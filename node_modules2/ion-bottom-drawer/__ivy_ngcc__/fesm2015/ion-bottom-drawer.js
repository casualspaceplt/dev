import { __decorate, __metadata } from 'tslib';
import { EventEmitter, Input, Output, Component, ElementRef, Renderer2, NgModule } from '@angular/core';
import { DomController, Platform, IonicModule } from '@ionic/angular';
import * as Hammer from 'hammerjs';
import { DIRECTION_VERTICAL } from 'hammerjs';

import * as ɵngcc0 from '@angular/core';
import * as ɵngcc1 from '@ionic/angular';

const _c0 = ["*"];
var DrawerState;
(function (DrawerState) {
    DrawerState[DrawerState["Bottom"] = 0] = "Bottom";
    DrawerState[DrawerState["Docked"] = 1] = "Docked";
    DrawerState[DrawerState["Top"] = 2] = "Top";
})(DrawerState || (DrawerState = {}));

let IonBottomDrawerComponent = class IonBottomDrawerComponent {
    constructor(_element, _renderer, _domCtrl, _platform) {
        this._element = _element;
        this._renderer = _renderer;
        this._domCtrl = _domCtrl;
        this._platform = _platform;
        this.dockedHeight = 50;
        this.shouldBounce = true;
        this.disableDrag = false;
        this.distanceTop = 0;
        this.transition = '0.25s ease-in-out';
        this.state = DrawerState.Bottom;
        this.minimumHeight = 0;
        this.stateChange = new EventEmitter();
        this._BOUNCE_DELTA = 30;
    }
    ngAfterViewInit() {
        this._renderer.setStyle(this._element.nativeElement.querySelector('.ion-bottom-drawer-scrollable-content :first-child'), 'touch-action', 'none');
        this._setDrawerState(this.state);
        const hammer = new Hammer(this._element.nativeElement);
        hammer.get('pan').set({ enable: true, direction: DIRECTION_VERTICAL });
        hammer.on('pan panstart panend', (ev) => {
            if (this.disableDrag) {
                return;
            }
            switch (ev.type) {
                case 'panstart':
                    this._handlePanStart();
                    break;
                case 'panend':
                    this._handlePanEnd(ev);
                    break;
                default:
                    this._handlePan(ev);
            }
        });
    }
    ngOnChanges(changes) {
        if (!changes.state) {
            return;
        }
        this._setDrawerState(changes.state.currentValue);
    }
    _setDrawerState(state) {
        this._renderer.setStyle(this._element.nativeElement, 'transition', this.transition);
        switch (state) {
            case DrawerState.Bottom:
                this._setTranslateY('calc(100vh - ' + this.minimumHeight + 'px)');
                break;
            case DrawerState.Docked:
                this._setTranslateY((this._platform.height() - this.dockedHeight) + 'px');
                break;
            default:
                this._setTranslateY(this.distanceTop + 'px');
        }
    }
    _handlePanStart() {
        this._startPositionTop = this._element.nativeElement.getBoundingClientRect().top;
    }
    _handlePanEnd(ev) {
        if (this.shouldBounce && ev.isFinal) {
            this._renderer.setStyle(this._element.nativeElement, 'transition', this.transition);
            switch (this.state) {
                case DrawerState.Docked:
                    this._handleDockedPanEnd(ev);
                    break;
                case DrawerState.Top:
                    this._handleTopPanEnd(ev);
                    break;
                default:
                    this._handleBottomPanEnd(ev);
            }
        }
        this.stateChange.emit(this.state);
    }
    _handleTopPanEnd(ev) {
        if (ev.deltaY > this._BOUNCE_DELTA) {
            this.state = DrawerState.Docked;
        }
        else {
            this._setTranslateY(this.distanceTop + 'px');
        }
    }
    _handleDockedPanEnd(ev) {
        const absDeltaY = Math.abs(ev.deltaY);
        if (absDeltaY > this._BOUNCE_DELTA && ev.deltaY < 0) {
            this.state = DrawerState.Top;
        }
        else if (absDeltaY > this._BOUNCE_DELTA && ev.deltaY > 0) {
            this.state = DrawerState.Bottom;
        }
        else {
            this._setTranslateY((this._platform.height() - this.dockedHeight) + 'px');
        }
    }
    _handleBottomPanEnd(ev) {
        if (-ev.deltaY > this._BOUNCE_DELTA) {
            this.state = DrawerState.Docked;
        }
        else {
            this._setTranslateY('calc(100vh - ' + this.minimumHeight + 'px)');
        }
    }
    _handlePan(ev) {
        const pointerY = ev.center.y;
        this._renderer.setStyle(this._element.nativeElement, 'transition', 'none');
        if (pointerY > 0 && pointerY < this._platform.height()) {
            if (ev.additionalEvent === 'panup' || ev.additionalEvent === 'pandown') {
                const newTop = this._startPositionTop + ev.deltaY;
                if (newTop >= this.distanceTop) {
                    this._setTranslateY(newTop + 'px');
                }
                else if (newTop < this.distanceTop) {
                    this._setTranslateY(this.distanceTop + 'px');
                }
                if (newTop > this._platform.height() - this.minimumHeight) {
                    this._setTranslateY((this._platform.height() - this.minimumHeight) + 'px');
                }
            }
        }
    }
    _setTranslateY(value) {
        this._domCtrl.write(() => {
            this._renderer.setStyle(this._element.nativeElement, 'transform', 'translateY(' + value + ')');
        });
    }
};
IonBottomDrawerComponent.ɵfac = function IonBottomDrawerComponent_Factory(t) { return new (t || IonBottomDrawerComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.DomController), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.Platform)); };
IonBottomDrawerComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: IonBottomDrawerComponent, selectors: [["ion-bottom-drawer"]], inputs: { dockedHeight: "dockedHeight", shouldBounce: "shouldBounce", disableDrag: "disableDrag", distanceTop: "distanceTop", transition: "transition", state: "state", minimumHeight: "minimumHeight" }, outputs: { stateChange: "stateChange" }, features: [ɵngcc0.ɵɵNgOnChangesFeature], ngContentSelectors: _c0, decls: 2, vars: 0, consts: [["no-bounce", "", 1, "ion-bottom-drawer-scrollable-content"]], template: function IonBottomDrawerComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵelementStart(0, "ion-content", 0);
        ɵngcc0.ɵɵprojection(1);
        ɵngcc0.ɵɵelementEnd();
    } }, directives: [ɵngcc1.IonContent], styles: ["[_nghost-%COMP%]{width:100%;height:100%;position:absolute;left:0;z-index:11!important;background-color:#fff;-webkit-transform:translateY(100vh);transform:translateY(100vh)}"] });
__decorate([
    Input(),
    __metadata("design:type", Object)
], IonBottomDrawerComponent.prototype, "dockedHeight", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], IonBottomDrawerComponent.prototype, "shouldBounce", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], IonBottomDrawerComponent.prototype, "disableDrag", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], IonBottomDrawerComponent.prototype, "distanceTop", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], IonBottomDrawerComponent.prototype, "transition", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number)
], IonBottomDrawerComponent.prototype, "state", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], IonBottomDrawerComponent.prototype, "minimumHeight", void 0);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], IonBottomDrawerComponent.prototype, "stateChange", void 0);
IonBottomDrawerComponent = __decorate([ __metadata("design:paramtypes", [ElementRef,
        Renderer2,
        DomController,
        Platform])
], IonBottomDrawerComponent);

let IonBottomDrawerModule = class IonBottomDrawerModule {
};
IonBottomDrawerModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: IonBottomDrawerModule });
IonBottomDrawerModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function IonBottomDrawerModule_Factory(t) { return new (t || IonBottomDrawerModule)(); }, imports: [[IonicModule]] });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(IonBottomDrawerComponent, [{
        type: Component,
        args: [{
                selector: 'ion-bottom-drawer',
                template: "<ion-content class=\"ion-bottom-drawer-scrollable-content\" no-bounce>\n  <ng-content></ng-content>\n</ion-content>\n",
                styles: [":host{width:100%;height:100%;position:absolute;left:0;z-index:11!important;background-color:#fff;-webkit-transform:translateY(100vh);transform:translateY(100vh)}"]
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc0.Renderer2 }, { type: ɵngcc1.DomController }, { type: ɵngcc1.Platform }]; }, { dockedHeight: [{
            type: Input
        }], shouldBounce: [{
            type: Input
        }], disableDrag: [{
            type: Input
        }], distanceTop: [{
            type: Input
        }], transition: [{
            type: Input
        }], state: [{
            type: Input
        }], minimumHeight: [{
            type: Input
        }], stateChange: [{
            type: Output
        }] }); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(IonBottomDrawerModule, { declarations: function () { return [IonBottomDrawerComponent]; }, imports: function () { return [IonicModule]; }, exports: function () { return [IonBottomDrawerComponent]; } }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(IonBottomDrawerModule, [{
        type: NgModule,
        args: [{
                declarations: [IonBottomDrawerComponent],
                imports: [IonicModule],
                exports: [IonBottomDrawerComponent]
            }]
    }], null, null); })();

/**
 * Generated bundle index. Do not edit.
 */

export { DrawerState, IonBottomDrawerModule, IonBottomDrawerComponent as ɵa };

//# sourceMappingURL=ion-bottom-drawer.js.map