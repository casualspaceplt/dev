{"code":"(window.webpackJsonp=window.webpackJsonp||[]).push([[3],{OB40:function(module,__webpack_exports__,__webpack_require__){\"use strict\";__webpack_require__.r(__webpack_exports__),__webpack_require__.d(__webpack_exports__,\"PlaceDetailPageModule\",function(){return place_detail_module_PlaceDetailPageModule});var router=__webpack_require__(\"tyNb\"),tslib_es6=__webpack_require__(\"mrSG\"),ionic_angular=__webpack_require__(\"TEn/\"),base_page=__webpack_require__(\"NV1z\"),core=__webpack_require__(\"fXoL\"),review_service=__webpack_require__(\"nFsf\"),ngx_bar_rating=__webpack_require__(\"Qsw1\"),fesm2015_forms=__webpack_require__(\"3Pt+\"),common=__webpack_require__(\"ofXK\"),ngx_translate_core=__webpack_require__(\"sYmb\");function ReviewAddPage_ion_spinner_15_Template(rf,ctx){1&rf&&core.Qb(0,\"ion-spinner\")}function ReviewAddPage_span_16_Template(rf,ctx){1&rf&&(core.Vb(0,\"span\"),core.Gc(1),core.gc(2,\"translate\"),core.Ub()),2&rf&&(core.Db(1),core.Hc(core.hc(2,1,\"SUBMIT\")))}let review_add_ReviewAddPage=(()=>{class ReviewAddPage extends base_page.a{constructor(injector,reviewService){super(injector),this.reviewService=reviewService,this.review={rating:3,comment:\"\"}}enableMenuSwipe(){return!1}onSubmit(){return Object(tslib_es6.a)(this,void 0,void 0,function*(){if(this.review.rating)try{yield this.showLoadingView({showOverlay:!1}),this.review.place=this.place;const review=yield this.reviewService.create(this.review);this.translate.get(\"REVIEW_ADDED\").subscribe(str=>this.showToast(str)),this.showContentView(),\"Published\"===review.status?this.onDismiss(review):this.onDismiss()}catch(err){this.showContentView(),5e3===err.code?this.translate.get(\"REVIEW_ALREADY_EXISTS\").subscribe(str=>this.showToast(str)):5003===err.code?this.translate.get(\"REVIEWS_DISABLED\").subscribe(str=>this.showToast(str)):this.translate.get(\"ERROR_NETWORK\").subscribe(str=>this.showToast(str))}else{const message=yield this.getTrans(\"PLEASE_SELECT_A_RATING\");this.showToast(message)}})}onDismiss(review=null){this.modalCtrl.dismiss(review)}}return ReviewAddPage.ɵfac=function(t){return new(t||ReviewAddPage)(core.Pb(core.t),core.Pb(review_service.a))},ReviewAddPage.ɵcmp=core.Jb({type:ReviewAddPage,selectors:[[\"page-review-add\"]],inputs:{place:\"place\"},features:[core.Ab],decls:17,vars:14,consts:[[1,\"ion-no-border\"],[\"color\",\"primary\"],[\"slot\",\"end\"],[\"fill\",\"clear\",3,\"click\"],[\"name\",\"close\"],[1,\"ion-padding\"],[1,\"ion-text-center\"],[1,\"rating\",3,\"rate\",\"readOnly\",\"max\",\"theme\",\"rateChange\"],[\"lines\",\"none\",\"color\",\"light\",1,\"radius\",\"ion-margin-vertical\"],[\"rows\",\"8\",3,\"ngModel\",\"placeholder\",\"ngModelChange\",\"keyup.enter\"],[\"strong\",\"\",\"shape\",\"round\",\"color\",\"secondary\",3,\"disabled\",\"click\"],[4,\"ngIf\"]],template:function(rf,ctx){1&rf&&(core.Vb(0,\"ion-header\",0),core.Vb(1,\"ion-toolbar\",1),core.Vb(2,\"ion-buttons\",2),core.Vb(3,\"ion-button\",3),core.dc(\"click\",function(){return ctx.onDismiss()}),core.Qb(4,\"ion-icon\",4),core.Ub(),core.Ub(),core.Vb(5,\"ion-title\"),core.Gc(6),core.gc(7,\"translate\"),core.Ub(),core.Ub(),core.Ub(),core.Vb(8,\"ion-content\",5),core.Vb(9,\"div\",6),core.Vb(10,\"bar-rating\",7),core.dc(\"rateChange\",function($event){return ctx.review.rating=$event}),core.Ub(),core.Vb(11,\"ion-item\",8),core.Vb(12,\"ion-textarea\",9),core.dc(\"ngModelChange\",function($event){return ctx.review.comment=$event})(\"keyup.enter\",function(){return ctx.onSubmit()}),core.gc(13,\"translate\"),core.Ub(),core.Ub(),core.Vb(14,\"ion-button\",10),core.dc(\"click\",function(){return ctx.onSubmit()}),core.Ec(15,ReviewAddPage_ion_spinner_15_Template,1,0,\"ion-spinner\",11),core.Ec(16,ReviewAddPage_span_16_Template,3,3,\"span\",11),core.Ub(),core.Ub(),core.Ub()),2&rf&&(core.Db(6),core.Ic(\" \",core.hc(7,10,\"ADD_REVIEW\"),\" \"),core.Db(4),core.lc(\"rate\",ctx.review.rating)(\"readOnly\",!1)(\"max\",5)(\"theme\",\"stars\"),core.Db(2),core.lc(\"ngModel\",ctx.review.comment)(\"placeholder\",core.hc(13,12,\"COMMENT\")),core.Db(2),core.lc(\"disabled\",ctx.isLoadingViewVisible),core.Db(1),core.lc(\"ngIf\",ctx.isLoadingViewVisible),core.Db(1),core.lc(\"ngIf\",!ctx.isLoadingViewVisible))},directives:[ionic_angular.w,ionic_angular.db,ionic_angular.l,ionic_angular.k,ionic_angular.x,ionic_angular.bb,ionic_angular.r,ngx_bar_rating.a,ionic_angular.B,ionic_angular.Z,ionic_angular.nb,fesm2015_forms.i,fesm2015_forms.k,common.m,ionic_angular.U],pipes:[ngx_translate_core.c],styles:[\"ion-content[_ngcontent-%COMP%]{--padding-top:60px}ion-item[_ngcontent-%COMP%]{--border-radius:4px;margin-top:40px}\"]}),ReviewAddPage})();var user_service=__webpack_require__(\"dexi\"),sign_in=__webpack_require__(\"GvuD\"),Subject=__webpack_require__(\"XNiG\"),merge=__webpack_require__(\"VRyK\"),environment=__webpack_require__(\"AytR\"),share_page=__webpack_require__(\"7asV\"),parse=__webpack_require__(\"v0iw\");let report_service_Report=(()=>{class Report extends parse.Object{constructor(){super(\"Report\")}set reason(reason){this.set(\"reason\",reason)}get reason(){return this.get(\"reason\")}set place(place){this.set(\"place\",place)}get place(){return this.get(\"place\")}set reportedBy(user){this.set(\"reportedBy\",user)}get reportedBy(){return this.get(\"reportedBy\")}}return Report.ɵfac=function(t){return new(t||Report)},Report.ɵprov=core.Lb({token:Report,factory:Report.ɵfac,providedIn:\"root\"}),Report})();parse.Object.registerSubclass(\"Report\",report_service_Report);var BehaviorSubject=__webpack_require__(\"2Vo4\"),of=__webpack_require__(\"LRne\"),empty=__webpack_require__(\"EY2u\"),Subscription=__webpack_require__(\"quSY\"),fromEvent=__webpack_require__(\"xgIS\"),fromArray=__webpack_require__(\"yCtX\"),isArray=__webpack_require__(\"DH7j\"),Subscriber=__webpack_require__(\"7o/Q\"),OuterSubscriber=__webpack_require__(\"l7GE\"),subscribeToResult=__webpack_require__(\"ZUHj\"),iterator=__webpack_require__(\"Lhse\");class ZipOperator{constructor(resultSelector){this.resultSelector=resultSelector}call(subscriber,source){return source.subscribe(new zip_ZipSubscriber(subscriber,this.resultSelector))}}class zip_ZipSubscriber extends Subscriber.a{constructor(destination,resultSelector,values=Object.create(null)){super(destination),this.iterators=[],this.active=0,this.resultSelector=\"function\"==typeof resultSelector?resultSelector:null,this.values=values}_next(value){const iterators=this.iterators;Object(isArray.a)(value)?iterators.push(new zip_StaticArrayIterator(value)):iterators.push(\"function\"==typeof value[iterator.a]?new StaticIterator(value[iterator.a]()):new zip_ZipBufferIterator(this.destination,this,value))}_complete(){const iterators=this.iterators,len=iterators.length;if(this.unsubscribe(),0!==len){this.active=len;for(let i=0;i<len;i++){let iterator=iterators[i];iterator.stillUnsubscribed?this.destination.add(iterator.subscribe(iterator,i)):this.active--}}else this.destination.complete()}notifyInactive(){this.active--,0===this.active&&this.destination.complete()}checkIterators(){const iterators=this.iterators,len=iterators.length,destination=this.destination;for(let i=0;i<len;i++){let iterator=iterators[i];if(\"function\"==typeof iterator.hasValue&&!iterator.hasValue())return}let shouldComplete=!1;const args=[];for(let i=0;i<len;i++){let iterator=iterators[i],result=iterator.next();if(iterator.hasCompleted()&&(shouldComplete=!0),result.done)return void destination.complete();args.push(result.value)}this.resultSelector?this._tryresultSelector(args):destination.next(args),shouldComplete&&destination.complete()}_tryresultSelector(args){let result;try{result=this.resultSelector.apply(this,args)}catch(err){return void this.destination.error(err)}this.destination.next(result)}}class StaticIterator{constructor(iterator){this.iterator=iterator,this.nextResult=iterator.next()}hasValue(){return!0}next(){const result=this.nextResult;return this.nextResult=this.iterator.next(),result}hasCompleted(){const nextResult=this.nextResult;return nextResult&&nextResult.done}}class zip_StaticArrayIterator{constructor(array){this.array=array,this.index=0,this.length=0,this.length=array.length}[iterator.a](){return this}next(value){const i=this.index++;return i<this.length?{value:this.array[i],done:!1}:{value:null,done:!0}}hasValue(){return this.array.length>this.index}hasCompleted(){return this.array.length===this.index}}class zip_ZipBufferIterator extends OuterSubscriber.a{constructor(destination,parent,observable){super(destination),this.parent=parent,this.observable=observable,this.stillUnsubscribed=!0,this.buffer=[],this.isComplete=!1}[iterator.a](){return this}next(){const buffer=this.buffer;return 0===buffer.length&&this.isComplete?{value:null,done:!0}:{value:buffer.shift(),done:!1}}hasValue(){return this.buffer.length>0}hasCompleted(){return 0===this.buffer.length&&this.isComplete}notifyComplete(){this.buffer.length>0?(this.isComplete=!0,this.parent.notifyInactive()):this.destination.complete()}notifyNext(outerValue,innerValue,outerIndex,innerIndex,innerSub){this.buffer.push(innerValue),this.parent.checkIterators()}subscribe(value,index){return Object(subscribeToResult.a)(this,this.observable,this,index)}}var filter=__webpack_require__(\"pLZG\"),switchMap=__webpack_require__(\"eIep\"),operators_delay=__webpack_require__(\"3E0/\"),tap=__webpack_require__(\"vkgz\"),map=__webpack_require__(\"lJxs\"),scheduler_async=__webpack_require__(\"D0XW\");function debounceTime(dueTime,scheduler=scheduler_async.a){return source=>source.lift(new DebounceTimeOperator(dueTime,scheduler))}class DebounceTimeOperator{constructor(dueTime,scheduler){this.dueTime=dueTime,this.scheduler=scheduler}call(subscriber,source){return source.subscribe(new debounceTime_DebounceTimeSubscriber(subscriber,this.dueTime,this.scheduler))}}class debounceTime_DebounceTimeSubscriber extends Subscriber.a{constructor(destination,dueTime,scheduler){super(destination),this.dueTime=dueTime,this.scheduler=scheduler,this.debouncedSubscription=null,this.lastValue=null,this.hasValue=!1}_next(value){this.clearDebounce(),this.lastValue=value,this.hasValue=!0,this.add(this.debouncedSubscription=this.scheduler.schedule(dispatchNext,this.dueTime,this))}_complete(){this.debouncedNext(),this.destination.complete()}debouncedNext(){if(this.clearDebounce(),this.hasValue){const{lastValue:lastValue}=this;this.lastValue=null,this.hasValue=!1,this.destination.next(lastValue)}}clearDebounce(){const debouncedSubscription=this.debouncedSubscription;null!==debouncedSubscription&&(this.remove(debouncedSubscription),debouncedSubscription.unsubscribe(),this.debouncedSubscription=null)}}function dispatchNext(subscriber){subscriber.debouncedNext()}var animations=__webpack_require__(\"R0Ic\"),platform_browser=__webpack_require__(\"jhN1\");const _c0=[\"*\"],_c1=[\"iframe\"];function GalleryImageComponent_div_2_Template(rf,ctx){if(1&rf&&core.Qb(0,\"div\",4),2&rf){const ctx_r0=core.fc();core.Bc(\"background-image\",ctx_r0.imageUrl),core.lc(\"@fadeIn\",void 0)}}function GalleryImageComponent_div_3_div_1_Template(rf,ctx){if(1&rf&&core.Qb(0,\"div\",8),2&rf){const ctx_r3=core.fc(2);core.lc(\"innerHTML\",ctx_r3.errorTemplate,core.wc)}}function GalleryImageComponent_div_3_ng_template_2_ng_container_0_Template(rf,ctx){1&rf&&(core.Tb(0),core.Vb(1,\"h4\"),core.Gc(2,\"⚠\"),core.Ub(),core.Sb())}function GalleryImageComponent_div_3_ng_template_2_ng_template_1_Template(rf,ctx){1&rf&&(core.Vb(0,\"h2\"),core.Gc(1,\"⚠\"),core.Ub(),core.Vb(2,\"p\"),core.Gc(3,\"Unable to load the image!\"),core.Ub())}function GalleryImageComponent_div_3_ng_template_2_Template(rf,ctx){if(1&rf&&(core.Ec(0,GalleryImageComponent_div_3_ng_template_2_ng_container_0_Template,3,0,\"ng-container\",9),core.Ec(1,GalleryImageComponent_div_3_ng_template_2_ng_template_1_Template,4,0,\"ng-template\",null,10,core.Fc)),2&rf){const _r7=core.uc(2),ctx_r5=core.fc(2);core.lc(\"ngIf\",ctx_r5.isThumbnail)(\"ngIfElse\",_r7)}}function GalleryImageComponent_div_3_Template(rf,ctx){if(1&rf&&(core.Vb(0,\"div\",5),core.Ec(1,GalleryImageComponent_div_3_div_1_Template,1,1,\"div\",6),core.Ec(2,GalleryImageComponent_div_3_ng_template_2_Template,3,2,\"ng-template\",null,7,core.Fc),core.Ub()),2&rf){const _r4=core.uc(3),ctx_r1=core.fc();core.Db(1),core.lc(\"ngIf\",ctx_r1.errorTemplate)(\"ngIfElse\",_r4)}}function GalleryImageComponent_ng_container_4_div_1_Template(rf,ctx){if(1&rf&&core.Qb(0,\"div\",13),2&rf){const ctx_r9=core.fc(2);core.lc(\"innerHTML\",ctx_r9.loaderTemplate,core.wc)}}function GalleryImageComponent_ng_container_4_ng_template_2_div_0_Template(rf,ctx){1&rf&&core.Qb(0,\"div\",15)}function GalleryImageComponent_ng_container_4_ng_template_2_Template(rf,ctx){if(1&rf&&core.Ec(0,GalleryImageComponent_ng_container_4_ng_template_2_div_0_Template,1,0,\"div\",14),2&rf){const ctx_r11=core.fc(2);core.lc(\"ngIf\",ctx_r11.isThumbnail)}}function GalleryImageComponent_ng_container_4_Template(rf,ctx){if(1&rf&&(core.Tb(0),core.Ec(1,GalleryImageComponent_ng_container_4_div_1_Template,1,1,\"div\",11),core.Ec(2,GalleryImageComponent_ng_container_4_ng_template_2_Template,1,1,\"ng-template\",null,12,core.Fc),core.Sb()),2&rf){const _r10=core.uc(3),ctx_r2=core.fc();core.Db(1),core.lc(\"ngIf\",ctx_r2.loaderTemplate)(\"ngIfElse\",_r10)}}const _c2=[\"video\"];function GalleryVideoComponent_source_2_Template(rf,ctx){if(1&rf&&core.Qb(0,\"source\",3),2&rf){const src_r2=ctx.$implicit;core.lc(\"src\",null==src_r2?null:src_r2.url,core.zc)(\"type\",null==src_r2?null:src_r2.type)}}function GalleryNavComponent_i_0_Template(rf,ctx){if(1&rf){const _r3=core.Wb();core.Vb(0,\"i\",2),core.dc(\"tapClick\",function(){return core.vc(_r3),core.fc().action.emit(\"prev\")}),core.Ub()}if(2&rf){const ctx_r0=core.fc();core.lc(\"innerHtml\",ctx_r0.navIcon,core.wc)}}function GalleryNavComponent_i_1_Template(rf,ctx){if(1&rf){const _r5=core.Wb();core.Vb(0,\"i\",3),core.dc(\"tapClick\",function(){return core.vc(_r5),core.fc().action.emit(\"next\")}),core.Ub()}if(2&rf){const ctx_r1=core.fc();core.lc(\"innerHtml\",ctx_r1.navIcon,core.wc)}}function GalleryCoreComponent_gallery_thumbs_0_Template(rf,ctx){if(1&rf){const _r5=core.Wb();core.Vb(0,\"gallery-thumbs\",5),core.dc(\"action\",function($event){return core.vc(_r5),core.fc().action.emit($event)})(\"thumbClick\",function($event){return core.vc(_r5),core.fc().thumbClick.emit($event)}),core.Ub()}if(2&rf){const ctx_r0=core.fc();core.lc(\"state\",ctx_r0.state)(\"config\",ctx_r0.config)}}function GalleryCoreComponent_gallery_nav_3_Template(rf,ctx){if(1&rf){const _r8=core.Wb();core.Vb(0,\"gallery-nav\",6),core.dc(\"action\",function($event){return core.vc(_r8),core.fc().action.emit($event)}),core.Ub()}if(2&rf){const ctx_r1=core.fc();core.lc(\"state\",ctx_r1.state)(\"config\",ctx_r1.config)}}function GalleryCoreComponent_gallery_dots_4_Template(rf,ctx){if(1&rf){const _r10=core.Wb();core.Vb(0,\"gallery-dots\",6),core.dc(\"action\",function($event){return core.vc(_r10),core.fc().action.emit($event)}),core.Ub()}if(2&rf){const ctx_r2=core.fc();core.lc(\"state\",ctx_r2.state)(\"config\",ctx_r2.config)}}function GalleryCoreComponent_gallery_counter_5_Template(rf,ctx){if(1&rf&&core.Qb(0,\"gallery-counter\",7),2&rf){const ctx_r3=core.fc();core.lc(\"state\",ctx_r3.state)}}function GalleryDotsComponent_div_0_Template(rf,ctx){if(1&rf){const _r4=core.Wb();core.Vb(0,\"div\",1),core.dc(\"tapClick\",function(){core.vc(_r4);const i_r2=ctx.index;return core.fc().action.emit(i_r2)}),core.Qb(1,\"div\",2),core.Ub()}if(2&rf){const i_r2=ctx.index,ctx_r0=core.fc();core.Bc(\"width\",null==ctx_r0.config?null:ctx_r0.config.dotsSize,\"px\")(\"height\",null==ctx_r0.config?null:ctx_r0.config.dotsSize,\"px\"),core.Hb(\"g-dot-active\",i_r2===ctx_r0.state.currIndex)}}function GalleryThumbsComponent_div_0_gallery_thumb_2_Template(rf,ctx){if(1&rf){const _r6=core.Wb();core.Vb(0,\"gallery-thumb\",4),core.dc(\"tapClick\",function(){core.vc(_r6);const i_r4=ctx.index;return core.fc(2).thumbClick.emit(i_r4)})(\"error\",function($event){core.vc(_r6);const i_r4=ctx.index;return core.fc(2).error.emit({itemIndex:i_r4,error:$event})}),core.Ub()}if(2&rf){const item_r3=ctx.$implicit,i_r4=ctx.index,ctx_r2=core.fc(2);core.lc(\"type\",item_r3.type)(\"config\",ctx_r2.config)(\"data\",item_r3.data)(\"currIndex\",ctx_r2.state.currIndex)(\"index\",i_r4)(\"tapClickDisabled\",ctx_r2.config.disableThumb)}}function GalleryThumbsComponent_div_0_Template(rf,ctx){if(1&rf&&(core.Vb(0,\"div\",1),core.Vb(1,\"div\",2),core.Ec(2,GalleryThumbsComponent_div_0_gallery_thumb_2_Template,1,6,\"gallery-thumb\",3),core.Ub(),core.Ub()),2&rf){const sliderState_r1=ctx.$implicit,ctx_r0=core.fc();core.Db(1),core.Hb(\"g-no-transition\",sliderState_r1.active),core.lc(\"ngStyle\",sliderState_r1.style),core.Db(1),core.lc(\"ngForOf\",ctx_r0.state.items)}}function GallerySliderComponent_div_0_gallery_item_2_Template(rf,ctx){if(1&rf){const _r6=core.Wb();core.Vb(0,\"gallery-item\",4),core.dc(\"tapClick\",function(){core.vc(_r6);const i_r4=ctx.index;return core.fc(2).itemClick.emit(i_r4)})(\"error\",function($event){core.vc(_r6);const i_r4=ctx.index;return core.fc(2).error.emit({itemIndex:i_r4,error:$event})}),core.Ub()}if(2&rf){const item_r3=ctx.$implicit,i_r4=ctx.index,ctx_r2=core.fc(2);core.lc(\"type\",item_r3.type)(\"config\",ctx_r2.config)(\"data\",item_r3.data)(\"currIndex\",ctx_r2.state.currIndex)(\"index\",i_r4)}}function GallerySliderComponent_div_0_Template(rf,ctx){if(1&rf&&(core.Vb(0,\"div\",1),core.Vb(1,\"div\",2),core.Ec(2,GallerySliderComponent_div_0_gallery_item_2_Template,1,5,\"gallery-item\",3),core.Ub(),core.Ub()),2&rf){const sliderState_r1=ctx.$implicit,ctx_r0=core.fc();core.lc(\"ngStyle\",ctx_r0.zoom),core.Db(1),core.Hb(\"g-no-transition\",sliderState_r1.active),core.lc(\"ngStyle\",sliderState_r1.style),core.Db(1),core.lc(\"ngForOf\",ctx_r0.state.items)}}function GalleryItemComponent_ng_container_0_ng_container_1_ng_container_3_Template(rf,ctx){1&rf&&core.Rb(0)}const _c3=function(a0,a1,a2,a3){return{index:a0,currIndex:a1,type:a2,data:a3}};function GalleryItemComponent_ng_container_0_ng_container_1_Template(rf,ctx){if(1&rf){const _r8=core.Wb();core.Tb(0),core.Vb(1,\"gallery-image\",7),core.dc(\"error\",function($event){return core.vc(_r8),core.fc(2).error.emit($event)}),core.Ub(),core.Vb(2,\"div\",8),core.Ec(3,GalleryItemComponent_ng_container_0_ng_container_1_ng_container_3_Template,1,0,\"ng-container\",9),core.Ub(),core.Sb()}if(2&rf){const ctx_r1=core.fc(2);core.Db(1),core.lc(\"src\",ctx_r1.data.src)(\"loadingIcon\",ctx_r1.config.loadingIcon)(\"loadingError\",ctx_r1.config.loadingError),core.Db(2),core.lc(\"ngTemplateOutlet\",ctx_r1.config.itemTemplate)(\"ngTemplateOutletContext\",core.sc(5,_c3,ctx_r1.index,ctx_r1.currIndex,ctx_r1.type,ctx_r1.data))}}function GalleryItemComponent_ng_container_0_gallery_video_2_Template(rf,ctx){if(1&rf){const _r10=core.Wb();core.Vb(0,\"gallery-video\",10),core.dc(\"error\",function($event){return core.vc(_r10),core.fc(2).error.emit($event)}),core.Ub()}if(2&rf){const ctx_r2=core.fc(2);core.lc(\"src\",ctx_r2.data.src)(\"poster\",ctx_r2.data.poster)(\"controls\",ctx_r2.data.controls)(\"play\",ctx_r2.isAutoPlay)(\"pause\",ctx_r2.currIndex!==ctx_r2.index)}}function GalleryItemComponent_ng_container_0_gallery_iframe_3_Template(rf,ctx){if(1&rf&&core.Qb(0,\"gallery-iframe\",11),2&rf){const ctx_r3=core.fc(2);core.lc(\"src\",ctx_r3.youtubeSrc)(\"autoplay\",ctx_r3.isAutoPlay)(\"pause\",ctx_r3.currIndex!==ctx_r3.index)}}function GalleryItemComponent_ng_container_0_gallery_iframe_4_Template(rf,ctx){if(1&rf&&core.Qb(0,\"gallery-iframe\",12),2&rf){const ctx_r4=core.fc(2);core.lc(\"src\",ctx_r4.data.src)}}function GalleryItemComponent_ng_container_0_ng_container_5_ng_container_2_Template(rf,ctx){1&rf&&core.Rb(0)}function GalleryItemComponent_ng_container_0_ng_container_5_Template(rf,ctx){if(1&rf&&(core.Tb(0),core.Vb(1,\"div\",8),core.Ec(2,GalleryItemComponent_ng_container_0_ng_container_5_ng_container_2_Template,1,0,\"ng-container\",9),core.Ub(),core.Sb()),2&rf){const ctx_r5=core.fc(2);core.Db(2),core.lc(\"ngTemplateOutlet\",ctx_r5.config.itemTemplate)(\"ngTemplateOutletContext\",core.sc(2,_c3,ctx_r5.index,ctx_r5.currIndex,ctx_r5.type,ctx_r5.data))}}function GalleryItemComponent_ng_container_0_Template(rf,ctx){if(1&rf&&(core.Tb(0,1),core.Ec(1,GalleryItemComponent_ng_container_0_ng_container_1_Template,4,10,\"ng-container\",2),core.Ec(2,GalleryItemComponent_ng_container_0_gallery_video_2_Template,1,5,\"gallery-video\",3),core.Ec(3,GalleryItemComponent_ng_container_0_gallery_iframe_3_Template,1,3,\"gallery-iframe\",4),core.Ec(4,GalleryItemComponent_ng_container_0_gallery_iframe_4_Template,1,1,\"gallery-iframe\",5),core.Ec(5,GalleryItemComponent_ng_container_0_ng_container_5_Template,3,7,\"ng-container\",6),core.Sb()),2&rf){const ctx_r0=core.fc();core.lc(\"ngSwitch\",ctx_r0.type),core.Db(1),core.lc(\"ngSwitchCase\",ctx_r0.Types.Image),core.Db(1),core.lc(\"ngSwitchCase\",ctx_r0.Types.Video),core.Db(1),core.lc(\"ngSwitchCase\",ctx_r0.Types.Youtube),core.Db(1),core.lc(\"ngSwitchCase\",ctx_r0.Types.Iframe)}}function GalleryThumbComponent_div_1_ng_container_1_Template(rf,ctx){1&rf&&core.Rb(0)}const _c4=function(a0,a1,a2){return{index:a0,type:a1,data:a2}};function GalleryThumbComponent_div_1_Template(rf,ctx){if(1&rf&&(core.Vb(0,\"div\",2),core.Ec(1,GalleryThumbComponent_div_1_ng_container_1_Template,1,0,\"ng-container\",3),core.Ub()),2&rf){const ctx_r0=core.fc();core.Db(1),core.lc(\"ngTemplateOutlet\",ctx_r0.config.thumbTemplate)(\"ngTemplateOutletContext\",core.rc(2,_c4,ctx_r0.index,ctx_r0.type,ctx_r0.data))}}var GalleryAction=function(GalleryAction){return GalleryAction.INITIALIZED=\"initialized\",GalleryAction.ITEMS_CHANGED=\"itemsChanged\",GalleryAction.INDEX_CHANGED=\"indexChanged\",GalleryAction.PLAY=\"play\",GalleryAction.STOP=\"stop\",GalleryAction}({}),ImageSize=function(ImageSize){return ImageSize.Cover=\"cover\",ImageSize.Contain=\"contain\",ImageSize}({}),LoadingStrategy=function(LoadingStrategy){return LoadingStrategy.Preload=\"preload\",LoadingStrategy.Lazy=\"lazy\",LoadingStrategy.Default=\"default\",LoadingStrategy}({}),ThumbnailsPosition=function(ThumbnailsPosition){return ThumbnailsPosition.Top=\"top\",ThumbnailsPosition.Left=\"left\",ThumbnailsPosition.Right=\"right\",ThumbnailsPosition.Bottom=\"bottom\",ThumbnailsPosition}({}),DotsPosition=function(DotsPosition){return DotsPosition.Top=\"top\",DotsPosition.Bottom=\"bottom\",DotsPosition}({}),CounterPosition=function(CounterPosition){return CounterPosition.Top=\"top\",CounterPosition.Bottom=\"bottom\",CounterPosition}({}),ThumbnailsMode=function(ThumbnailsMode){return ThumbnailsMode.Free=\"free\",ThumbnailsMode.Strict=\"strict\",ThumbnailsMode}({}),SlidingDirection=function(SlidingDirection){return SlidingDirection.Horizontal=\"horizontal\",SlidingDirection.Vertical=\"vertical\",SlidingDirection}({}),GalleryItemType=function(GalleryItemType){return GalleryItemType.Image=\"image\",GalleryItemType.Video=\"video\",GalleryItemType.Youtube=\"youtube\",GalleryItemType.Iframe=\"iframe\",GalleryItemType}({});const defaultState={action:GalleryAction.INITIALIZED,isPlaying:!1,hasNext:!1,hasPrev:!1,currIndex:0,items:[]},defaultConfig={nav:!0,loop:!0,zoomOut:0,dots:!1,thumb:!0,dotsSize:30,counter:!0,gestures:!0,autoPlay:!1,thumbWidth:120,thumbHeight:90,panSensitivity:25,disableThumb:!1,playerInterval:3e3,imageSize:ImageSize.Contain,thumbMode:ThumbnailsMode.Strict,dotsPosition:DotsPosition.Bottom,counterPosition:CounterPosition.Top,thumbPosition:ThumbnailsPosition.Bottom,loadingStrategy:LoadingStrategy.Default,slidingDirection:SlidingDirection.Horizontal,navIcon:'<?xml version=\"1.0\" encoding=\"UTF-8\"?><svg width=\"512px\" height=\"512px\" enable-background=\"new 0 0 240.823 240.823\" version=\"1.1\" viewBox=\"0 0 240.823 240.823\" xml:space=\"preserve\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"m183.19 111.82l-108.3-108.26c-4.752-4.74-12.451-4.74-17.215 0-4.752 4.74-4.752 12.439 0 17.179l99.707 99.671-99.695 99.671c-4.752 4.74-4.752 12.439 0 17.191 4.752 4.74 12.463 4.74 17.215 0l108.3-108.26c4.68-4.691 4.68-12.511-0.012-17.19z\" fill=\"#fff\"/></svg>',loadingIcon:'<?xml version=\"1.0\" encoding=\"UTF-8\"?><svg stroke=\"#fff\" viewBox=\"0 0 44 44\" xmlns=\"http://www.w3.org/2000/svg\"><g fill=\"none\" fill-rule=\"evenodd\" stroke-width=\"2\"><circle cx=\"22\" cy=\"22\" r=\"1\"><animate attributeName=\"r\" begin=\"0s\" calcMode=\"spline\" dur=\"1.8s\" keySplines=\"0.165, 0.84, 0.44, 1\" keyTimes=\"0; 1\" repeatCount=\"indefinite\" values=\"1; 20\"/><animate attributeName=\"stroke-opacity\" begin=\"0s\" calcMode=\"spline\" dur=\"1.8s\" keySplines=\"0.3, 0.61, 0.355, 1\" keyTimes=\"0; 1\" repeatCount=\"indefinite\" values=\"1; 0\"/></circle><circle cx=\"22\" cy=\"22\" r=\"1\"><animate attributeName=\"r\" begin=\"-0.9s\" calcMode=\"spline\" dur=\"1.8s\" keySplines=\"0.165, 0.84, 0.44, 1\" keyTimes=\"0; 1\" repeatCount=\"indefinite\" values=\"1; 20\"/><animate attributeName=\"stroke-opacity\" begin=\"-0.9s\" calcMode=\"spline\" dur=\"1.8s\" keySplines=\"0.3, 0.61, 0.355, 1\" keyTimes=\"0; 1\" repeatCount=\"indefinite\" values=\"1; 0\"/></circle></g></svg>'};class ImageItem{constructor(data){this.data=data,this.type=GalleryItemType.Image}}class VideoItem{constructor(data){this.data=data,this.type=GalleryItemType.Video}}class IframeItem{constructor(data){this.data=data,this.type=GalleryItemType.Iframe}}class YoutubeItem{constructor(data){this.data=Object.assign(Object.assign({},data),{src:`https://youtube.com/embed/${data.src}`,thumb:data.thumb?data.thumb:`//img.youtube.com/vi/${data.src}/default.jpg`}),this.type=GalleryItemType.Youtube}}const filterActions=actions=>Object(filter.a)(state=>actions.indexOf(state.action)>-1);class ng_gallery_GalleryRef{constructor(config,deleteInstance){this.deleteInstance=deleteInstance,this.itemClick=new Subject.a,this.thumbClick=new Subject.a,this.error=new Subject.a,this._state=new BehaviorSubject.a(defaultState),this._config=new BehaviorSubject.a(config),this.state=this._state.asObservable(),this.config=this._config.asObservable()}get initialized(){return this.state.pipe(filterActions([GalleryAction.INITIALIZED]))}get itemsChanged(){return this.state.pipe(filterActions([GalleryAction.ITEMS_CHANGED]))}get indexChanged(){return this.state.pipe(filterActions([GalleryAction.INDEX_CHANGED]))}get playingChanged(){return this.state.pipe(filterActions([GalleryAction.PLAY,GalleryAction.STOP]))}get playerActions(){return this.state.pipe(filterActions([GalleryAction.PLAY,GalleryAction.STOP,GalleryAction.INDEX_CHANGED]))}activatePlayer(){return this.playerActions.pipe(Object(switchMap.a)(e=>e.isPlaying?Object(of.a)({}).pipe(Object(operators_delay.a)(this._config.value.playerInterval),Object(tap.a)(()=>this.next())):empty.a))}setState(state){this._state.next(Object.assign(Object.assign({},this._state.value),state))}setConfig(config){this._config.next(Object.assign(Object.assign({},this._config.value),config))}add(item,active){const items=[...this._state.value.items,item];this.setState({action:GalleryAction.ITEMS_CHANGED,items:items,hasNext:items.length>1,currIndex:active?items.length-1:this._state.value.currIndex})}addImage(data,active){this.add(new ImageItem(data),active)}addVideo(data,active){this.add(new VideoItem(data),active)}addIframe(data,active){this.add(new IframeItem(data),active)}addYoutube(data,active){this.add(new YoutubeItem(data),active)}remove(i){const items=[...this._state.value.items.slice(0,i),...this._state.value.items.slice(i+1,this._state.value.items.length)];this.setState({action:GalleryAction.ITEMS_CHANGED,items:items,hasNext:items.length>1,hasPrev:i>0})}load(items){items&&this.setState({action:GalleryAction.ITEMS_CHANGED,items:items,hasNext:items.length>1,hasPrev:!1})}set(i){i!==this._state.value.currIndex&&this.setState({action:GalleryAction.INDEX_CHANGED,currIndex:i,hasNext:i<this._state.value.items.length-1,hasPrev:i>0})}next(){this._state.value.hasNext?this.set(this._state.value.currIndex+1):this._config.value.loop&&this.set(0)}prev(){this._state.value.hasPrev?this.set(this._state.value.currIndex-1):this._config.value.loop&&this.set(this._state.value.items.length-1)}play(interval){interval&&this.setConfig({playerInterval:interval}),this.setState({action:GalleryAction.PLAY,isPlaying:!0})}stop(){this.setState({action:GalleryAction.STOP,isPlaying:!1})}reset(){this.setState(defaultState)}destroy(){this._state.complete(),this._config.complete(),this.itemClick.complete(),this.thumbClick.complete(),this.deleteInstance()}}const GALLERY_CONFIG=new core.s(\"GALLERY_CONFIG\");let ng_gallery_Gallery=(()=>{class Gallery{constructor(config){this._instances=new Map,this.config=config?Object.assign(Object.assign({},defaultConfig),config):defaultConfig}ref(id=\"root\",config){if(this._instances.has(id)){const galleryRef=this._instances.get(id);return config&&galleryRef.setConfig(Object.assign(Object.assign({},this.config),config)),galleryRef}return this._instances.set(id,new ng_gallery_GalleryRef(Object.assign(Object.assign({},this.config),config),this.deleteInstance(id))).get(id)}destroyAll(){this._instances.forEach(ref=>ref.destroy())}resetAll(){this._instances.forEach(ref=>ref.reset())}deleteInstance(id){return()=>{this._instances.has(id)&&this._instances.delete(id)}}}return Gallery.ɵfac=function(t){return new(t||Gallery)(core.Zb(GALLERY_CONFIG,8))},Gallery.ɵprov=Object(core.Lb)({factory:function(){return new Gallery(Object(core.Zb)(GALLERY_CONFIG,8))},token:Gallery,providedIn:\"root\"}),Gallery})(),ng_gallery_GalleryComponent=(()=>{class GalleryComponent{constructor(_gallery){this._gallery=_gallery,this.nav=this._gallery.config.nav,this.dots=this._gallery.config.dots,this.loop=this._gallery.config.loop,this.thumb=this._gallery.config.thumb,this.zoomOut=this._gallery.config.zoomOut,this.counter=this._gallery.config.counter,this.dotsSize=this._gallery.config.dotsSize,this.autoPlay=this._gallery.config.autoPlay,this.gestures=this._gallery.config.gestures,this.thumbWidth=this._gallery.config.thumbWidth,this.thumbHeight=this._gallery.config.thumbHeight,this.disableThumb=this._gallery.config.disableThumb,this.panSensitivity=this._gallery.config.panSensitivity,this.playerInterval=this._gallery.config.playerInterval,this.itemTemplate=this._gallery.config.itemTemplate,this.thumbTemplate=this._gallery.config.thumbTemplate,this.thumbMode=this._gallery.config.thumbMode,this.imageSize=this._gallery.config.imageSize,this.dotsPosition=this._gallery.config.dotsPosition,this.counterPosition=this._gallery.config.counterPosition,this.slidingDirection=this._gallery.config.slidingDirection,this.loadingStrategy=this._gallery.config.loadingStrategy,this.thumbPosition=this._gallery.config.thumbPosition,this.destroyRef=!0,this.skipInitConfig=!1,this.itemClick=new core.o,this.thumbClick=new core.o,this.playingChange=new core.o,this.indexChange=new core.o,this.itemsChange=new core.o,this.error=new core.o,this._itemClick$=Subscription.a.EMPTY,this._thumbClick$=Subscription.a.EMPTY,this._itemChange$=Subscription.a.EMPTY,this._indexChange$=Subscription.a.EMPTY,this._playingChange$=Subscription.a.EMPTY,this._playerListener$=Subscription.a.EMPTY}getConfig(){return{nav:this.nav,dots:this.dots,loop:this.loop,thumb:this.thumb,zoomOut:this.zoomOut,counter:this.counter,autoPlay:this.autoPlay,gestures:this.gestures,dotsSize:this.dotsSize,imageSize:this.imageSize,thumbMode:this.thumbMode,thumbWidth:this.thumbWidth,thumbHeight:this.thumbHeight,disableThumb:this.disableThumb,dotsPosition:this.dotsPosition,itemTemplate:this.itemTemplate,thumbTemplate:this.thumbTemplate,thumbPosition:this.thumbPosition,panSensitivity:this.panSensitivity,playerInterval:this.playerInterval,counterPosition:this.counterPosition,loadingStrategy:this.loadingStrategy,slidingDirection:this.slidingDirection}}onAction(i){switch(i){case\"next\":this.galleryRef.next();break;case\"prev\":this.galleryRef.prev();break;default:this.galleryRef.set(i)}}ngOnChanges(changes){this.galleryRef&&(this.galleryRef.setConfig(this.getConfig()),changes.items&&changes.items.currentValue!==changes.items.previousValue&&this.load(this.items))}ngOnInit(){this.galleryRef=this.skipInitConfig?this._gallery.ref(this.id):this._gallery.ref(this.id,this.getConfig()),this.load(this.items),this._playerListener$=this.galleryRef.activatePlayer().subscribe(),this.indexChange.observers.length&&(this._indexChange$=this.galleryRef.indexChanged.subscribe(state=>this.indexChange.emit(state))),this.itemsChange.observers.length&&(this._itemChange$=this.galleryRef.itemsChanged.subscribe(state=>this.itemsChange.emit(state))),this.playingChange.observers.length&&(this._playingChange$=this.galleryRef.playingChanged.subscribe(state=>this.playingChange.emit(state))),this.autoPlay&&this.play()}ngOnDestroy(){this._itemClick$.unsubscribe(),this._thumbClick$.unsubscribe(),this._itemChange$.unsubscribe(),this._indexChange$.unsubscribe(),this._playingChange$.unsubscribe(),this._playerListener$.unsubscribe(),this.destroyRef&&this.galleryRef.destroy()}onItemClick(i){this.itemClick.emit(i),this.galleryRef.itemClick.next(i)}onThumbClick(i){this.galleryRef.set(i),this.thumbClick.emit(i),this.galleryRef.thumbClick.next(i)}onError(err){this.error.emit(err),this.galleryRef.error.next(err)}load(items){this.galleryRef.load(items)}add(item,active){this.galleryRef.add(item,active)}addImage(data,active){this.add(new ImageItem(data),active)}addVideo(data,active){this.add(new VideoItem(data),active)}addIframe(data,active){this.add(new IframeItem(data),active)}addYoutube(data,active){this.add(new YoutubeItem(data),active)}remove(i){this.galleryRef.remove(i)}next(){this.galleryRef.next()}prev(){this.galleryRef.prev()}set(i){this.galleryRef.set(i)}reset(){this.galleryRef.reset()}play(interval){this.galleryRef.play(interval)}stop(){this.galleryRef.stop()}}return GalleryComponent.ɵfac=function(t){return new(t||GalleryComponent)(core.Pb(ng_gallery_Gallery))},GalleryComponent.ɵcmp=core.Jb({type:GalleryComponent,selectors:[[\"gallery\"]],inputs:{nav:\"nav\",dots:\"dots\",loop:\"loop\",thumb:\"thumb\",zoomOut:\"zoomOut\",counter:\"counter\",dotsSize:\"dotsSize\",autoPlay:\"autoPlay\",gestures:\"gestures\",thumbWidth:\"thumbWidth\",thumbHeight:\"thumbHeight\",disableThumb:\"disableThumb\",panSensitivity:\"panSensitivity\",playerInterval:\"playerInterval\",itemTemplate:\"itemTemplate\",thumbTemplate:\"thumbTemplate\",thumbMode:\"thumbMode\",imageSize:\"imageSize\",dotsPosition:\"dotsPosition\",counterPosition:\"counterPosition\",slidingDirection:\"slidingDirection\",loadingStrategy:\"loadingStrategy\",thumbPosition:\"thumbPosition\",destroyRef:\"destroyRef\",skipInitConfig:\"skipInitConfig\",id:\"id\",items:\"items\"},outputs:{itemClick:\"itemClick\",thumbClick:\"thumbClick\",playingChange:\"playingChange\",indexChange:\"indexChange\",itemsChange:\"itemsChange\",error:\"error\"},features:[core.Bb],ngContentSelectors:_c0,decls:4,vars:6,consts:[[3,\"state\",\"config\",\"action\",\"itemClick\",\"thumbClick\",\"error\"]],template:function(rf,ctx){1&rf&&(core.kc(),core.Vb(0,\"gallery-core\",0),core.dc(\"action\",function($event){return ctx.onAction($event)})(\"itemClick\",function($event){return ctx.onItemClick($event)})(\"thumbClick\",function($event){return ctx.onThumbClick($event)})(\"error\",function($event){return ctx.onError($event)}),core.gc(1,\"async\"),core.gc(2,\"async\"),core.Ub(),core.jc(3)),2&rf&&core.lc(\"state\",core.hc(1,2,ctx.galleryRef.state))(\"config\",core.hc(2,4,ctx.galleryRef.config))},directives:function(){return[ng_gallery_GalleryCoreComponent]},pipes:function(){return[common.b]},styles:['gallery-core[dotsPosition=top] gallery-dots{top:0}  gallery-core[dotsPosition=bottom] gallery-dots{bottom:0}  gallery-dots{left:50%;margin:7px;position:absolute;transform:translateX(-50%)}  .g-dot{cursor:pointer;z-index:20}  .g-dot:hover .g-dot-inner{opacity:1}  .g-dot-active .g-dot-inner{opacity:1;transform:scale(1.5)!important}  .g-dot-inner{background-color:#fff;border-radius:50%;box-shadow:0 0 1px #000;height:30%;opacity:.6;transition:all .2s ease;width:30%}  .g-dot,   .g-dot-inner,   gallery-dots{align-items:center;display:flex;justify-content:center}  .g-nav-next,   .g-nav-prev{cursor:pointer;height:40px;position:absolute;top:50%;width:30px;z-index:999}  .g-nav-next{right:.5em;transform:translateY(-50%) perspective(1px)}  .g-nav-prev{left:.5em;transform:translateY(-50%) perspective(1px) scale(-1)}@media only screen and (max-width:480px){  .g-nav-next{right:.2em}  .g-nav-prev{left:.2em}}  .g-items-container{height:100%}  .g-slider{position:absolute;transition:transform .4s cubic-bezier(.5,0,.5,1)}  gallery-core[slidingDirection=horizontal] .g-slider{flex-direction:row}  gallery-core[slidingDirection=vertical] .g-slider{flex-direction:column}  gallery-thumbs{display:block;overflow:unset;z-index:1}  .g-thumbs-container{display:flex;height:100%;left:0;overflow:unset;position:relative;top:0;width:100%;z-index:206}  gallery-core[disableThumb=true] gallery-thumb{cursor:default}  gallery-core[thumbPosition=bottom] gallery-thumbs .g-slider,   gallery-core[thumbPosition=top] gallery-thumbs .g-slider{flex-direction:row;left:50%;top:0}  gallery-core[thumbPosition=bottom] gallery-thumb,   gallery-core[thumbPosition=top] gallery-thumb{padding:1px 0 1px 1px}  gallery-core[thumbPosition=left] gallery-thumbs .g-slider,   gallery-core[thumbPosition=right] gallery-thumbs .g-slider{flex-direction:column;left:0;top:50%}  gallery-core[thumbPosition=left] gallery-thumb,   gallery-core[thumbPosition=right] gallery-thumb{padding:0 1px 1px}  gallery-core[thumbPosition=top]{flex-direction:column}  gallery-core[thumbPosition=left]{flex-direction:row}  gallery-core[thumbPosition=right]{flex-direction:row-reverse}  gallery-core[thumbPosition=bottom]{flex-direction:column-reverse}  gallery-thumb.g-active-thumb .g-thumb-loading{background-color:#464646}  .g-thumb-loading{background-color:#262626;height:100%;overflow:hidden;position:relative}  .g-thumb-loading:before{-webkit-animation:phAnimation .8s linear infinite;animation:phAnimation .8s linear infinite;background:linear-gradient(90deg,hsla(0,0%,100%,0) 46%,hsla(0,0%,100%,.35) 50%,hsla(0,0%,100%,0) 54%) 50% 50%;bottom:0;content:\"\";left:50%;margin-left:-250%;position:absolute;right:0;top:0;width:500%;z-index:1}@-webkit-keyframes phAnimation{0%{transform:translate3d(-30%,0,0)}to{transform:translate3d(30%,0,0)}}@keyframes phAnimation{0%{transform:translate3d(-30%,0,0)}to{transform:translate3d(30%,0,0)}}  gallery-core[counterPosition=top] .g-counter{border-bottom-left-radius:4px;border-bottom-right-radius:4px;top:0}  gallery-core[counterPosition=bottom] .g-counter{border-top-left-radius:4px;border-top-right-radius:4px;bottom:0}  .g-counter{background-color:rgba(0,0,0,.5);color:#fff;font-size:12px;left:50%;padding:4px 10px;position:absolute;transform:translateX(-50%) perspective(1px);z-index:50}  gallery[gallerize] gallery-item{cursor:pointer}  gallery-item,   gallery-thumb{display:block;height:100%;overflow:hidden;position:relative;width:100%}  gallery-item h2,   gallery-item h4,   gallery-thumb h2,   gallery-thumb h4{color:coral;margin:0}  gallery-item h2,   gallery-thumb h2{font-size:3.5em;margin-bottom:.3em}  gallery-item h4,   gallery-thumb h4{font-size:1.6em}  gallery-item{z-index:10}  gallery-item iframe,   gallery-item video{height:100%;position:absolute;width:100%}  gallery-thumb{cursor:pointer;opacity:.5;transition:opacity .3s cubic-bezier(.5,0,.5,1)}  gallery-thumb.g-active-thumb{opacity:1}  .g-image-item{background-position:50%;background-repeat:no-repeat;background-size:cover;height:100%;width:100%}  .g-image-error-message,   .g-template{align-items:center;bottom:0;color:#fff;display:flex;flex-direction:column;justify-content:center;left:0;position:absolute;right:0;top:0;z-index:10}  .g-loading{height:80px;left:50%;position:absolute;top:50%;transform:translate3d(-50%,-50%,0);width:80px}  gallery-core[imageSize=contain] gallery-slider .g-image-item{background-size:contain}  gallery-image{align-items:center;display:flex;height:100%;justify-content:center}  gallery{background-color:#000;display:block;height:500px;overflow:hidden;position:relative;z-index:1}  gallery *{box-sizing:border-box}  gallery,   gallery-core{overflow:hidden;position:relative}  .g-box,   .g-slider,   gallery-core{display:flex;height:100%;width:100%}  gallery[fluid]{left:50%;transform:translateX(-50vw);width:100vw}  gallery[fluid][fluid=false]{left:auto;transform:none;width:auto}  .g-no-transition{transition:unset!important}  .g-box,   gallery-slider{display:flex;flex:1;flex-direction:column;height:100%;order:1;overflow:hidden;position:relative}  .g-btn-close svg,   gallery-nav svg{-webkit-filter:drop-shadow(0 0 1px #000);filter:drop-shadow(0 0 1px black);height:100%;opacity:.6;transition:opacity .2s linear;width:100%}  .g-btn-close svg:hover,   gallery-nav svg:hover{opacity:1}'],changeDetection:0}),GalleryComponent})(),ng_gallery_GalleryIframeComponent=(()=>{class GalleryIframeComponent{constructor(_sanitizer){this._sanitizer=_sanitizer}set src(src){this.iframeSrc=this._sanitizer.bypassSecurityTrustResourceUrl(src)}set pauseVideo(shouldPause){this.iframe.nativeElement&&shouldPause&&(this.iframe.nativeElement.src=null)}}return GalleryIframeComponent.ɵfac=function(t){return new(t||GalleryIframeComponent)(core.Pb(platform_browser.b))},GalleryIframeComponent.ɵcmp=core.Jb({type:GalleryIframeComponent,selectors:[[\"gallery-iframe\"]],viewQuery:function(rf,ctx){if(1&rf&&core.Kc(_c1,3),2&rf){let _t;core.tc(_t=core.ec())&&(ctx.iframe=_t.first)}},inputs:{src:\"src\",pauseVideo:[\"pause\",\"pauseVideo\"],autoplay:\"autoplay\"},decls:2,vars:2,consts:[[\"frameborder\",\"0\",\"allowfullscreen\",\"\",3,\"src\"],[\"iframe\",\"\"]],template:function(rf,ctx){1&rf&&core.Qb(0,\"iframe\",0,1),2&rf&&(core.lc(\"src\",ctx.iframeSrc,core.xc),core.Eb(\"allow\",ctx.autoplay?\"autoplay\":\"\"))},encapsulation:2,changeDetection:0}),GalleryIframeComponent})(),ng_gallery_GalleryImageComponent=(()=>{class GalleryImageComponent{constructor(_sanitizer){this._sanitizer=_sanitizer,this._state=new BehaviorSubject.a(\"loading\"),this.state=this._state.asObservable(),this.progress=0,this.error=new core.o}get imageLoadSuccess(){return!!this.imageUrl}get imageLoadFailed(){return!!this.loadError}ngOnInit(){this.loadingIcon&&(this.loaderTemplate=this._sanitizer.bypassSecurityTrustHtml(this.loadingIcon)),this.loadingError&&(this.errorTemplate=this._sanitizer.bypassSecurityTrustHtml(this.loadingError))}ngOnDestroy(){this._state.complete()}onProgress({loaded:loaded,total:total}){this.progress=100*loaded/total}onLoaded(blobUrl){this.imageUrl=this._sanitizer.bypassSecurityTrustStyle(`url(\"${blobUrl}\")`),this._state.next(\"success\")}onError(err){this.loadError=err,this._state.next(\"failed\"),this.error.emit(err)}}return GalleryImageComponent.ɵfac=function(t){return new(t||GalleryImageComponent)(core.Pb(platform_browser.b))},GalleryImageComponent.ɵcmp=core.Jb({type:GalleryImageComponent,selectors:[[\"gallery-image\"]],hostVars:4,hostBindings:function(rf,ctx){2&rf&&core.Hb(\"g-image-loaded\",ctx.imageLoadSuccess)(\"g-image-error\",ctx.imageLoadFailed)},inputs:{isThumbnail:\"isThumbnail\",src:\"src\",loadingIcon:\"loadingIcon\",loadingError:\"loadingError\"},outputs:{error:\"error\"},decls:5,vars:7,consts:[[3,\"lazyImage\",\"ngSwitch\",\"progress\",\"loaded\",\"error\"],[\"class\",\"g-image-item\",3,\"backgroundImage\",4,\"ngSwitchCase\"],[\"class\",\"g-image-error-message\",4,\"ngSwitchCase\"],[4,\"ngSwitchCase\"],[1,\"g-image-item\"],[1,\"g-image-error-message\"],[3,\"innerHTML\",4,\"ngIf\",\"ngIfElse\"],[\"defaultError\",\"\"],[3,\"innerHTML\"],[4,\"ngIf\",\"ngIfElse\"],[\"isLarge\",\"\"],[\"class\",\"g-loading\",3,\"innerHTML\",4,\"ngIf\",\"ngIfElse\"],[\"defaultLoader\",\"\"],[1,\"g-loading\",3,\"innerHTML\"],[\"class\",\"g-thumb-loading\",4,\"ngIf\"],[1,\"g-thumb-loading\"]],template:function(rf,ctx){1&rf&&(core.Tb(0,0),core.dc(\"progress\",function($event){return ctx.onProgress($event)})(\"loaded\",function($event){return ctx.onLoaded($event)})(\"error\",function($event){return ctx.onError($event)}),core.gc(1,\"async\"),core.Ec(2,GalleryImageComponent_div_2_Template,1,3,\"div\",1),core.Ec(3,GalleryImageComponent_div_3_Template,4,2,\"div\",2),core.Ec(4,GalleryImageComponent_ng_container_4_Template,4,2,\"ng-container\",3),core.Sb()),2&rf&&(core.lc(\"lazyImage\",ctx.src)(\"ngSwitch\",core.hc(1,5,ctx.state)),core.Db(2),core.lc(\"ngSwitchCase\",\"success\"),core.Db(1),core.lc(\"ngSwitchCase\",\"failed\"),core.Db(1),core.lc(\"ngSwitchCase\",\"loading\"))},directives:function(){return[ng_gallery_LazyImage,common.o,common.p,common.m]},pipes:function(){return[common.b]},encapsulation:2,data:{animation:[Object(animations.l)(\"fadeIn\",[Object(animations.k)(\":enter\",[Object(animations.j)({opacity:0}),Object(animations.e)(\"300ms ease-in\",Object(animations.j)({opacity:1}))])])]},changeDetection:0}),GalleryImageComponent})(),ng_gallery_GalleryVideoComponent=(()=>{class GalleryVideoComponent{constructor(){this.error=new core.o}set pauseVideo(shouldPause){if(this.video.nativeElement){const video=this.video.nativeElement;shouldPause&&!video.paused&&video.pause()}}set playVideo(shouldPlay){if(this.video.nativeElement){const video=this.video.nativeElement;shouldPlay&&video.play()}}ngOnInit(){this.videoSources=this.src instanceof Array?[...this.src]:[{url:this.src}],this.controls=\"boolean\"!=typeof this.controlsEnabled||this.controlsEnabled}}return GalleryVideoComponent.ɵfac=function(t){return new(t||GalleryVideoComponent)},GalleryVideoComponent.ɵcmp=core.Jb({type:GalleryVideoComponent,selectors:[[\"gallery-video\"]],viewQuery:function(rf,ctx){if(1&rf&&core.Kc(_c2,3),2&rf){let _t;core.tc(_t=core.ec())&&(ctx.video=_t.first)}},inputs:{pauseVideo:[\"pause\",\"pauseVideo\"],playVideo:[\"play\",\"playVideo\"],src:\"src\",poster:\"poster\",controlsEnabled:[\"controls\",\"controlsEnabled\"]},outputs:{error:\"error\"},decls:3,vars:3,consts:[[3,\"controls\",\"poster\",\"error\"],[\"video\",\"\"],[3,\"src\",\"type\",4,\"ngFor\",\"ngForOf\"],[3,\"src\",\"type\"]],template:function(rf,ctx){1&rf&&(core.Vb(0,\"video\",0,1),core.dc(\"error\",function($event){return ctx.error.emit($event)}),core.Ec(2,GalleryVideoComponent_source_2_Template,1,2,\"source\",2),core.Ub()),2&rf&&(core.lc(\"controls\",ctx.controls)(\"poster\",ctx.poster,core.zc),core.Db(2),core.lc(\"ngForOf\",ctx.videoSources))},directives:[common.l],encapsulation:2,changeDetection:0}),GalleryVideoComponent})(),ng_gallery_GalleryNavComponent=(()=>{class GalleryNavComponent{constructor(_sanitizer){this._sanitizer=_sanitizer,this.action=new core.o}ngOnInit(){this.navIcon=this._sanitizer.bypassSecurityTrustHtml(this.config.navIcon)}}return GalleryNavComponent.ɵfac=function(t){return new(t||GalleryNavComponent)(core.Pb(platform_browser.b))},GalleryNavComponent.ɵcmp=core.Jb({type:GalleryNavComponent,selectors:[[\"gallery-nav\"]],inputs:{state:\"state\",config:\"config\"},outputs:{action:\"action\"},decls:2,vars:2,consts:[[\"class\",\"g-nav-prev\",\"aria-label\",\"Previous\",3,\"innerHtml\",\"tapClick\",4,\"ngIf\"],[\"class\",\"g-nav-next\",\"aria-label\",\"Next\",3,\"innerHtml\",\"tapClick\",4,\"ngIf\"],[\"aria-label\",\"Previous\",1,\"g-nav-prev\",3,\"innerHtml\",\"tapClick\"],[\"aria-label\",\"Next\",1,\"g-nav-next\",3,\"innerHtml\",\"tapClick\"]],template:function(rf,ctx){1&rf&&(core.Ec(0,GalleryNavComponent_i_0_Template,1,1,\"i\",0),core.Ec(1,GalleryNavComponent_i_1_Template,1,1,\"i\",1)),2&rf&&(core.lc(\"ngIf\",ctx.config.loop||ctx.state.hasPrev),core.Db(1),core.lc(\"ngIf\",ctx.config.loop||ctx.state.hasNext))},directives:function(){return[common.m,ng_gallery_TapClick]},encapsulation:2,changeDetection:0}),GalleryNavComponent})(),ng_gallery_GalleryCoreComponent=(()=>{class GalleryCoreComponent{constructor(){this.action=new core.o,this.itemClick=new core.o,this.thumbClick=new core.o,this.error=new core.o}get thumbPosition(){return this.config.thumbPosition}get slidingDirection(){return this.config.slidingDirection}get disableThumb(){return this.config.disableThumb}get imageSize(){return this.config.imageSize}get dotsPosition(){return this.config.dotsPosition}get counterPosition(){return this.config.counterPosition}}return GalleryCoreComponent.ɵfac=function(t){return new(t||GalleryCoreComponent)},GalleryCoreComponent.ɵcmp=core.Jb({type:GalleryCoreComponent,selectors:[[\"gallery-core\"]],hostVars:6,hostBindings:function(rf,ctx){2&rf&&core.Eb(\"thumbPosition\",ctx.thumbPosition)(\"slidingDirection\",ctx.slidingDirection)(\"disableThumb\",ctx.disableThumb)(\"imageSize\",ctx.imageSize)(\"dotsPosition\",ctx.dotsPosition)(\"counterPosition\",ctx.counterPosition)},inputs:{state:\"state\",config:\"config\"},outputs:{action:\"action\",itemClick:\"itemClick\",thumbClick:\"thumbClick\",error:\"error\"},decls:6,vars:6,consts:[[3,\"state\",\"config\",\"action\",\"thumbClick\",4,\"ngIf\"],[1,\"g-box\"],[3,\"state\",\"config\",\"action\",\"itemClick\",\"error\"],[3,\"state\",\"config\",\"action\",4,\"ngIf\"],[3,\"state\",4,\"ngIf\"],[3,\"state\",\"config\",\"action\",\"thumbClick\"],[3,\"state\",\"config\",\"action\"],[3,\"state\"]],template:function(rf,ctx){1&rf&&(core.Ec(0,GalleryCoreComponent_gallery_thumbs_0_Template,1,2,\"gallery-thumbs\",0),core.Vb(1,\"div\",1),core.Vb(2,\"gallery-slider\",2),core.dc(\"action\",function($event){return ctx.action.emit($event)})(\"itemClick\",function($event){return ctx.itemClick.emit($event)})(\"error\",function($event){return ctx.error.emit($event)}),core.Ec(3,GalleryCoreComponent_gallery_nav_3_Template,1,2,\"gallery-nav\",3),core.Ub(),core.Ec(4,GalleryCoreComponent_gallery_dots_4_Template,1,2,\"gallery-dots\",3),core.Ec(5,GalleryCoreComponent_gallery_counter_5_Template,1,1,\"gallery-counter\",4),core.Ub()),2&rf&&(core.lc(\"ngIf\",ctx.config.thumb),core.Db(2),core.lc(\"state\",ctx.state)(\"config\",ctx.config),core.Db(1),core.lc(\"ngIf\",ctx.config.nav&&ctx.state.items.length>1),core.Db(1),core.lc(\"ngIf\",ctx.config.dots),core.Db(1),core.lc(\"ngIf\",ctx.config.counter))},directives:function(){return[common.m,ng_gallery_GallerySliderComponent,ng_gallery_GalleryThumbsComponent,ng_gallery_GalleryNavComponent,ng_gallery_GalleryDotsComponent,ng_gallery_GalleryCounterComponent]},encapsulation:2,changeDetection:0}),GalleryCoreComponent})(),ng_gallery_GalleryDotsComponent=(()=>{class GalleryDotsComponent{constructor(){this.action=new core.o}}return GalleryDotsComponent.ɵfac=function(t){return new(t||GalleryDotsComponent)},GalleryDotsComponent.ɵcmp=core.Jb({type:GalleryDotsComponent,selectors:[[\"gallery-dots\"]],inputs:{state:\"state\",config:\"config\"},outputs:{action:\"action\"},decls:1,vars:1,consts:[[\"class\",\"g-dot\",3,\"g-dot-active\",\"width\",\"height\",\"tapClick\",4,\"ngFor\",\"ngForOf\"],[1,\"g-dot\",3,\"tapClick\"],[1,\"g-dot-inner\"]],template:function(rf,ctx){1&rf&&core.Ec(0,GalleryDotsComponent_div_0_Template,2,6,\"div\",0),2&rf&&core.lc(\"ngForOf\",ctx.state.items)},directives:function(){return[common.l,ng_gallery_TapClick]},encapsulation:2,changeDetection:0}),GalleryDotsComponent})(),ng_gallery_GalleryThumbsComponent=(()=>{class GalleryThumbsComponent{constructor(_el,_zone){this._el=_el,this._zone=_zone,this._slidingWorker$=new BehaviorSubject.a({value:0,active:!1}),this._freeModeCurrentOffset=0,this.action=new core.o,this.thumbClick=new core.o,this.error=new core.o,this.sliderState$=this._slidingWorker$.pipe(Object(map.a)(state=>({style:this.getSliderStyles(state),active:state.active})))}ngOnChanges(){this.updateSlider({value:0,active:!1}),this._freeModeCurrentOffset=0}ngOnInit(){if(this.config.gestures&&!this.config.disableThumb&&\"undefined\"!=typeof Hammer){let direction;switch(this.config.thumbPosition){case ThumbnailsPosition.Right:case ThumbnailsPosition.Left:direction=Hammer.DIRECTION_VERTICAL;break;case ThumbnailsPosition.Top:case ThumbnailsPosition.Bottom:direction=Hammer.DIRECTION_HORIZONTAL}this._hammer=new Hammer(this._el.nativeElement),this._hammer.get(\"pan\").set({direction:direction}),this._zone.runOutsideAngular(()=>{switch(this.config.thumbMode){case ThumbnailsMode.Strict:this._hammer.on(\"pan\",e=>this.strictMode(e));break;case ThumbnailsMode.Free:this._hammer.on(\"pan\",e=>this.freeMode(e))}})}}ngOnDestroy(){this._hammer&&this._hammer.destroy()}strictMode(e){switch(this.config.thumbPosition){case ThumbnailsPosition.Right:case ThumbnailsPosition.Left:this.updateSlider({value:e.deltaY,active:!0}),e.isFinal&&(this.updateSlider({value:0,active:!1}),this.verticalPan(e));break;case ThumbnailsPosition.Top:case ThumbnailsPosition.Bottom:this.updateSlider({value:e.deltaX,active:!0}),e.isFinal&&(this.updateSlider({value:0,active:!1}),this.horizontalPan(e))}}freeMode(e){switch(this.config.thumbPosition){case ThumbnailsPosition.Right:case ThumbnailsPosition.Left:this.updateSlider({value:this._freeModeCurrentOffset+e.deltaY,active:!0}),e.isFinal&&(this.minFreeScrollExceeded(e.deltaY,this.config.thumbWidth,this.config.thumbHeight)?this._freeModeCurrentOffset=-(this.state.items.length-1-this.state.currIndex)*this.config.thumbHeight:this.maxFreeScrollExceeded(e.deltaY,this.config.thumbHeight,this.config.thumbWidth)?this._freeModeCurrentOffset=this.state.currIndex*this.config.thumbHeight:this._freeModeCurrentOffset+=e.deltaY,this.updateSlider({value:this._freeModeCurrentOffset,active:!1}));break;case ThumbnailsPosition.Top:case ThumbnailsPosition.Bottom:this.updateSlider({value:this._freeModeCurrentOffset+e.deltaX,active:!0}),e.isFinal&&(this.minFreeScrollExceeded(e.deltaX,this.config.thumbHeight,this.config.thumbWidth)?this._freeModeCurrentOffset=-(this.state.items.length-1-this.state.currIndex)*this.config.thumbWidth:this.maxFreeScrollExceeded(e.deltaX,this.config.thumbWidth,this.config.thumbHeight)?this._freeModeCurrentOffset=this.state.currIndex*this.config.thumbWidth:this._freeModeCurrentOffset+=e.deltaX,this.updateSlider({value:this._freeModeCurrentOffset,active:!1}))}}minFreeScrollExceeded(delta,width,height){return-(this._freeModeCurrentOffset+delta-width/2)>(this.state.items.length-this.state.currIndex)*height}maxFreeScrollExceeded(delta,width,height){return this._freeModeCurrentOffset+delta>this.state.currIndex*width+height/2}getSliderStyles(state){let value;switch(this.config.thumbPosition){case ThumbnailsPosition.Top:case ThumbnailsPosition.Bottom:return this.width=\"100%\",this.height=this.config.thumbHeight+\"px\",value=-this.state.currIndex*this.config.thumbWidth-(this.config.thumbWidth/2-state.value),{transform:`translate3d(${value}px, 0, 0)`,width:this.state.items.length*this.config.thumbWidth+\"px\",height:\"100%\"};case ThumbnailsPosition.Left:case ThumbnailsPosition.Right:return this.width=this.config.thumbWidth+\"px\",this.height=\"100%\",value=-this.state.currIndex*this.config.thumbHeight-(this.config.thumbHeight/2-state.value),{transform:`translate3d(0, ${value}px, 0)`,width:\"100%\",height:this.state.items.length*this.config.thumbHeight+\"px\"}}}verticalPan(e){e.direction&Hammer.DIRECTION_UP&&e.offsetDirection&Hammer.DIRECTION_VERTICAL&&(e.velocityY>.3?this.prev():e.velocityY<-.3||e.deltaY/2<=-this.config.thumbHeight*this.state.items.length/this.config.panSensitivity?this.next():e.deltaY/2>=this.config.thumbHeight*this.state.items.length/this.config.panSensitivity?this.prev():this.action.emit(this.state.currIndex))}horizontalPan(e){e.direction&Hammer.DIRECTION_HORIZONTAL&&e.offsetDirection&Hammer.DIRECTION_HORIZONTAL&&(e.velocityX>.3?this.prev():e.velocityX<-.3||e.deltaX/2<=-this.config.thumbWidth*this.state.items.length/this.config.panSensitivity?this.next():e.deltaX/2>=this.config.thumbWidth*this.state.items.length/this.config.panSensitivity?this.prev():this.action.emit(this.state.currIndex))}next(){this.action.emit(\"next\")}prev(){this.action.emit(\"prev\")}updateSlider(state){const newState=Object.assign(Object.assign({},this._slidingWorker$.value),state);this._slidingWorker$.next(newState)}}return GalleryThumbsComponent.ɵfac=function(t){return new(t||GalleryThumbsComponent)(core.Pb(core.m),core.Pb(core.B))},GalleryThumbsComponent.ɵcmp=core.Jb({type:GalleryThumbsComponent,selectors:[[\"gallery-thumbs\"]],hostVars:4,hostBindings:function(rf,ctx){2&rf&&core.Bc(\"width\",ctx.width)(\"height\",ctx.height)},inputs:{state:\"state\",config:\"config\"},outputs:{action:\"action\",thumbClick:\"thumbClick\",error:\"error\"},features:[core.Bb],decls:2,vars:3,consts:[[\"class\",\"g-thumbs-container\",4,\"ngIf\"],[1,\"g-thumbs-container\"],[1,\"g-slider\",3,\"ngStyle\"],[3,\"type\",\"config\",\"data\",\"currIndex\",\"index\",\"tapClickDisabled\",\"tapClick\",\"error\",4,\"ngFor\",\"ngForOf\"],[3,\"type\",\"config\",\"data\",\"currIndex\",\"index\",\"tapClickDisabled\",\"tapClick\",\"error\"]],template:function(rf,ctx){1&rf&&(core.Ec(0,GalleryThumbsComponent_div_0_Template,3,4,\"div\",0),core.gc(1,\"async\")),2&rf&&core.lc(\"ngIf\",core.hc(1,1,ctx.sliderState$))},directives:function(){return[common.m,common.n,common.l,ng_gallery_GalleryThumbComponent,ng_gallery_TapClick]},pipes:function(){return[common.b]},encapsulation:2,changeDetection:0}),GalleryThumbsComponent})(),ng_gallery_GallerySliderComponent=(()=>{class GallerySliderComponent{constructor(_el,_zone,platform){this._el=_el,this._zone=_zone,this.platform=platform,this._slidingWorker$=new BehaviorSubject.a({value:0,active:!1}),this.action=new core.o,this.itemClick=new core.o,this.error=new core.o,this.sliderState$=this._slidingWorker$.pipe(Object(map.a)(state=>({style:this.getSliderStyles(state),active:state.active})))}get zoom(){return{transform:`perspective(50px) translate3d(0, 0, ${-this.config.zoomOut}px)`}}ngOnChanges(){this.updateSlider({value:0,active:!1})}ngOnInit(){if(this.config.gestures&&\"undefined\"!=typeof Hammer){const direction=this.config.slidingDirection===SlidingDirection.Horizontal?Hammer.DIRECTION_HORIZONTAL:Hammer.DIRECTION_VERTICAL;this._hammer=new Hammer(this._el.nativeElement),this._hammer.get(\"pan\").set({direction:direction}),this._zone.runOutsideAngular(()=>{this._hammer.on(\"pan\",e=>{switch(this.config.slidingDirection){case SlidingDirection.Horizontal:this.updateSlider({value:e.deltaX,active:!0}),e.isFinal&&(this.updateSlider({value:0,active:!1}),this.horizontalPan(e));break;case SlidingDirection.Vertical:this.updateSlider({value:e.deltaY,active:!0}),e.isFinal&&(this.updateSlider({value:0,active:!1}),this.verticalPan(e))}})})}Object(common.w)(this.platform)&&(this._resizeSub$=Object(fromEvent.a)(window,\"resize\").pipe(debounceTime(200),Object(tap.a)(()=>this.updateSlider(this._slidingWorker$.value))).subscribe()),setTimeout(()=>this.updateSlider({value:0,active:!1}))}ngOnDestroy(){this._hammer&&this._hammer.destroy(),this._resizeSub$&&this._resizeSub$.unsubscribe(),this._slidingWorker$.complete()}getSliderStyles(state){switch(this.config.slidingDirection){case SlidingDirection.Horizontal:return{transform:`translate3d(${-this.state.currIndex*this._el.nativeElement.offsetWidth+state.value}px, 0, 0)`,width:`calc(100% * ${this.state.items.length})`,height:\"100%\"};case SlidingDirection.Vertical:return{transform:`translate3d(0, ${-this.state.currIndex*this._el.nativeElement.offsetHeight+state.value}px, 0)`,width:\"100%\",height:`calc(100% * ${this.state.items.length})`}}}verticalPan(e){e.direction&Hammer.DIRECTION_UP&&e.offsetDirection&Hammer.DIRECTION_VERTICAL&&(e.velocityY>.3?this.prev():e.velocityY<-.3||e.deltaY/2<=-this._el.nativeElement.offsetHeight*this.state.items.length/this.config.panSensitivity?this.next():e.deltaY/2>=this._el.nativeElement.offsetHeight*this.state.items.length/this.config.panSensitivity?this.prev():this.action.emit(this.state.currIndex))}horizontalPan(e){e.direction&Hammer.DIRECTION_HORIZONTAL&&e.offsetDirection&Hammer.DIRECTION_HORIZONTAL&&(e.velocityX>.3?this.prev():e.velocityX<-.3||e.deltaX/2<=-this._el.nativeElement.offsetWidth*this.state.items.length/this.config.panSensitivity?this.next():e.deltaX/2>=this._el.nativeElement.offsetWidth*this.state.items.length/this.config.panSensitivity?this.prev():this.action.emit(this.state.currIndex))}next(){this.action.emit(\"next\")}prev(){this.action.emit(\"prev\")}updateSlider(state){const newState=Object.assign(Object.assign({},this._slidingWorker$.value),state);this._slidingWorker$.next(newState)}}return GallerySliderComponent.ɵfac=function(t){return new(t||GallerySliderComponent)(core.Pb(core.m),core.Pb(core.B),core.Pb(core.D))},GallerySliderComponent.ɵcmp=core.Jb({type:GallerySliderComponent,selectors:[[\"gallery-slider\"]],inputs:{state:\"state\",config:\"config\"},outputs:{action:\"action\",itemClick:\"itemClick\",error:\"error\"},features:[core.Bb],ngContentSelectors:_c0,decls:3,vars:3,consts:[[\"class\",\"g-items-container\",3,\"ngStyle\",4,\"ngIf\"],[1,\"g-items-container\",3,\"ngStyle\"],[1,\"g-slider\",3,\"ngStyle\"],[3,\"type\",\"config\",\"data\",\"currIndex\",\"index\",\"tapClick\",\"error\",4,\"ngFor\",\"ngForOf\"],[3,\"type\",\"config\",\"data\",\"currIndex\",\"index\",\"tapClick\",\"error\"]],template:function(rf,ctx){1&rf&&(core.kc(),core.Ec(0,GallerySliderComponent_div_0_Template,3,5,\"div\",0),core.gc(1,\"async\"),core.jc(2)),2&rf&&core.lc(\"ngIf\",core.hc(1,1,ctx.sliderState$))},directives:function(){return[common.m,common.n,common.l,ng_gallery_GalleryItemComponent,ng_gallery_TapClick]},pipes:function(){return[common.b]},encapsulation:2,changeDetection:0}),GallerySliderComponent})(),ng_gallery_GalleryCounterComponent=(()=>{class GalleryCounterComponent{}return GalleryCounterComponent.ɵfac=function(t){return new(t||GalleryCounterComponent)},GalleryCounterComponent.ɵcmp=core.Jb({type:GalleryCounterComponent,selectors:[[\"gallery-counter\"]],inputs:{state:\"state\"},decls:2,vars:1,consts:[[1,\"g-counter\"]],template:function(rf,ctx){1&rf&&(core.Vb(0,\"div\",0),core.Gc(1),core.Ub()),2&rf&&(core.Db(1),core.Hc(ctx.state.currIndex+1+\"/\"+ctx.state.items.length))},encapsulation:2,changeDetection:0}),GalleryCounterComponent})(),ng_gallery_GalleryItemComponent=(()=>{class GalleryItemComponent{constructor(){this.Types=GalleryItemType,this.error=new core.o}get isActive(){return this.index===this.currIndex}get isAutoPlay(){if(this.isActive&&(this.type===GalleryItemType.Video||this.type===GalleryItemType.Youtube))return this.data.autoplay}get youtubeSrc(){let autoplay=0;this.isActive&&this.type===GalleryItemType.Youtube&&this.data.autoplay&&(autoplay=1);const url=new URL(this.data.src);return url.search=new URLSearchParams(Object.assign(Object.assign({wmode:\"transparent\"},this.data.params),{autoplay:autoplay})).toString(),url.href}get load(){switch(this.config.loadingStrategy){case LoadingStrategy.Preload:return!0;case LoadingStrategy.Lazy:return this.currIndex===this.index;default:return this.currIndex===this.index||this.currIndex===this.index-1||this.currIndex===this.index+1}}}return GalleryItemComponent.ɵfac=function(t){return new(t||GalleryItemComponent)},GalleryItemComponent.ɵcmp=core.Jb({type:GalleryItemComponent,selectors:[[\"gallery-item\"]],hostVars:2,hostBindings:function(rf,ctx){2&rf&&core.Hb(\"g-active-item\",ctx.isActive)},inputs:{config:\"config\",index:\"index\",currIndex:\"currIndex\",type:\"type\",data:\"data\"},outputs:{error:\"error\"},decls:1,vars:1,consts:[[3,\"ngSwitch\",4,\"ngIf\"],[3,\"ngSwitch\"],[4,\"ngSwitchCase\"],[3,\"src\",\"poster\",\"controls\",\"play\",\"pause\",\"error\",4,\"ngSwitchCase\"],[3,\"src\",\"autoplay\",\"pause\",4,\"ngSwitchCase\"],[3,\"src\",4,\"ngSwitchCase\"],[4,\"ngSwitchDefault\"],[3,\"src\",\"loadingIcon\",\"loadingError\",\"error\"],[1,\"g-template\",\"g-item-template\"],[4,\"ngTemplateOutlet\",\"ngTemplateOutletContext\"],[3,\"src\",\"poster\",\"controls\",\"play\",\"pause\",\"error\"],[3,\"src\",\"autoplay\",\"pause\"],[3,\"src\"]],template:function(rf,ctx){1&rf&&core.Ec(0,GalleryItemComponent_ng_container_0_Template,6,5,\"ng-container\",0),2&rf&&core.lc(\"ngIf\",ctx.load)},directives:[common.m,common.o,common.p,common.q,ng_gallery_GalleryImageComponent,common.r,ng_gallery_GalleryVideoComponent,ng_gallery_GalleryIframeComponent],encapsulation:2,changeDetection:0}),GalleryItemComponent})(),ng_gallery_GalleryThumbComponent=(()=>{class GalleryThumbComponent{constructor(){this.error=new core.o}get isActive(){return this.index===this.currIndex}}return GalleryThumbComponent.ɵfac=function(t){return new(t||GalleryThumbComponent)},GalleryThumbComponent.ɵcmp=core.Jb({type:GalleryThumbComponent,selectors:[[\"gallery-thumb\"]],hostVars:2,hostBindings:function(rf,ctx){2&rf&&core.Hb(\"g-active-thumb\",ctx.isActive)},inputs:{config:\"config\",index:\"index\",currIndex:\"currIndex\",type:\"type\",data:\"data\"},outputs:{error:\"error\"},decls:2,vars:5,consts:[[\"mode\",\"indeterminate\",3,\"src\",\"isThumbnail\",\"loadingIcon\",\"loadingError\",\"error\"],[\"class\",\"g-template g-thumb-template\",4,\"ngIf\"],[1,\"g-template\",\"g-thumb-template\"],[4,\"ngTemplateOutlet\",\"ngTemplateOutletContext\"]],template:function(rf,ctx){1&rf&&(core.Vb(0,\"gallery-image\",0),core.dc(\"error\",function($event){return ctx.error.emit($event)}),core.Ub(),core.Ec(1,GalleryThumbComponent_div_1_Template,2,6,\"div\",1)),2&rf&&(core.lc(\"src\",ctx.data.thumb)(\"isThumbnail\",!0)(\"loadingIcon\",ctx.config.thumbLoadingIcon)(\"loadingError\",ctx.config.thumbLoadingError),core.Db(1),core.lc(\"ngIf\",ctx.config.thumbTemplate))},directives:[ng_gallery_GalleryImageComponent,common.m,common.r],encapsulation:2,changeDetection:0}),GalleryThumbComponent})(),ng_gallery_LazyImage=(()=>{class LazyImage{constructor(document){this.document=document,this._imageLoader$=new Subject.a,this._loaderSub$=Subscription.a.EMPTY,this.loaded=new core.o,this.error=new core.o,this._loaderSub$=this._imageLoader$.pipe(Object(switchMap.a)(imageSrc=>this.nativeLoader(imageSrc))).subscribe()}ngOnChanges(changes){changes.src&&changes.src.previousValue!==changes.src.currentValue&&this.loadImage(this.src)}ngOnDestroy(){this._loaderSub$.unsubscribe(),this._imageLoader$.complete()}loadImage(imagePath){this._imageLoader$.next(imagePath)}nativeLoader(url){const img=this.document.createElement(\"img\");return img.src=url,function(...observables){const resultSelector=observables[observables.length-1];return\"function\"==typeof resultSelector&&observables.pop(),Object(fromArray.a)(observables,void 0).lift(new ZipOperator(resultSelector))}(Object(fromEvent.a)(img,\"load\").pipe(Object(tap.a)(()=>this.loaded.emit(url))),Object(fromEvent.a)(img,\"error\").pipe(Object(tap.a)(()=>this.error.emit(new Error(`[lazyImage]: The image ${url} did not load`)))))}}return LazyImage.ɵfac=function(t){return new(t||LazyImage)(core.Pb(common.e))},LazyImage.ɵdir=core.Kb({type:LazyImage,selectors:[[\"\",\"lazyImage\",\"\"]],inputs:{src:[\"lazyImage\",\"src\"]},outputs:{loaded:\"loaded\",error:\"error\"},features:[core.Bb]}),LazyImage})(),ng_gallery_TapClick=(()=>{class TapClick{constructor(_el){this._el=_el,this.clickListener=Subscription.a.EMPTY,this.tapClick=new core.o}ngOnInit(){this.activateClickEvent()}activateClickEvent(){\"undefined\"!=typeof Hammer?(this._hammer=new Hammer(this._el.nativeElement),this._hammer.on(\"tap\",()=>{this.tapClickDisabled||this.tapClick.emit(null)})):this.clickListener=Object(fromEvent.a)(this._el.nativeElement,\"click\").pipe(Object(filter.a)(()=>!this.tapClickDisabled),Object(tap.a)(()=>this.tapClick.emit(null))).subscribe()}ngOnDestroy(){this._hammer&&this._hammer.destroy(),this.clickListener.unsubscribe()}}return TapClick.ɵfac=function(t){return new(t||TapClick)(core.Pb(core.m))},TapClick.ɵdir=core.Kb({type:TapClick,selectors:[[\"\",\"tapClick\",\"\"]],inputs:{tapClickDisabled:\"tapClickDisabled\"},outputs:{tapClick:\"tapClick\"}}),TapClick})(),ng_gallery_GalleryModule=(()=>{class GalleryModule{static withConfig(config){return{ngModule:GalleryModule,providers:[{provide:GALLERY_CONFIG,useValue:config}]}}}return GalleryModule.ɵmod=core.Nb({type:GalleryModule}),GalleryModule.ɵinj=core.Mb({factory:function(t){return new(t||GalleryModule)},imports:[[common.c]]}),GalleryModule})();var place_service=__webpack_require__(\"qOnq\"),geolocation_service=__webpack_require__(\"H+Hf\"),local_storage=__webpack_require__(\"eAEk\"),app_config_service=__webpack_require__(\"JvtB\"),take=__webpack_require__(\"IzEk\");function coerceArray(value){return Array.isArray(value)?value:[value]}function coerceCssPixelValue(value){return null==value?\"\":\"string\"==typeof value?value:`${value}px`}var fesm2015_platform=__webpack_require__(\"nLfN\"),Observable=__webpack_require__(\"HDdC\");let observers_MutationObserverFactory=(()=>{class MutationObserverFactory{create(callback){return\"undefined\"==typeof MutationObserver?null:new MutationObserver(callback)}}return MutationObserverFactory.ɵfac=function(t){return new(t||MutationObserverFactory)},MutationObserverFactory.ɵprov=Object(core.Lb)({factory:function(){return new MutationObserverFactory},token:MutationObserverFactory,providedIn:\"root\"}),MutationObserverFactory})(),observers_ObserversModule=(()=>{class ObserversModule{}return ObserversModule.ɵmod=core.Nb({type:ObserversModule}),ObserversModule.ɵinj=core.Mb({factory:function(t){return new(t||ObserversModule)},providers:[observers_MutationObserverFactory]}),ObserversModule})(),a11y_InteractivityChecker=(()=>{class InteractivityChecker{constructor(_platform){this._platform=_platform}isDisabled(element){return element.hasAttribute(\"disabled\")}isVisible(element){return function(element){return!!(element.offsetWidth||element.offsetHeight||\"function\"==typeof element.getClientRects&&element.getClientRects().length)}(element)&&\"visible\"===getComputedStyle(element).visibility}isTabbable(element){if(!this._platform.isBrowser)return!1;const frameElement=function(window){try{return window.frameElement}catch(_a){return null}}((node=element).ownerDocument&&node.ownerDocument.defaultView||window);var node;if(frameElement){const frameType=frameElement&&frameElement.nodeName.toLowerCase();if(-1===getTabIndexValue(frameElement))return!1;if((this._platform.BLINK||this._platform.WEBKIT)&&\"object\"===frameType)return!1;if((this._platform.BLINK||this._platform.WEBKIT)&&!this.isVisible(frameElement))return!1}let nodeName=element.nodeName.toLowerCase(),tabIndexValue=getTabIndexValue(element);if(element.hasAttribute(\"contenteditable\"))return-1!==tabIndexValue;if(\"iframe\"===nodeName)return!1;if(\"audio\"===nodeName){if(!element.hasAttribute(\"controls\"))return!1;if(this._platform.BLINK)return!0}if(\"video\"===nodeName){if(!element.hasAttribute(\"controls\")&&this._platform.TRIDENT)return!1;if(this._platform.BLINK||this._platform.FIREFOX)return!0}return(\"object\"!==nodeName||!this._platform.BLINK&&!this._platform.WEBKIT)&&!(this._platform.WEBKIT&&this._platform.IOS&&!function(element){let nodeName=element.nodeName.toLowerCase(),inputType=\"input\"===nodeName&&element.type;return\"text\"===inputType||\"password\"===inputType||\"select\"===nodeName||\"textarea\"===nodeName}(element))&&element.tabIndex>=0}isFocusable(element){return function(element){return!function(element){return function(element){return\"input\"==element.nodeName.toLowerCase()}(element)&&\"hidden\"==element.type}(element)&&(function(element){let nodeName=element.nodeName.toLowerCase();return\"input\"===nodeName||\"select\"===nodeName||\"button\"===nodeName||\"textarea\"===nodeName}(element)||function(element){return function(element){return\"a\"==element.nodeName.toLowerCase()}(element)&&element.hasAttribute(\"href\")}(element)||element.hasAttribute(\"contenteditable\")||hasValidTabIndex(element))}(element)&&!this.isDisabled(element)&&this.isVisible(element)}}return InteractivityChecker.ɵfac=function(t){return new(t||InteractivityChecker)(core.Zb(fesm2015_platform.a))},InteractivityChecker.ɵprov=Object(core.Lb)({factory:function(){return new InteractivityChecker(Object(core.Zb)(fesm2015_platform.a))},token:InteractivityChecker,providedIn:\"root\"}),InteractivityChecker})();function hasValidTabIndex(element){if(!element.hasAttribute(\"tabindex\")||void 0===element.tabIndex)return!1;let tabIndex=element.getAttribute(\"tabindex\");return\"-32768\"!=tabIndex&&!(!tabIndex||isNaN(parseInt(tabIndex,10)))}function getTabIndexValue(element){if(!hasValidTabIndex(element))return null;const tabIndex=parseInt(element.getAttribute(\"tabindex\")||\"\",10);return isNaN(tabIndex)?-1:tabIndex}class ConfigurableFocusTrap extends class{constructor(_element,_checker,_ngZone,_document,deferAnchors=!1){this._element=_element,this._checker=_checker,this._ngZone=_ngZone,this._document=_document,this._hasAttached=!1,this.startAnchorListener=()=>this.focusLastTabbableElement(),this.endAnchorListener=()=>this.focusFirstTabbableElement(),this._enabled=!0,deferAnchors||this.attachAnchors()}get enabled(){return this._enabled}set enabled(value){this._enabled=value,this._startAnchor&&this._endAnchor&&(this._toggleAnchorTabIndex(value,this._startAnchor),this._toggleAnchorTabIndex(value,this._endAnchor))}destroy(){const startAnchor=this._startAnchor,endAnchor=this._endAnchor;startAnchor&&(startAnchor.removeEventListener(\"focus\",this.startAnchorListener),startAnchor.parentNode&&startAnchor.parentNode.removeChild(startAnchor)),endAnchor&&(endAnchor.removeEventListener(\"focus\",this.endAnchorListener),endAnchor.parentNode&&endAnchor.parentNode.removeChild(endAnchor)),this._startAnchor=this._endAnchor=null,this._hasAttached=!1}attachAnchors(){return!!this._hasAttached||(this._ngZone.runOutsideAngular(()=>{this._startAnchor||(this._startAnchor=this._createAnchor(),this._startAnchor.addEventListener(\"focus\",this.startAnchorListener)),this._endAnchor||(this._endAnchor=this._createAnchor(),this._endAnchor.addEventListener(\"focus\",this.endAnchorListener))}),this._element.parentNode&&(this._element.parentNode.insertBefore(this._startAnchor,this._element),this._element.parentNode.insertBefore(this._endAnchor,this._element.nextSibling),this._hasAttached=!0),this._hasAttached)}focusInitialElementWhenReady(){return new Promise(resolve=>{this._executeOnStable(()=>resolve(this.focusInitialElement()))})}focusFirstTabbableElementWhenReady(){return new Promise(resolve=>{this._executeOnStable(()=>resolve(this.focusFirstTabbableElement()))})}focusLastTabbableElementWhenReady(){return new Promise(resolve=>{this._executeOnStable(()=>resolve(this.focusLastTabbableElement()))})}_getRegionBoundary(bound){let markers=this._element.querySelectorAll(`[cdk-focus-region-${bound}], [cdkFocusRegion${bound}], [cdk-focus-${bound}]`);for(let i=0;i<markers.length;i++)markers[i].hasAttribute(`cdk-focus-${bound}`)?console.warn(`Found use of deprecated attribute 'cdk-focus-${bound}', use 'cdkFocusRegion${bound}' instead. The deprecated attribute will be removed in 8.0.0.`,markers[i]):markers[i].hasAttribute(`cdk-focus-region-${bound}`)&&console.warn(`Found use of deprecated attribute 'cdk-focus-region-${bound}', use 'cdkFocusRegion${bound}' instead. The deprecated attribute will be removed in 8.0.0.`,markers[i]);return\"start\"==bound?markers.length?markers[0]:this._getFirstTabbableElement(this._element):markers.length?markers[markers.length-1]:this._getLastTabbableElement(this._element)}focusInitialElement(){const redirectToElement=this._element.querySelector(\"[cdk-focus-initial], [cdkFocusInitial]\");return redirectToElement?(redirectToElement.hasAttribute(\"cdk-focus-initial\")&&console.warn(\"Found use of deprecated attribute 'cdk-focus-initial', use 'cdkFocusInitial' instead. The deprecated attribute will be removed in 8.0.0\",redirectToElement),Object(core.Y)()&&!this._checker.isFocusable(redirectToElement)&&console.warn(\"Element matching '[cdkFocusInitial]' is not focusable.\",redirectToElement),redirectToElement.focus(),!0):this.focusFirstTabbableElement()}focusFirstTabbableElement(){const redirectToElement=this._getRegionBoundary(\"start\");return redirectToElement&&redirectToElement.focus(),!!redirectToElement}focusLastTabbableElement(){const redirectToElement=this._getRegionBoundary(\"end\");return redirectToElement&&redirectToElement.focus(),!!redirectToElement}hasAttached(){return this._hasAttached}_getFirstTabbableElement(root){if(this._checker.isFocusable(root)&&this._checker.isTabbable(root))return root;let children=root.children||root.childNodes;for(let i=0;i<children.length;i++){let tabbableChild=children[i].nodeType===this._document.ELEMENT_NODE?this._getFirstTabbableElement(children[i]):null;if(tabbableChild)return tabbableChild}return null}_getLastTabbableElement(root){if(this._checker.isFocusable(root)&&this._checker.isTabbable(root))return root;let children=root.children||root.childNodes;for(let i=children.length-1;i>=0;i--){let tabbableChild=children[i].nodeType===this._document.ELEMENT_NODE?this._getLastTabbableElement(children[i]):null;if(tabbableChild)return tabbableChild}return null}_createAnchor(){const anchor=this._document.createElement(\"div\");return this._toggleAnchorTabIndex(this._enabled,anchor),anchor.classList.add(\"cdk-visually-hidden\"),anchor.classList.add(\"cdk-focus-trap-anchor\"),anchor.setAttribute(\"aria-hidden\",\"true\"),anchor}_toggleAnchorTabIndex(isEnabled,anchor){isEnabled?anchor.setAttribute(\"tabindex\",\"0\"):anchor.removeAttribute(\"tabindex\")}toggleAnchors(enabled){this._startAnchor&&this._endAnchor&&(this._toggleAnchorTabIndex(enabled,this._startAnchor),this._toggleAnchorTabIndex(enabled,this._endAnchor))}_executeOnStable(fn){this._ngZone.isStable?fn():this._ngZone.onStable.asObservable().pipe(Object(take.a)(1)).subscribe(fn)}}{constructor(_element,_checker,_ngZone,_document,_focusTrapManager,_inertStrategy,config){super(_element,_checker,_ngZone,_document,config.defer),this._focusTrapManager=_focusTrapManager,this._inertStrategy=_inertStrategy,this._focusTrapManager.register(this)}get enabled(){return this._enabled}set enabled(value){this._enabled=value,this._enabled?this._focusTrapManager.register(this):this._focusTrapManager.deregister(this)}destroy(){this._focusTrapManager.deregister(this),super.destroy()}_enable(){this._inertStrategy.preventFocus(this),this.toggleAnchors(!0)}_disable(){this._inertStrategy.allowFocus(this),this.toggleAnchors(!1)}}const hasNativeClosest=\"undefined\"!=typeof Element&&!!Element.prototype.closest;function matches(element,selector){return element.matches?element.matches(selector):element.msMatchesSelector(selector)}class EventListenerFocusTrapInertStrategy{constructor(){this._listener=null}preventFocus(focusTrap){this._listener&&focusTrap._document.removeEventListener(\"focus\",this._listener,!0),this._listener=e=>this._trapFocus(focusTrap,e),focusTrap._ngZone.runOutsideAngular(()=>{focusTrap._document.addEventListener(\"focus\",this._listener,!0)})}allowFocus(focusTrap){this._listener&&(focusTrap._document.removeEventListener(\"focus\",this._listener,!0),this._listener=null)}_trapFocus(focusTrap,event){const target=event.target,focusTrapRoot=focusTrap._element;focusTrapRoot.contains(target)||null!==function(element,selector){if(!(element instanceof Node))return null;let curr=element;for(;null!=curr&&!(curr instanceof Element);)curr=curr.parentNode;return curr&&(hasNativeClosest?curr.closest(\"div.cdk-overlay-pane\"):function(element,selector){let curr=element;for(;null!=curr&&!(curr instanceof Element&&matches(curr,\"div.cdk-overlay-pane\"));)curr=curr.parentNode;return curr||null}(curr))}(target)||setTimeout(()=>{focusTrap.enabled&&!focusTrapRoot.contains(focusTrap._document.activeElement)&&focusTrap.focusFirstTabbableElement()})}}class ConfigurableFocusTrapConfig{constructor(){this.defer=!1}}const FOCUS_TRAP_INERT_STRATEGY=new core.s(\"FOCUS_TRAP_INERT_STRATEGY\");let a11y_FocusTrapManager=(()=>{class FocusTrapManager{constructor(){this._focusTrapStack=[]}register(focusTrap){this._focusTrapStack=this._focusTrapStack.filter(ft=>ft!==focusTrap);let stack=this._focusTrapStack;stack.length&&stack[stack.length-1]._disable(),stack.push(focusTrap),focusTrap._enable()}deregister(focusTrap){focusTrap._disable();const stack=this._focusTrapStack,i=stack.indexOf(focusTrap);-1!==i&&(stack.splice(i,1),stack.length&&stack[stack.length-1]._enable())}}return FocusTrapManager.ɵfac=function(t){return new(t||FocusTrapManager)},FocusTrapManager.ɵprov=Object(core.Lb)({factory:function(){return new FocusTrapManager},token:FocusTrapManager,providedIn:\"root\"}),FocusTrapManager})(),a11y_ConfigurableFocusTrapFactory=(()=>{class ConfigurableFocusTrapFactory{constructor(_checker,_ngZone,_focusTrapManager,_document,_inertStrategy){this._checker=_checker,this._ngZone=_ngZone,this._focusTrapManager=_focusTrapManager,this._document=_document,this._inertStrategy=_inertStrategy||new EventListenerFocusTrapInertStrategy}create(element,config=new ConfigurableFocusTrapConfig){let configObject;return\"boolean\"==typeof config?(configObject=new ConfigurableFocusTrapConfig,configObject.defer=config):configObject=config,new ConfigurableFocusTrap(element,this._checker,this._ngZone,this._document,this._focusTrapManager,this._inertStrategy,configObject)}}return ConfigurableFocusTrapFactory.ɵfac=function(t){return new(t||ConfigurableFocusTrapFactory)(core.Zb(a11y_InteractivityChecker),core.Zb(core.B),core.Zb(a11y_FocusTrapManager),core.Zb(common.e),core.Zb(FOCUS_TRAP_INERT_STRATEGY,8))},ConfigurableFocusTrapFactory.ɵprov=Object(core.Lb)({factory:function(){return new ConfigurableFocusTrapFactory(Object(core.Zb)(a11y_InteractivityChecker),Object(core.Zb)(core.B),Object(core.Zb)(a11y_FocusTrapManager),Object(core.Zb)(common.e),Object(core.Zb)(FOCUS_TRAP_INERT_STRATEGY,8))},token:ConfigurableFocusTrapFactory,providedIn:\"root\"}),ConfigurableFocusTrapFactory})(),a11y_HighContrastModeDetector=(()=>{class HighContrastModeDetector{constructor(_platform,document){this._platform=_platform,this._document=document}getHighContrastMode(){if(!this._platform.isBrowser)return 0;const testElement=this._document.createElement(\"div\");testElement.style.backgroundColor=\"rgb(1,2,3)\",testElement.style.position=\"absolute\",this._document.body.appendChild(testElement);const documentWindow=this._document.defaultView||window,computedStyle=documentWindow&&documentWindow.getComputedStyle?documentWindow.getComputedStyle(testElement):null,computedColor=(computedStyle&&computedStyle.backgroundColor||\"\").replace(/ /g,\"\");switch(this._document.body.removeChild(testElement),computedColor){case\"rgb(0,0,0)\":return 2;case\"rgb(255,255,255)\":return 1}return 0}_applyBodyHighContrastModeCssClasses(){if(this._platform.isBrowser&&this._document.body){const bodyClasses=this._document.body.classList;bodyClasses.remove(\"cdk-high-contrast-active\"),bodyClasses.remove(\"cdk-high-contrast-black-on-white\"),bodyClasses.remove(\"cdk-high-contrast-white-on-black\");const mode=this.getHighContrastMode();1===mode?(bodyClasses.add(\"cdk-high-contrast-active\"),bodyClasses.add(\"cdk-high-contrast-black-on-white\")):2===mode&&(bodyClasses.add(\"cdk-high-contrast-active\"),bodyClasses.add(\"cdk-high-contrast-white-on-black\"))}}}return HighContrastModeDetector.ɵfac=function(t){return new(t||HighContrastModeDetector)(core.Zb(fesm2015_platform.a),core.Zb(common.e))},HighContrastModeDetector.ɵprov=Object(core.Lb)({factory:function(){return new HighContrastModeDetector(Object(core.Zb)(fesm2015_platform.a),Object(core.Zb)(common.e))},token:HighContrastModeDetector,providedIn:\"root\"}),HighContrastModeDetector})(),a11y_A11yModule=(()=>{class A11yModule{constructor(highContrastModeDetector){highContrastModeDetector._applyBodyHighContrastModeCssClasses()}}return A11yModule.ɵmod=core.Nb({type:A11yModule}),A11yModule.ɵinj=core.Mb({factory:function(t){return new(t||A11yModule)(core.Zb(a11y_HighContrastModeDetector))},imports:[[fesm2015_platform.b,observers_ObserversModule]]}),A11yModule})();function throwPortalAlreadyAttachedError(){throw Error(\"Host already has a portal attached\")}class Portal{attach(host){return null==host&&function(){throw Error(\"Attempting to attach a portal to a null PortalOutlet\")}(),host.hasAttached()&&throwPortalAlreadyAttachedError(),this._attachedHost=host,host.attach(this)}detach(){let host=this._attachedHost;null==host?function(){throw Error(\"Attempting to detach a portal that is not attached to a host\")}():(this._attachedHost=null,host.detach())}get isAttached(){return null!=this._attachedHost}setAttachedHost(host){this._attachedHost=host}}class ComponentPortal extends Portal{constructor(component,viewContainerRef,injector,componentFactoryResolver){super(),this.component=component,this.viewContainerRef=viewContainerRef,this.injector=injector,this.componentFactoryResolver=componentFactoryResolver}}class TemplatePortal extends Portal{constructor(template,viewContainerRef,context){super(),this.templateRef=template,this.viewContainerRef=viewContainerRef,this.context=context}get origin(){return this.templateRef.elementRef}attach(host,context=this.context){return this.context=context,super.attach(host)}detach(){return this.context=void 0,super.detach()}}class portal_DomPortal extends Portal{constructor(element){super(),this.element=element instanceof core.m?element.nativeElement:element}}class DomPortalOutlet extends class{constructor(){this._isDisposed=!1,this.attachDomPortal=null}hasAttached(){return!!this._attachedPortal}attach(portal){return portal||function(){throw Error(\"Must provide a portal to attach\")}(),this.hasAttached()&&throwPortalAlreadyAttachedError(),this._isDisposed&&function(){throw Error(\"This PortalOutlet has already been disposed\")}(),portal instanceof ComponentPortal?(this._attachedPortal=portal,this.attachComponentPortal(portal)):portal instanceof TemplatePortal?(this._attachedPortal=portal,this.attachTemplatePortal(portal)):this.attachDomPortal&&portal instanceof portal_DomPortal?(this._attachedPortal=portal,this.attachDomPortal(portal)):void function(){throw Error(\"Attempting to attach an unknown Portal type. BasePortalOutlet accepts either a ComponentPortal or a TemplatePortal.\")}()}detach(){this._attachedPortal&&(this._attachedPortal.setAttachedHost(null),this._attachedPortal=null),this._invokeDisposeFn()}dispose(){this.hasAttached()&&this.detach(),this._invokeDisposeFn(),this._isDisposed=!0}setDisposeFn(fn){this._disposeFn=fn}_invokeDisposeFn(){this._disposeFn&&(this._disposeFn(),this._disposeFn=null)}}{constructor(outletElement,_componentFactoryResolver,_appRef,_defaultInjector,_document){super(),this.outletElement=outletElement,this._componentFactoryResolver=_componentFactoryResolver,this._appRef=_appRef,this._defaultInjector=_defaultInjector,this.attachDomPortal=portal=>{if(!this._document)throw Error(\"Cannot attach DOM portal without _document constructor parameter\");const element=portal.element;if(!element.parentNode)throw Error(\"DOM portal content must be attached to a parent node.\");const anchorNode=this._document.createComment(\"dom-portal\");element.parentNode.insertBefore(anchorNode,element),this.outletElement.appendChild(element),super.setDisposeFn(()=>{anchorNode.parentNode&&anchorNode.parentNode.replaceChild(element,anchorNode)})},this._document=_document}attachComponentPortal(portal){const componentFactory=(portal.componentFactoryResolver||this._componentFactoryResolver).resolveComponentFactory(portal.component);let componentRef;return portal.viewContainerRef?(componentRef=portal.viewContainerRef.createComponent(componentFactory,portal.viewContainerRef.length,portal.injector||portal.viewContainerRef.injector),this.setDisposeFn(()=>componentRef.destroy())):(componentRef=componentFactory.create(portal.injector||this._defaultInjector),this._appRef.attachView(componentRef.hostView),this.setDisposeFn(()=>{this._appRef.detachView(componentRef.hostView),componentRef.destroy()})),this.outletElement.appendChild(this._getComponentRootNode(componentRef)),componentRef}attachTemplatePortal(portal){let viewContainer=portal.viewContainerRef,viewRef=viewContainer.createEmbeddedView(portal.templateRef,portal.context);return viewRef.detectChanges(),viewRef.rootNodes.forEach(rootNode=>this.outletElement.appendChild(rootNode)),this.setDisposeFn(()=>{let index=viewContainer.indexOf(viewRef);-1!==index&&viewContainer.remove(index)}),viewRef}dispose(){super.dispose(),null!=this.outletElement.parentNode&&this.outletElement.parentNode.removeChild(this.outletElement)}_getComponentRootNode(componentRef){return componentRef.hostView.rootNodes[0]}}let portal_PortalModule=(()=>{class PortalModule{}return PortalModule.ɵmod=core.Nb({type:PortalModule}),PortalModule.ɵinj=core.Mb({factory:function(t){return new(t||PortalModule)}}),PortalModule})();__webpack_require__(\"3N8a\"),__webpack_require__(\"IjjT\"),__webpack_require__(\"7+OI\"),__webpack_require__(\"/uUt\");class AuditOperator{constructor(durationSelector){this.durationSelector=durationSelector}call(subscriber,source){return source.subscribe(new audit_AuditSubscriber(subscriber,this.durationSelector))}}class audit_AuditSubscriber extends OuterSubscriber.a{constructor(destination,durationSelector){super(destination),this.durationSelector=durationSelector,this.hasValue=!1}_next(value){if(this.value=value,this.hasValue=!0,!this.throttled){let duration;try{const{durationSelector:durationSelector}=this;duration=durationSelector(value)}catch(err){return this.destination.error(err)}const innerSubscription=Object(subscribeToResult.a)(this,duration);!innerSubscription||innerSubscription.closed?this.clearThrottle():this.add(this.throttled=innerSubscription)}}clearThrottle(){const{value:value,hasValue:hasValue,throttled:throttled}=this;throttled&&(this.remove(throttled),this.throttled=null,throttled.unsubscribe()),hasValue&&(this.value=null,this.hasValue=!1,this.destination.next(value))}notifyNext(outerValue,innerValue,outerIndex,innerIndex){this.clearThrottle()}notifyComplete(){this.clearThrottle()}}function isNumeric(val){return!Object(isArray.a)(val)&&val-parseFloat(val)+1>=0}var isScheduler=__webpack_require__(\"z+Ro\");function dispatch(state){const{index:index,period:period,subscriber:subscriber}=state;if(subscriber.next(index),!subscriber.closed){if(-1===period)return subscriber.complete();state.index=index+1,this.schedule(state,period)}}function auditTime(duration,scheduler=scheduler_async.a){return durationSelector=()=>function(dueTime=0,periodOrScheduler,scheduler){let period=-1;return isNumeric(periodOrScheduler)?period=Number(periodOrScheduler)<1?1:Number(periodOrScheduler):Object(isScheduler.a)(periodOrScheduler)&&(scheduler=periodOrScheduler),Object(isScheduler.a)(scheduler)||(scheduler=scheduler_async.a),new Observable.a(subscriber=>{const due=isNumeric(dueTime)?dueTime:+dueTime-scheduler.now();return scheduler.schedule(dispatch,due,{index:0,period:period,subscriber:subscriber})})}(duration,scheduler),function(source){return source.lift(new AuditOperator(durationSelector))};var durationSelector}class takeUntil_TakeUntilOperator{constructor(notifier){this.notifier=notifier}call(subscriber,source){const takeUntilSubscriber=new takeUntil_TakeUntilSubscriber(subscriber),notifierSubscription=Object(subscribeToResult.a)(takeUntilSubscriber,this.notifier);return notifierSubscription&&!takeUntilSubscriber.seenValue?(takeUntilSubscriber.add(notifierSubscription),source.subscribe(takeUntilSubscriber)):takeUntilSubscriber}}class takeUntil_TakeUntilSubscriber extends OuterSubscriber.a{constructor(destination){super(destination),this.seenValue=!1}notifyNext(outerValue,innerValue,outerIndex,innerIndex,innerSub){this.seenValue=!0,this.complete()}notifyComplete(){}}__webpack_require__(\"JX91\"),__webpack_require__(\"UXun\");const DIR_DOCUMENT=new core.s(\"cdk-dir-doc\",{providedIn:\"root\",factory:function(){return Object(core.X)(common.e)}});let bidi_Directionality=(()=>{class Directionality{constructor(_document){if(this.value=\"ltr\",this.change=new core.o,_document){const htmlDir=_document.documentElement?_document.documentElement.dir:null,value=(_document.body?_document.body.dir:null)||htmlDir;this.value=\"ltr\"===value||\"rtl\"===value?value:\"ltr\"}}ngOnDestroy(){this.change.complete()}}return Directionality.ɵfac=function(t){return new(t||Directionality)(core.Zb(DIR_DOCUMENT,8))},Directionality.ɵprov=Object(core.Lb)({factory:function(){return new Directionality(Object(core.Zb)(DIR_DOCUMENT,8))},token:Directionality,providedIn:\"root\"}),Directionality})(),bidi_BidiModule=(()=>{class BidiModule{}return BidiModule.ɵmod=core.Nb({type:BidiModule}),BidiModule.ɵinj=core.Mb({factory:function(t){return new(t||BidiModule)}}),BidiModule})(),scrolling_ScrollDispatcher=(()=>{class ScrollDispatcher{constructor(_ngZone,_platform,document){this._ngZone=_ngZone,this._platform=_platform,this._scrolled=new Subject.a,this._globalSubscription=null,this._scrolledCount=0,this.scrollContainers=new Map,this._document=document}register(scrollable){this.scrollContainers.has(scrollable)||this.scrollContainers.set(scrollable,scrollable.elementScrolled().subscribe(()=>this._scrolled.next(scrollable)))}deregister(scrollable){const scrollableReference=this.scrollContainers.get(scrollable);scrollableReference&&(scrollableReference.unsubscribe(),this.scrollContainers.delete(scrollable))}scrolled(auditTimeInMs=20){return this._platform.isBrowser?new Observable.a(observer=>{this._globalSubscription||this._addGlobalListener();const subscription=auditTimeInMs>0?this._scrolled.pipe(auditTime(auditTimeInMs)).subscribe(observer):this._scrolled.subscribe(observer);return this._scrolledCount++,()=>{subscription.unsubscribe(),this._scrolledCount--,this._scrolledCount||this._removeGlobalListener()}}):Object(of.a)()}ngOnDestroy(){this._removeGlobalListener(),this.scrollContainers.forEach((_,container)=>this.deregister(container)),this._scrolled.complete()}ancestorScrolled(elementRef,auditTimeInMs){const ancestors=this.getAncestorScrollContainers(elementRef);return this.scrolled(auditTimeInMs).pipe(Object(filter.a)(target=>!target||ancestors.indexOf(target)>-1))}getAncestorScrollContainers(elementRef){const scrollingContainers=[];return this.scrollContainers.forEach((_subscription,scrollable)=>{this._scrollableContainsElement(scrollable,elementRef)&&scrollingContainers.push(scrollable)}),scrollingContainers}_getDocument(){return this._document||document}_getWindow(){return this._getDocument().defaultView||window}_scrollableContainsElement(scrollable,elementRef){let element=elementRef.nativeElement,scrollableElement=scrollable.getElementRef().nativeElement;do{if(element==scrollableElement)return!0}while(element=element.parentElement);return!1}_addGlobalListener(){this._globalSubscription=this._ngZone.runOutsideAngular(()=>{const window=this._getWindow();return Object(fromEvent.a)(window.document,\"scroll\").subscribe(()=>this._scrolled.next())})}_removeGlobalListener(){this._globalSubscription&&(this._globalSubscription.unsubscribe(),this._globalSubscription=null)}}return ScrollDispatcher.ɵfac=function(t){return new(t||ScrollDispatcher)(core.Zb(core.B),core.Zb(fesm2015_platform.a),core.Zb(common.e,8))},ScrollDispatcher.ɵprov=Object(core.Lb)({factory:function(){return new ScrollDispatcher(Object(core.Zb)(core.B),Object(core.Zb)(fesm2015_platform.a),Object(core.Zb)(common.e,8))},token:ScrollDispatcher,providedIn:\"root\"}),ScrollDispatcher})(),scrolling_ViewportRuler=(()=>{class ViewportRuler{constructor(_platform,ngZone,document){this._platform=_platform,this._document=document,ngZone.runOutsideAngular(()=>{const window=this._getWindow();this._change=_platform.isBrowser?Object(merge.a)(Object(fromEvent.a)(window,\"resize\"),Object(fromEvent.a)(window,\"orientationchange\")):Object(of.a)(),this._invalidateCache=this.change().subscribe(()=>this._updateViewportSize())})}ngOnDestroy(){this._invalidateCache.unsubscribe()}getViewportSize(){this._viewportSize||this._updateViewportSize();const output={width:this._viewportSize.width,height:this._viewportSize.height};return this._platform.isBrowser||(this._viewportSize=null),output}getViewportRect(){const scrollPosition=this.getViewportScrollPosition(),{width:width,height:height}=this.getViewportSize();return{top:scrollPosition.top,left:scrollPosition.left,bottom:scrollPosition.top+height,right:scrollPosition.left+width,height:height,width:width}}getViewportScrollPosition(){if(!this._platform.isBrowser)return{top:0,left:0};const document=this._getDocument(),window=this._getWindow(),documentElement=document.documentElement,documentRect=documentElement.getBoundingClientRect();return{top:-documentRect.top||document.body.scrollTop||window.scrollY||documentElement.scrollTop||0,left:-documentRect.left||document.body.scrollLeft||window.scrollX||documentElement.scrollLeft||0}}change(throttleTime=20){return throttleTime>0?this._change.pipe(auditTime(throttleTime)):this._change}_getDocument(){return this._document||document}_getWindow(){return this._getDocument().defaultView||window}_updateViewportSize(){const window=this._getWindow();this._viewportSize=this._platform.isBrowser?{width:window.innerWidth,height:window.innerHeight}:{width:0,height:0}}}return ViewportRuler.ɵfac=function(t){return new(t||ViewportRuler)(core.Zb(fesm2015_platform.a),core.Zb(core.B),core.Zb(common.e,8))},ViewportRuler.ɵprov=Object(core.Lb)({factory:function(){return new ViewportRuler(Object(core.Zb)(fesm2015_platform.a),Object(core.Zb)(core.B),Object(core.Zb)(common.e,8))},token:ViewportRuler,providedIn:\"root\"}),ViewportRuler})(),scrolling_CdkScrollableModule=(()=>{class CdkScrollableModule{}return CdkScrollableModule.ɵmod=core.Nb({type:CdkScrollableModule}),CdkScrollableModule.ɵinj=core.Mb({factory:function(t){return new(t||CdkScrollableModule)}}),CdkScrollableModule})(),scrolling_ScrollingModule=(()=>{class ScrollingModule{}return ScrollingModule.ɵmod=core.Nb({type:ScrollingModule}),ScrollingModule.ɵinj=core.Mb({factory:function(t){return new(t||ScrollingModule)},imports:[[bidi_BidiModule,fesm2015_platform.b,scrolling_CdkScrollableModule],bidi_BidiModule,scrolling_CdkScrollableModule]}),ScrollingModule})();class overlay_BlockScrollStrategy{constructor(_viewportRuler,document){this._viewportRuler=_viewportRuler,this._previousHTMLStyles={top:\"\",left:\"\"},this._isEnabled=!1,this._document=document}attach(){}enable(){if(this._canBeEnabled()){const root=this._document.documentElement;this._previousScrollPosition=this._viewportRuler.getViewportScrollPosition(),this._previousHTMLStyles.left=root.style.left||\"\",this._previousHTMLStyles.top=root.style.top||\"\",root.style.left=coerceCssPixelValue(-this._previousScrollPosition.left),root.style.top=coerceCssPixelValue(-this._previousScrollPosition.top),root.classList.add(\"cdk-global-scrollblock\"),this._isEnabled=!0}}disable(){if(this._isEnabled){const html=this._document.documentElement,htmlStyle=html.style,bodyStyle=this._document.body.style,previousHtmlScrollBehavior=htmlStyle.scrollBehavior||\"\",previousBodyScrollBehavior=bodyStyle.scrollBehavior||\"\";this._isEnabled=!1,htmlStyle.left=this._previousHTMLStyles.left,htmlStyle.top=this._previousHTMLStyles.top,html.classList.remove(\"cdk-global-scrollblock\"),htmlStyle.scrollBehavior=bodyStyle.scrollBehavior=\"auto\",window.scroll(this._previousScrollPosition.left,this._previousScrollPosition.top),htmlStyle.scrollBehavior=previousHtmlScrollBehavior,bodyStyle.scrollBehavior=previousBodyScrollBehavior}}_canBeEnabled(){if(this._document.documentElement.classList.contains(\"cdk-global-scrollblock\")||this._isEnabled)return!1;const body=this._document.body,viewport=this._viewportRuler.getViewportSize();return body.scrollHeight>viewport.height||body.scrollWidth>viewport.width}}function getMatScrollStrategyAlreadyAttachedError(){return Error(\"Scroll strategy has already been attached.\")}class CloseScrollStrategy{constructor(_scrollDispatcher,_ngZone,_viewportRuler,_config){this._scrollDispatcher=_scrollDispatcher,this._ngZone=_ngZone,this._viewportRuler=_viewportRuler,this._config=_config,this._scrollSubscription=null,this._detach=()=>{this.disable(),this._overlayRef.hasAttached()&&this._ngZone.run(()=>this._overlayRef.detach())}}attach(overlayRef){if(this._overlayRef)throw getMatScrollStrategyAlreadyAttachedError();this._overlayRef=overlayRef}enable(){if(this._scrollSubscription)return;const stream=this._scrollDispatcher.scrolled(0);this._config&&this._config.threshold&&this._config.threshold>1?(this._initialScrollPosition=this._viewportRuler.getViewportScrollPosition().top,this._scrollSubscription=stream.subscribe(()=>{const scrollPosition=this._viewportRuler.getViewportScrollPosition().top;Math.abs(scrollPosition-this._initialScrollPosition)>this._config.threshold?this._detach():this._overlayRef.updatePosition()})):this._scrollSubscription=stream.subscribe(this._detach)}disable(){this._scrollSubscription&&(this._scrollSubscription.unsubscribe(),this._scrollSubscription=null)}detach(){this.disable(),this._overlayRef=null}}class NoopScrollStrategy{enable(){}disable(){}attach(){}}function isElementScrolledOutsideView(element,scrollContainers){return scrollContainers.some(containerBounds=>element.bottom<containerBounds.top||element.top>containerBounds.bottom||element.right<containerBounds.left||element.left>containerBounds.right)}function isElementClippedByScrolling(element,scrollContainers){return scrollContainers.some(scrollContainerRect=>element.top<scrollContainerRect.top||element.bottom>scrollContainerRect.bottom||element.left<scrollContainerRect.left||element.right>scrollContainerRect.right)}class RepositionScrollStrategy{constructor(_scrollDispatcher,_viewportRuler,_ngZone,_config){this._scrollDispatcher=_scrollDispatcher,this._viewportRuler=_viewportRuler,this._ngZone=_ngZone,this._config=_config,this._scrollSubscription=null}attach(overlayRef){if(this._overlayRef)throw getMatScrollStrategyAlreadyAttachedError();this._overlayRef=overlayRef}enable(){this._scrollSubscription||(this._scrollSubscription=this._scrollDispatcher.scrolled(this._config?this._config.scrollThrottle:0).subscribe(()=>{if(this._overlayRef.updatePosition(),this._config&&this._config.autoClose){const overlayRect=this._overlayRef.overlayElement.getBoundingClientRect(),{width:width,height:height}=this._viewportRuler.getViewportSize();isElementScrolledOutsideView(overlayRect,[{width:width,height:height,bottom:height,right:width,top:0,left:0}])&&(this.disable(),this._ngZone.run(()=>this._overlayRef.detach()))}}))}disable(){this._scrollSubscription&&(this._scrollSubscription.unsubscribe(),this._scrollSubscription=null)}detach(){this.disable(),this._overlayRef=null}}let overlay_ScrollStrategyOptions=(()=>{class ScrollStrategyOptions{constructor(_scrollDispatcher,_viewportRuler,_ngZone,document){this._scrollDispatcher=_scrollDispatcher,this._viewportRuler=_viewportRuler,this._ngZone=_ngZone,this.noop=()=>new NoopScrollStrategy,this.close=config=>new CloseScrollStrategy(this._scrollDispatcher,this._ngZone,this._viewportRuler,config),this.block=()=>new overlay_BlockScrollStrategy(this._viewportRuler,this._document),this.reposition=config=>new RepositionScrollStrategy(this._scrollDispatcher,this._viewportRuler,this._ngZone,config),this._document=document}}return ScrollStrategyOptions.ɵfac=function(t){return new(t||ScrollStrategyOptions)(core.Zb(scrolling_ScrollDispatcher),core.Zb(scrolling_ViewportRuler),core.Zb(core.B),core.Zb(common.e))},ScrollStrategyOptions.ɵprov=Object(core.Lb)({factory:function(){return new ScrollStrategyOptions(Object(core.Zb)(scrolling_ScrollDispatcher),Object(core.Zb)(scrolling_ViewportRuler),Object(core.Zb)(core.B),Object(core.Zb)(common.e))},token:ScrollStrategyOptions,providedIn:\"root\"}),ScrollStrategyOptions})();class OverlayConfig{constructor(config){if(this.scrollStrategy=new NoopScrollStrategy,this.panelClass=\"\",this.hasBackdrop=!1,this.backdropClass=\"cdk-overlay-dark-backdrop\",this.disposeOnNavigation=!1,config){const configKeys=Object.keys(config);for(const key of configKeys)void 0!==config[key]&&(this[key]=config[key])}}}class ConnectionPositionPair{constructor(origin,overlay,offsetX,offsetY,panelClass){this.offsetX=offsetX,this.offsetY=offsetY,this.panelClass=panelClass,this.originX=origin.originX,this.originY=origin.originY,this.overlayX=overlay.overlayX,this.overlayY=overlay.overlayY}}class ConnectedOverlayPositionChange{constructor(connectionPair,scrollableViewProperties){this.connectionPair=connectionPair,this.scrollableViewProperties=scrollableViewProperties}}function validateVerticalPosition(property,value){if(\"top\"!==value&&\"bottom\"!==value&&\"center\"!==value)throw Error(`ConnectedPosition: Invalid ${property} \"${value}\". Expected \"top\", \"bottom\" or \"center\".`)}function validateHorizontalPosition(property,value){if(\"start\"!==value&&\"end\"!==value&&\"center\"!==value)throw Error(`ConnectedPosition: Invalid ${property} \"${value}\". Expected \"start\", \"end\" or \"center\".`)}let overlay_OverlayKeyboardDispatcher=(()=>{class OverlayKeyboardDispatcher{constructor(document){this._attachedOverlays=[],this._keydownListener=event=>{const overlays=this._attachedOverlays;for(let i=overlays.length-1;i>-1;i--)if(overlays[i]._keydownEvents.observers.length>0){overlays[i]._keydownEvents.next(event);break}},this._document=document}ngOnDestroy(){this._detach()}add(overlayRef){this.remove(overlayRef),this._isAttached||(this._document.body.addEventListener(\"keydown\",this._keydownListener),this._isAttached=!0),this._attachedOverlays.push(overlayRef)}remove(overlayRef){const index=this._attachedOverlays.indexOf(overlayRef);index>-1&&this._attachedOverlays.splice(index,1),0===this._attachedOverlays.length&&this._detach()}_detach(){this._isAttached&&(this._document.body.removeEventListener(\"keydown\",this._keydownListener),this._isAttached=!1)}}return OverlayKeyboardDispatcher.ɵfac=function(t){return new(t||OverlayKeyboardDispatcher)(core.Zb(common.e))},OverlayKeyboardDispatcher.ɵprov=Object(core.Lb)({factory:function(){return new OverlayKeyboardDispatcher(Object(core.Zb)(common.e))},token:OverlayKeyboardDispatcher,providedIn:\"root\"}),OverlayKeyboardDispatcher})();const isTestEnvironment=!(\"undefined\"==typeof window||!window||!window.__karma__&&!window.jasmine);let overlay_OverlayContainer=(()=>{class OverlayContainer{constructor(document,_platform){this._platform=_platform,this._document=document}ngOnDestroy(){const container=this._containerElement;container&&container.parentNode&&container.parentNode.removeChild(container)}getContainerElement(){return this._containerElement||this._createContainer(),this._containerElement}_createContainer(){const isBrowser=this._platform?this._platform.isBrowser:\"undefined\"!=typeof window;if(isBrowser||isTestEnvironment){const oppositePlatformContainers=this._document.querySelectorAll('.cdk-overlay-container[platform=\"server\"], .cdk-overlay-container[platform=\"test\"]');for(let i=0;i<oppositePlatformContainers.length;i++)oppositePlatformContainers[i].parentNode.removeChild(oppositePlatformContainers[i])}const container=this._document.createElement(\"div\");container.classList.add(\"cdk-overlay-container\"),isTestEnvironment?container.setAttribute(\"platform\",\"test\"):isBrowser||container.setAttribute(\"platform\",\"server\"),this._document.body.appendChild(container),this._containerElement=container}}return OverlayContainer.ɵfac=function(t){return new(t||OverlayContainer)(core.Zb(common.e),core.Zb(fesm2015_platform.a))},OverlayContainer.ɵprov=Object(core.Lb)({factory:function(){return new OverlayContainer(Object(core.Zb)(common.e),Object(core.Zb)(fesm2015_platform.a))},token:OverlayContainer,providedIn:\"root\"}),OverlayContainer})();class overlay_OverlayRef{constructor(_portalOutlet,_host,_pane,_config,_ngZone,_keyboardDispatcher,_document,_location){this._portalOutlet=_portalOutlet,this._host=_host,this._pane=_pane,this._config=_config,this._ngZone=_ngZone,this._keyboardDispatcher=_keyboardDispatcher,this._document=_document,this._location=_location,this._backdropElement=null,this._backdropClick=new Subject.a,this._attachments=new Subject.a,this._detachments=new Subject.a,this._locationChanges=Subscription.a.EMPTY,this._backdropClickHandler=event=>this._backdropClick.next(event),this._keydownEvents=new Subject.a,_config.scrollStrategy&&(this._scrollStrategy=_config.scrollStrategy,this._scrollStrategy.attach(this)),this._positionStrategy=_config.positionStrategy}get overlayElement(){return this._pane}get backdropElement(){return this._backdropElement}get hostElement(){return this._host}attach(portal){let attachResult=this._portalOutlet.attach(portal);return!this._host.parentElement&&this._previousHostParent&&this._previousHostParent.appendChild(this._host),this._positionStrategy&&this._positionStrategy.attach(this),this._updateStackingOrder(),this._updateElementSize(),this._updateElementDirection(),this._scrollStrategy&&this._scrollStrategy.enable(),this._ngZone.onStable.asObservable().pipe(Object(take.a)(1)).subscribe(()=>{this.hasAttached()&&this.updatePosition()}),this._togglePointerEvents(!0),this._config.hasBackdrop&&this._attachBackdrop(),this._config.panelClass&&this._toggleClasses(this._pane,this._config.panelClass,!0),this._attachments.next(),this._keyboardDispatcher.add(this),this._config.disposeOnNavigation&&this._location&&(this._locationChanges=this._location.subscribe(()=>this.dispose())),attachResult}detach(){if(!this.hasAttached())return;this.detachBackdrop(),this._togglePointerEvents(!1),this._positionStrategy&&this._positionStrategy.detach&&this._positionStrategy.detach(),this._scrollStrategy&&this._scrollStrategy.disable();const detachmentResult=this._portalOutlet.detach();return this._detachments.next(),this._keyboardDispatcher.remove(this),this._detachContentWhenStable(),this._locationChanges.unsubscribe(),detachmentResult}dispose(){const isAttached=this.hasAttached();this._positionStrategy&&this._positionStrategy.dispose(),this._disposeScrollStrategy(),this.detachBackdrop(),this._locationChanges.unsubscribe(),this._keyboardDispatcher.remove(this),this._portalOutlet.dispose(),this._attachments.complete(),this._backdropClick.complete(),this._keydownEvents.complete(),this._host&&this._host.parentNode&&(this._host.parentNode.removeChild(this._host),this._host=null),this._previousHostParent=this._pane=null,isAttached&&this._detachments.next(),this._detachments.complete()}hasAttached(){return this._portalOutlet.hasAttached()}backdropClick(){return this._backdropClick.asObservable()}attachments(){return this._attachments.asObservable()}detachments(){return this._detachments.asObservable()}keydownEvents(){return this._keydownEvents.asObservable()}getConfig(){return this._config}updatePosition(){this._positionStrategy&&this._positionStrategy.apply()}updatePositionStrategy(strategy){strategy!==this._positionStrategy&&(this._positionStrategy&&this._positionStrategy.dispose(),this._positionStrategy=strategy,this.hasAttached()&&(strategy.attach(this),this.updatePosition()))}updateSize(sizeConfig){this._config=Object.assign(Object.assign({},this._config),sizeConfig),this._updateElementSize()}setDirection(dir){this._config=Object.assign(Object.assign({},this._config),{direction:dir}),this._updateElementDirection()}addPanelClass(classes){this._pane&&this._toggleClasses(this._pane,classes,!0)}removePanelClass(classes){this._pane&&this._toggleClasses(this._pane,classes,!1)}getDirection(){const direction=this._config.direction;return direction?\"string\"==typeof direction?direction:direction.value:\"ltr\"}updateScrollStrategy(strategy){strategy!==this._scrollStrategy&&(this._disposeScrollStrategy(),this._scrollStrategy=strategy,this.hasAttached()&&(strategy.attach(this),strategy.enable()))}_updateElementDirection(){this._host.setAttribute(\"dir\",this.getDirection())}_updateElementSize(){if(!this._pane)return;const style=this._pane.style;style.width=coerceCssPixelValue(this._config.width),style.height=coerceCssPixelValue(this._config.height),style.minWidth=coerceCssPixelValue(this._config.minWidth),style.minHeight=coerceCssPixelValue(this._config.minHeight),style.maxWidth=coerceCssPixelValue(this._config.maxWidth),style.maxHeight=coerceCssPixelValue(this._config.maxHeight)}_togglePointerEvents(enablePointer){this._pane.style.pointerEvents=enablePointer?\"auto\":\"none\"}_attachBackdrop(){this._backdropElement=this._document.createElement(\"div\"),this._backdropElement.classList.add(\"cdk-overlay-backdrop\"),this._config.backdropClass&&this._toggleClasses(this._backdropElement,this._config.backdropClass,!0),this._host.parentElement.insertBefore(this._backdropElement,this._host),this._backdropElement.addEventListener(\"click\",this._backdropClickHandler),\"undefined\"!=typeof requestAnimationFrame?this._ngZone.runOutsideAngular(()=>{requestAnimationFrame(()=>{this._backdropElement&&this._backdropElement.classList.add(\"cdk-overlay-backdrop-showing\")})}):this._backdropElement.classList.add(\"cdk-overlay-backdrop-showing\")}_updateStackingOrder(){this._host.nextSibling&&this._host.parentNode.appendChild(this._host)}detachBackdrop(){let timeoutId,backdropToDetach=this._backdropElement;if(!backdropToDetach)return;let finishDetach=()=>{backdropToDetach&&(backdropToDetach.removeEventListener(\"click\",this._backdropClickHandler),backdropToDetach.removeEventListener(\"transitionend\",finishDetach),backdropToDetach.parentNode&&backdropToDetach.parentNode.removeChild(backdropToDetach)),this._backdropElement==backdropToDetach&&(this._backdropElement=null),this._config.backdropClass&&this._toggleClasses(backdropToDetach,this._config.backdropClass,!1),clearTimeout(timeoutId)};backdropToDetach.classList.remove(\"cdk-overlay-backdrop-showing\"),this._ngZone.runOutsideAngular(()=>{backdropToDetach.addEventListener(\"transitionend\",finishDetach)}),backdropToDetach.style.pointerEvents=\"none\",timeoutId=this._ngZone.runOutsideAngular(()=>setTimeout(finishDetach,500))}_toggleClasses(element,cssClasses,isAdd){const classList=element.classList;coerceArray(cssClasses).forEach(cssClass=>{cssClass&&(isAdd?classList.add(cssClass):classList.remove(cssClass))})}_detachContentWhenStable(){this._ngZone.runOutsideAngular(()=>{const subscription=this._ngZone.onStable.asObservable().pipe((notifier=Object(merge.a)(this._attachments,this._detachments),source=>source.lift(new takeUntil_TakeUntilOperator(notifier)))).subscribe(()=>{this._pane&&this._host&&0!==this._pane.children.length||(this._pane&&this._config.panelClass&&this._toggleClasses(this._pane,this._config.panelClass,!1),this._host&&this._host.parentElement&&(this._previousHostParent=this._host.parentElement,this._previousHostParent.removeChild(this._host)),subscription.unsubscribe())});var notifier})}_disposeScrollStrategy(){const scrollStrategy=this._scrollStrategy;scrollStrategy&&(scrollStrategy.disable(),scrollStrategy.detach&&scrollStrategy.detach())}}const cssUnitPattern=/([A-Za-z%]+)$/;class overlay_FlexibleConnectedPositionStrategy{constructor(connectedTo,_viewportRuler,_document,_platform,_overlayContainer){this._viewportRuler=_viewportRuler,this._document=_document,this._platform=_platform,this._overlayContainer=_overlayContainer,this._lastBoundingBoxSize={width:0,height:0},this._isPushed=!1,this._canPush=!0,this._growAfterOpen=!1,this._hasFlexibleDimensions=!0,this._positionLocked=!1,this._viewportMargin=0,this._scrollables=[],this._preferredPositions=[],this._positionChanges=new Subject.a,this._resizeSubscription=Subscription.a.EMPTY,this._offsetX=0,this._offsetY=0,this._appliedPanelClasses=[],this.positionChanges=this._positionChanges.asObservable(),this.setOrigin(connectedTo)}get positions(){return this._preferredPositions}attach(overlayRef){if(this._overlayRef&&overlayRef!==this._overlayRef)throw Error(\"This position strategy is already attached to an overlay\");this._validatePositions(),overlayRef.hostElement.classList.add(\"cdk-overlay-connected-position-bounding-box\"),this._overlayRef=overlayRef,this._boundingBox=overlayRef.hostElement,this._pane=overlayRef.overlayElement,this._isDisposed=!1,this._isInitialRender=!0,this._lastPosition=null,this._resizeSubscription.unsubscribe(),this._resizeSubscription=this._viewportRuler.change().subscribe(()=>{this._isInitialRender=!0,this.apply()})}apply(){if(this._isDisposed||!this._platform.isBrowser)return;if(!this._isInitialRender&&this._positionLocked&&this._lastPosition)return void this.reapplyLastPosition();this._clearPanelClasses(),this._resetOverlayElementStyles(),this._resetBoundingBoxStyles(),this._viewportRect=this._getNarrowedViewportRect(),this._originRect=this._getOriginRect(),this._overlayRect=this._pane.getBoundingClientRect();const originRect=this._originRect,overlayRect=this._overlayRect,viewportRect=this._viewportRect,flexibleFits=[];let fallback;for(let pos of this._preferredPositions){let originPoint=this._getOriginPoint(originRect,pos),overlayPoint=this._getOverlayPoint(originPoint,overlayRect,pos),overlayFit=this._getOverlayFit(overlayPoint,overlayRect,viewportRect,pos);if(overlayFit.isCompletelyWithinViewport)return this._isPushed=!1,void this._applyPosition(pos,originPoint);this._canFitWithFlexibleDimensions(overlayFit,overlayPoint,viewportRect)?flexibleFits.push({position:pos,origin:originPoint,overlayRect:overlayRect,boundingBoxRect:this._calculateBoundingBoxRect(originPoint,pos)}):(!fallback||fallback.overlayFit.visibleArea<overlayFit.visibleArea)&&(fallback={overlayFit:overlayFit,overlayPoint:overlayPoint,originPoint:originPoint,position:pos,overlayRect:overlayRect})}if(flexibleFits.length){let bestFit=null,bestScore=-1;for(const fit of flexibleFits){const score=fit.boundingBoxRect.width*fit.boundingBoxRect.height*(fit.position.weight||1);score>bestScore&&(bestScore=score,bestFit=fit)}return this._isPushed=!1,void this._applyPosition(bestFit.position,bestFit.origin)}if(this._canPush)return this._isPushed=!0,void this._applyPosition(fallback.position,fallback.originPoint);this._applyPosition(fallback.position,fallback.originPoint)}detach(){this._clearPanelClasses(),this._lastPosition=null,this._previousPushAmount=null,this._resizeSubscription.unsubscribe()}dispose(){this._isDisposed||(this._boundingBox&&extendStyles(this._boundingBox.style,{top:\"\",left:\"\",right:\"\",bottom:\"\",height:\"\",width:\"\",alignItems:\"\",justifyContent:\"\"}),this._pane&&this._resetOverlayElementStyles(),this._overlayRef&&this._overlayRef.hostElement.classList.remove(\"cdk-overlay-connected-position-bounding-box\"),this.detach(),this._positionChanges.complete(),this._overlayRef=this._boundingBox=null,this._isDisposed=!0)}reapplyLastPosition(){if(!this._isDisposed&&(!this._platform||this._platform.isBrowser)){this._originRect=this._getOriginRect(),this._overlayRect=this._pane.getBoundingClientRect(),this._viewportRect=this._getNarrowedViewportRect();const lastPosition=this._lastPosition||this._preferredPositions[0],originPoint=this._getOriginPoint(this._originRect,lastPosition);this._applyPosition(lastPosition,originPoint)}}withScrollableContainers(scrollables){return this._scrollables=scrollables,this}withPositions(positions){return this._preferredPositions=positions,-1===positions.indexOf(this._lastPosition)&&(this._lastPosition=null),this._validatePositions(),this}withViewportMargin(margin){return this._viewportMargin=margin,this}withFlexibleDimensions(flexibleDimensions=!0){return this._hasFlexibleDimensions=flexibleDimensions,this}withGrowAfterOpen(growAfterOpen=!0){return this._growAfterOpen=growAfterOpen,this}withPush(canPush=!0){return this._canPush=canPush,this}withLockedPosition(isLocked=!0){return this._positionLocked=isLocked,this}setOrigin(origin){return this._origin=origin,this}withDefaultOffsetX(offset){return this._offsetX=offset,this}withDefaultOffsetY(offset){return this._offsetY=offset,this}withTransformOriginOn(selector){return this._transformOriginSelector=selector,this}_getOriginPoint(originRect,pos){let x,y;if(\"center\"==pos.originX)x=originRect.left+originRect.width/2;else{const startX=this._isRtl()?originRect.right:originRect.left,endX=this._isRtl()?originRect.left:originRect.right;x=\"start\"==pos.originX?startX:endX}return y=\"center\"==pos.originY?originRect.top+originRect.height/2:\"top\"==pos.originY?originRect.top:originRect.bottom,{x:x,y:y}}_getOverlayPoint(originPoint,overlayRect,pos){let overlayStartX,overlayStartY;return overlayStartX=\"center\"==pos.overlayX?-overlayRect.width/2:\"start\"===pos.overlayX?this._isRtl()?-overlayRect.width:0:this._isRtl()?0:-overlayRect.width,overlayStartY=\"center\"==pos.overlayY?-overlayRect.height/2:\"top\"==pos.overlayY?0:-overlayRect.height,{x:originPoint.x+overlayStartX,y:originPoint.y+overlayStartY}}_getOverlayFit(point,overlay,viewport,position){let{x:x,y:y}=point,offsetX=this._getOffset(position,\"x\"),offsetY=this._getOffset(position,\"y\");offsetX&&(x+=offsetX),offsetY&&(y+=offsetY);let topOverflow=0-y,bottomOverflow=y+overlay.height-viewport.height,visibleWidth=this._subtractOverflows(overlay.width,0-x,x+overlay.width-viewport.width),visibleHeight=this._subtractOverflows(overlay.height,topOverflow,bottomOverflow),visibleArea=visibleWidth*visibleHeight;return{visibleArea:visibleArea,isCompletelyWithinViewport:overlay.width*overlay.height===visibleArea,fitsInViewportVertically:visibleHeight===overlay.height,fitsInViewportHorizontally:visibleWidth==overlay.width}}_canFitWithFlexibleDimensions(fit,point,viewport){if(this._hasFlexibleDimensions){const availableHeight=viewport.bottom-point.y,availableWidth=viewport.right-point.x,minHeight=getPixelValue(this._overlayRef.getConfig().minHeight),minWidth=getPixelValue(this._overlayRef.getConfig().minWidth),horizontalFit=fit.fitsInViewportHorizontally||null!=minWidth&&minWidth<=availableWidth;return(fit.fitsInViewportVertically||null!=minHeight&&minHeight<=availableHeight)&&horizontalFit}return!1}_pushOverlayOnScreen(start,overlay,scrollPosition){if(this._previousPushAmount&&this._positionLocked)return{x:start.x+this._previousPushAmount.x,y:start.y+this._previousPushAmount.y};const viewport=this._viewportRect,overflowRight=Math.max(start.x+overlay.width-viewport.right,0),overflowBottom=Math.max(start.y+overlay.height-viewport.bottom,0),overflowTop=Math.max(viewport.top-scrollPosition.top-start.y,0),overflowLeft=Math.max(viewport.left-scrollPosition.left-start.x,0);let pushX=0,pushY=0;return pushX=overlay.width<=viewport.width?overflowLeft||-overflowRight:start.x<this._viewportMargin?viewport.left-scrollPosition.left-start.x:0,pushY=overlay.height<=viewport.height?overflowTop||-overflowBottom:start.y<this._viewportMargin?viewport.top-scrollPosition.top-start.y:0,this._previousPushAmount={x:pushX,y:pushY},{x:start.x+pushX,y:start.y+pushY}}_applyPosition(position,originPoint){if(this._setTransformOrigin(position),this._setOverlayElementStyles(originPoint,position),this._setBoundingBoxStyles(originPoint,position),position.panelClass&&this._addPanelClasses(position.panelClass),this._lastPosition=position,this._positionChanges.observers.length){const scrollableViewProperties=this._getScrollVisibility(),changeEvent=new ConnectedOverlayPositionChange(position,scrollableViewProperties);this._positionChanges.next(changeEvent)}this._isInitialRender=!1}_setTransformOrigin(position){if(!this._transformOriginSelector)return;const elements=this._boundingBox.querySelectorAll(this._transformOriginSelector);let xOrigin,yOrigin=position.overlayY;xOrigin=\"center\"===position.overlayX?\"center\":this._isRtl()?\"start\"===position.overlayX?\"right\":\"left\":\"start\"===position.overlayX?\"left\":\"right\";for(let i=0;i<elements.length;i++)elements[i].style.transformOrigin=`${xOrigin} ${yOrigin}`}_calculateBoundingBoxRect(origin,position){const viewport=this._viewportRect,isRtl=this._isRtl();let height,top,bottom,width,left,right;if(\"top\"===position.overlayY)top=origin.y,height=viewport.height-top+this._viewportMargin;else if(\"bottom\"===position.overlayY)bottom=viewport.height-origin.y+2*this._viewportMargin,height=viewport.height-bottom+this._viewportMargin;else{const smallestDistanceToViewportEdge=Math.min(viewport.bottom-origin.y+viewport.top,origin.y),previousHeight=this._lastBoundingBoxSize.height;height=2*smallestDistanceToViewportEdge,top=origin.y-smallestDistanceToViewportEdge,height>previousHeight&&!this._isInitialRender&&!this._growAfterOpen&&(top=origin.y-previousHeight/2)}if(\"end\"===position.overlayX&&!isRtl||\"start\"===position.overlayX&&isRtl)right=viewport.width-origin.x+this._viewportMargin,width=origin.x-this._viewportMargin;else if(\"start\"===position.overlayX&&!isRtl||\"end\"===position.overlayX&&isRtl)left=origin.x,width=viewport.right-origin.x;else{const smallestDistanceToViewportEdge=Math.min(viewport.right-origin.x+viewport.left,origin.x),previousWidth=this._lastBoundingBoxSize.width;width=2*smallestDistanceToViewportEdge,left=origin.x-smallestDistanceToViewportEdge,width>previousWidth&&!this._isInitialRender&&!this._growAfterOpen&&(left=origin.x-previousWidth/2)}return{top:top,left:left,bottom:bottom,right:right,width:width,height:height}}_setBoundingBoxStyles(origin,position){const boundingBoxRect=this._calculateBoundingBoxRect(origin,position);this._isInitialRender||this._growAfterOpen||(boundingBoxRect.height=Math.min(boundingBoxRect.height,this._lastBoundingBoxSize.height),boundingBoxRect.width=Math.min(boundingBoxRect.width,this._lastBoundingBoxSize.width));const styles={};if(this._hasExactPosition())styles.top=styles.left=\"0\",styles.bottom=styles.right=styles.maxHeight=styles.maxWidth=\"\",styles.width=styles.height=\"100%\";else{const maxHeight=this._overlayRef.getConfig().maxHeight,maxWidth=this._overlayRef.getConfig().maxWidth;styles.height=coerceCssPixelValue(boundingBoxRect.height),styles.top=coerceCssPixelValue(boundingBoxRect.top),styles.bottom=coerceCssPixelValue(boundingBoxRect.bottom),styles.width=coerceCssPixelValue(boundingBoxRect.width),styles.left=coerceCssPixelValue(boundingBoxRect.left),styles.right=coerceCssPixelValue(boundingBoxRect.right),styles.alignItems=\"center\"===position.overlayX?\"center\":\"end\"===position.overlayX?\"flex-end\":\"flex-start\",styles.justifyContent=\"center\"===position.overlayY?\"center\":\"bottom\"===position.overlayY?\"flex-end\":\"flex-start\",maxHeight&&(styles.maxHeight=coerceCssPixelValue(maxHeight)),maxWidth&&(styles.maxWidth=coerceCssPixelValue(maxWidth))}this._lastBoundingBoxSize=boundingBoxRect,extendStyles(this._boundingBox.style,styles)}_resetBoundingBoxStyles(){extendStyles(this._boundingBox.style,{top:\"0\",left:\"0\",right:\"0\",bottom:\"0\",height:\"\",width:\"\",alignItems:\"\",justifyContent:\"\"})}_resetOverlayElementStyles(){extendStyles(this._pane.style,{top:\"\",left:\"\",bottom:\"\",right:\"\",position:\"\",transform:\"\"})}_setOverlayElementStyles(originPoint,position){const styles={},hasExactPosition=this._hasExactPosition(),hasFlexibleDimensions=this._hasFlexibleDimensions,config=this._overlayRef.getConfig();if(hasExactPosition){const scrollPosition=this._viewportRuler.getViewportScrollPosition();extendStyles(styles,this._getExactOverlayY(position,originPoint,scrollPosition)),extendStyles(styles,this._getExactOverlayX(position,originPoint,scrollPosition))}else styles.position=\"static\";let transformString=\"\",offsetX=this._getOffset(position,\"x\"),offsetY=this._getOffset(position,\"y\");offsetX&&(transformString+=`translateX(${offsetX}px) `),offsetY&&(transformString+=`translateY(${offsetY}px)`),styles.transform=transformString.trim(),config.maxHeight&&(hasExactPosition?styles.maxHeight=coerceCssPixelValue(config.maxHeight):hasFlexibleDimensions&&(styles.maxHeight=\"\")),config.maxWidth&&(hasExactPosition?styles.maxWidth=coerceCssPixelValue(config.maxWidth):hasFlexibleDimensions&&(styles.maxWidth=\"\")),extendStyles(this._pane.style,styles)}_getExactOverlayY(position,originPoint,scrollPosition){let styles={top:\"\",bottom:\"\"},overlayPoint=this._getOverlayPoint(originPoint,this._overlayRect,position);this._isPushed&&(overlayPoint=this._pushOverlayOnScreen(overlayPoint,this._overlayRect,scrollPosition));let virtualKeyboardOffset=this._overlayContainer.getContainerElement().getBoundingClientRect().top;return overlayPoint.y-=virtualKeyboardOffset,\"bottom\"===position.overlayY?styles.bottom=this._document.documentElement.clientHeight-(overlayPoint.y+this._overlayRect.height)+\"px\":styles.top=coerceCssPixelValue(overlayPoint.y),styles}_getExactOverlayX(position,originPoint,scrollPosition){let horizontalStyleProperty,styles={left:\"\",right:\"\"},overlayPoint=this._getOverlayPoint(originPoint,this._overlayRect,position);return this._isPushed&&(overlayPoint=this._pushOverlayOnScreen(overlayPoint,this._overlayRect,scrollPosition)),horizontalStyleProperty=this._isRtl()?\"end\"===position.overlayX?\"left\":\"right\":\"end\"===position.overlayX?\"right\":\"left\",\"right\"===horizontalStyleProperty?styles.right=this._document.documentElement.clientWidth-(overlayPoint.x+this._overlayRect.width)+\"px\":styles.left=coerceCssPixelValue(overlayPoint.x),styles}_getScrollVisibility(){const originBounds=this._getOriginRect(),overlayBounds=this._pane.getBoundingClientRect(),scrollContainerBounds=this._scrollables.map(scrollable=>scrollable.getElementRef().nativeElement.getBoundingClientRect());return{isOriginClipped:isElementClippedByScrolling(originBounds,scrollContainerBounds),isOriginOutsideView:isElementScrolledOutsideView(originBounds,scrollContainerBounds),isOverlayClipped:isElementClippedByScrolling(overlayBounds,scrollContainerBounds),isOverlayOutsideView:isElementScrolledOutsideView(overlayBounds,scrollContainerBounds)}}_subtractOverflows(length,...overflows){return overflows.reduce((currentValue,currentOverflow)=>currentValue-Math.max(currentOverflow,0),length)}_getNarrowedViewportRect(){const width=this._document.documentElement.clientWidth,height=this._document.documentElement.clientHeight,scrollPosition=this._viewportRuler.getViewportScrollPosition();return{top:scrollPosition.top+this._viewportMargin,left:scrollPosition.left+this._viewportMargin,right:scrollPosition.left+width-this._viewportMargin,bottom:scrollPosition.top+height-this._viewportMargin,width:width-2*this._viewportMargin,height:height-2*this._viewportMargin}}_isRtl(){return\"rtl\"===this._overlayRef.getDirection()}_hasExactPosition(){return!this._hasFlexibleDimensions||this._isPushed}_getOffset(position,axis){return\"x\"===axis?null==position.offsetX?this._offsetX:position.offsetX:null==position.offsetY?this._offsetY:position.offsetY}_validatePositions(){if(!this._preferredPositions.length)throw Error(\"FlexibleConnectedPositionStrategy: At least one position is required.\");this._preferredPositions.forEach(pair=>{validateHorizontalPosition(\"originX\",pair.originX),validateVerticalPosition(\"originY\",pair.originY),validateHorizontalPosition(\"overlayX\",pair.overlayX),validateVerticalPosition(\"overlayY\",pair.overlayY)})}_addPanelClasses(cssClasses){this._pane&&coerceArray(cssClasses).forEach(cssClass=>{\"\"!==cssClass&&-1===this._appliedPanelClasses.indexOf(cssClass)&&(this._appliedPanelClasses.push(cssClass),this._pane.classList.add(cssClass))})}_clearPanelClasses(){this._pane&&(this._appliedPanelClasses.forEach(cssClass=>{this._pane.classList.remove(cssClass)}),this._appliedPanelClasses=[])}_getOriginRect(){const origin=this._origin;if(origin instanceof core.m)return origin.nativeElement.getBoundingClientRect();if(origin instanceof Element)return origin.getBoundingClientRect();const width=origin.width||0,height=origin.height||0;return{top:origin.y,bottom:origin.y+height,left:origin.x,right:origin.x+width,height:height,width:width}}}function extendStyles(destination,source){for(let key in source)source.hasOwnProperty(key)&&(destination[key]=source[key]);return destination}function getPixelValue(input){if(\"number\"!=typeof input&&null!=input){const[value,units]=input.split(cssUnitPattern);return units&&\"px\"!==units?null:parseFloat(value)}return input||null}class ConnectedPositionStrategy{constructor(originPos,overlayPos,connectedTo,viewportRuler,document,platform,overlayContainer){this._preferredPositions=[],this._positionStrategy=new overlay_FlexibleConnectedPositionStrategy(connectedTo,viewportRuler,document,platform,overlayContainer).withFlexibleDimensions(!1).withPush(!1).withViewportMargin(0),this.withFallbackPosition(originPos,overlayPos)}get _isRtl(){return\"rtl\"===this._overlayRef.getDirection()}get onPositionChange(){return this._positionStrategy.positionChanges}get positions(){return this._preferredPositions}attach(overlayRef){this._overlayRef=overlayRef,this._positionStrategy.attach(overlayRef),this._direction&&(overlayRef.setDirection(this._direction),this._direction=null)}dispose(){this._positionStrategy.dispose()}detach(){this._positionStrategy.detach()}apply(){this._positionStrategy.apply()}recalculateLastPosition(){this._positionStrategy.reapplyLastPosition()}withScrollableContainers(scrollables){this._positionStrategy.withScrollableContainers(scrollables)}withFallbackPosition(originPos,overlayPos,offsetX,offsetY){const position=new ConnectionPositionPair(originPos,overlayPos,offsetX,offsetY);return this._preferredPositions.push(position),this._positionStrategy.withPositions(this._preferredPositions),this}withDirection(dir){return this._overlayRef?this._overlayRef.setDirection(dir):this._direction=dir,this}withOffsetX(offset){return this._positionStrategy.withDefaultOffsetX(offset),this}withOffsetY(offset){return this._positionStrategy.withDefaultOffsetY(offset),this}withLockedPosition(isLocked){return this._positionStrategy.withLockedPosition(isLocked),this}withPositions(positions){return this._preferredPositions=positions.slice(),this._positionStrategy.withPositions(this._preferredPositions),this}setOrigin(origin){return this._positionStrategy.setOrigin(origin),this}}class GlobalPositionStrategy{constructor(){this._cssPosition=\"static\",this._topOffset=\"\",this._bottomOffset=\"\",this._leftOffset=\"\",this._rightOffset=\"\",this._alignItems=\"\",this._justifyContent=\"\",this._width=\"\",this._height=\"\"}attach(overlayRef){const config=overlayRef.getConfig();this._overlayRef=overlayRef,this._width&&!config.width&&overlayRef.updateSize({width:this._width}),this._height&&!config.height&&overlayRef.updateSize({height:this._height}),overlayRef.hostElement.classList.add(\"cdk-global-overlay-wrapper\"),this._isDisposed=!1}top(value=\"\"){return this._bottomOffset=\"\",this._topOffset=value,this._alignItems=\"flex-start\",this}left(value=\"\"){return this._rightOffset=\"\",this._leftOffset=value,this._justifyContent=\"flex-start\",this}bottom(value=\"\"){return this._topOffset=\"\",this._bottomOffset=value,this._alignItems=\"flex-end\",this}right(value=\"\"){return this._leftOffset=\"\",this._rightOffset=value,this._justifyContent=\"flex-end\",this}width(value=\"\"){return this._overlayRef?this._overlayRef.updateSize({width:value}):this._width=value,this}height(value=\"\"){return this._overlayRef?this._overlayRef.updateSize({height:value}):this._height=value,this}centerHorizontally(offset=\"\"){return this.left(offset),this._justifyContent=\"center\",this}centerVertically(offset=\"\"){return this.top(offset),this._alignItems=\"center\",this}apply(){if(!this._overlayRef||!this._overlayRef.hasAttached())return;const styles=this._overlayRef.overlayElement.style,parentStyles=this._overlayRef.hostElement.style,config=this._overlayRef.getConfig(),{width:width,height:height,maxWidth:maxWidth,maxHeight:maxHeight}=config,shouldBeFlushHorizontally=!(\"100%\"!==width&&\"100vw\"!==width||maxWidth&&\"100%\"!==maxWidth&&\"100vw\"!==maxWidth),shouldBeFlushVertically=!(\"100%\"!==height&&\"100vh\"!==height||maxHeight&&\"100%\"!==maxHeight&&\"100vh\"!==maxHeight);styles.position=this._cssPosition,styles.marginLeft=shouldBeFlushHorizontally?\"0\":this._leftOffset,styles.marginTop=shouldBeFlushVertically?\"0\":this._topOffset,styles.marginBottom=this._bottomOffset,styles.marginRight=this._rightOffset,shouldBeFlushHorizontally?parentStyles.justifyContent=\"flex-start\":\"center\"===this._justifyContent?parentStyles.justifyContent=\"center\":\"rtl\"===this._overlayRef.getConfig().direction?\"flex-start\"===this._justifyContent?parentStyles.justifyContent=\"flex-end\":\"flex-end\"===this._justifyContent&&(parentStyles.justifyContent=\"flex-start\"):parentStyles.justifyContent=this._justifyContent,parentStyles.alignItems=shouldBeFlushVertically?\"flex-start\":this._alignItems}dispose(){if(this._isDisposed||!this._overlayRef)return;const styles=this._overlayRef.overlayElement.style,parent=this._overlayRef.hostElement,parentStyles=parent.style;parent.classList.remove(\"cdk-global-overlay-wrapper\"),parentStyles.justifyContent=parentStyles.alignItems=styles.marginTop=styles.marginBottom=styles.marginLeft=styles.marginRight=styles.position=\"\",this._overlayRef=null,this._isDisposed=!0}}let overlay_OverlayPositionBuilder=(()=>{class OverlayPositionBuilder{constructor(_viewportRuler,_document,_platform,_overlayContainer){this._viewportRuler=_viewportRuler,this._document=_document,this._platform=_platform,this._overlayContainer=_overlayContainer}global(){return new GlobalPositionStrategy}connectedTo(elementRef,originPos,overlayPos){return new ConnectedPositionStrategy(originPos,overlayPos,elementRef,this._viewportRuler,this._document,this._platform,this._overlayContainer)}flexibleConnectedTo(origin){return new overlay_FlexibleConnectedPositionStrategy(origin,this._viewportRuler,this._document,this._platform,this._overlayContainer)}}return OverlayPositionBuilder.ɵfac=function(t){return new(t||OverlayPositionBuilder)(core.Zb(scrolling_ViewportRuler),core.Zb(common.e),core.Zb(fesm2015_platform.a),core.Zb(overlay_OverlayContainer))},OverlayPositionBuilder.ɵprov=Object(core.Lb)({factory:function(){return new OverlayPositionBuilder(Object(core.Zb)(scrolling_ViewportRuler),Object(core.Zb)(common.e),Object(core.Zb)(fesm2015_platform.a),Object(core.Zb)(overlay_OverlayContainer))},token:OverlayPositionBuilder,providedIn:\"root\"}),OverlayPositionBuilder})(),nextUniqueId=0,overlay_Overlay=(()=>{class Overlay{constructor(scrollStrategies,_overlayContainer,_componentFactoryResolver,_positionBuilder,_keyboardDispatcher,_injector,_ngZone,_document,_directionality,_location){this.scrollStrategies=scrollStrategies,this._overlayContainer=_overlayContainer,this._componentFactoryResolver=_componentFactoryResolver,this._positionBuilder=_positionBuilder,this._keyboardDispatcher=_keyboardDispatcher,this._injector=_injector,this._ngZone=_ngZone,this._document=_document,this._directionality=_directionality,this._location=_location}create(config){const host=this._createHostElement(),pane=this._createPaneElement(host),portalOutlet=this._createPortalOutlet(pane),overlayConfig=new OverlayConfig(config);return overlayConfig.direction=overlayConfig.direction||this._directionality.value,new overlay_OverlayRef(portalOutlet,host,pane,overlayConfig,this._ngZone,this._keyboardDispatcher,this._document,this._location)}position(){return this._positionBuilder}_createPaneElement(host){const pane=this._document.createElement(\"div\");return pane.id=\"cdk-overlay-\"+nextUniqueId++,pane.classList.add(\"cdk-overlay-pane\"),host.appendChild(pane),pane}_createHostElement(){const host=this._document.createElement(\"div\");return this._overlayContainer.getContainerElement().appendChild(host),host}_createPortalOutlet(pane){return this._appRef||(this._appRef=this._injector.get(core.g)),new DomPortalOutlet(pane,this._componentFactoryResolver,this._appRef,this._injector,this._document)}}return Overlay.ɵfac=function(t){return new(t||Overlay)(core.Zb(overlay_ScrollStrategyOptions),core.Zb(overlay_OverlayContainer),core.Zb(core.k),core.Zb(overlay_OverlayPositionBuilder),core.Zb(overlay_OverlayKeyboardDispatcher),core.Zb(core.t),core.Zb(core.B),core.Zb(common.e),core.Zb(bidi_Directionality),core.Zb(common.i,8))},Overlay.ɵprov=core.Lb({token:Overlay,factory:Overlay.ɵfac}),Overlay})();const CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY_PROVIDER={provide:new core.s(\"cdk-connected-overlay-scroll-strategy\"),deps:[overlay_Overlay],useFactory:function(overlay){return()=>overlay.scrollStrategies.reposition()}};let overlay_OverlayModule=(()=>{class OverlayModule{}return OverlayModule.ɵmod=core.Nb({type:OverlayModule}),OverlayModule.ɵinj=core.Mb({factory:function(t){return new(t||OverlayModule)},providers:[overlay_Overlay,CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY_PROVIDER],imports:[[bidi_BidiModule,portal_PortalModule,scrolling_ScrollingModule],scrolling_ScrollingModule]}),OverlayModule})();var observable_from=__webpack_require__(\"Cfvw\"),finalize=__webpack_require__(\"nYR2\");const ng_gallery_lightbox_c0=function(a0,a1){return{startAnimationTime:a0,exitAnimationTime:a1}},ng_gallery_lightbox_c1=function(a0,a1){return{value:a0,params:a1}},LIGHTBOX_CONFIG=new core.s(\"LIGHTBOX_CONFIG\"),lightboxAnimation=Object(animations.l)(\"lightbox\",[Object(animations.i)(\"void, exit\",Object(animations.j)({opacity:0,transform:\"scale(0.7)\"})),Object(animations.i)(\"enter\",Object(animations.j)({transform:\"none\"})),Object(animations.k)(\"* => enter\",Object(animations.e)(\"{{startAnimationTime}}ms cubic-bezier(0, 0, 0.2, 1)\",Object(animations.j)({transform:\"none\",opacity:1}))),Object(animations.k)(\"* => void, * => exit\",Object(animations.e)(\"{{exitAnimationTime}}ms cubic-bezier(0.4, 0.0, 0.2, 1)\",Object(animations.j)({opacity:0})))]);let ng_gallery_lightbox_LightboxComponent=(()=>{class LightboxComponent{constructor(_document,_focusTrapFactory,_elementRef,sanitizer){this._document=_document,this._focusTrapFactory=_focusTrapFactory,this._elementRef=_elementRef,this.sanitizer=sanitizer,this.state=\"enter\",this._savePreviouslyFocusedElement()}onAnimationDone(event){\"enter\"===event.toState?this._trapFocus():(this.overlayRef.dispose(),this._restoreFocus())}_trapFocus(){this._focusTrap||(this._focusTrap=this._focusTrapFactory.create(this._elementRef.nativeElement)),this._focusTrap.focusInitialElementWhenReady()}_savePreviouslyFocusedElement(){this._document&&(this._elementFocusedBeforeDialogWasOpened=this._document.activeElement,this._elementRef.nativeElement.focus&&Promise.resolve().then(()=>this._elementRef.nativeElement.focus()))}_restoreFocus(){const toFocus=this._elementFocusedBeforeDialogWasOpened;toFocus&&\"function\"==typeof toFocus.focus&&toFocus.focus(),this._focusTrap&&this._focusTrap.destroy()}}return LightboxComponent.ɵfac=function(t){return new(t||LightboxComponent)(core.Pb(common.e,8),core.Pb(a11y_ConfigurableFocusTrapFactory),core.Pb(core.m),core.Pb(platform_browser.b))},LightboxComponent.ɵcmp=core.Jb({type:LightboxComponent,selectors:[[\"lightbox\"]],hostAttrs:[\"tabindex\",\"-1\",\"aria-modal\",\"true\"],hostVars:12,hostBindings:function(rf,ctx){1&rf&&core.Cc(\"@lightbox.done\",function($event){return ctx.onAnimationDone($event)}),2&rf&&(core.Eb(\"id\",\"lightbox-\"+ctx.id)(\"role\",ctx.role)(\"aria-labelledby\",ctx.ariaLabel?null:ctx.ariaLabelledBy)(\"aria-label\",ctx.ariaLabel)(\"aria-describedby\",ctx.ariaDescribedBy||null),core.Dc(\"@lightbox\",core.qc(9,ng_gallery_lightbox_c1,ctx.state,core.qc(6,ng_gallery_lightbox_c0,ctx.startAnimationTime,ctx.exitAnimationTime))))},decls:2,vars:4,consts:[[3,\"id\",\"destroyRef\",\"skipInitConfig\"],[\"aria-label\",\"Close\",1,\"g-btn-close\",3,\"innerHTML\",\"click\"]],template:function(rf,ctx){1&rf&&(core.Vb(0,\"gallery\",0),core.Vb(1,\"i\",1),core.dc(\"click\",function(){return ctx.overlayRef.detach()}),core.Ub(),core.Ub()),2&rf&&(core.lc(\"id\",ctx.id)(\"destroyRef\",!1)(\"skipInitConfig\",!0),core.Db(1),core.lc(\"innerHTML\",ctx.sanitizer.bypassSecurityTrustHtml(ctx.closeIcon),core.wc))},directives:[ng_gallery_GalleryComponent],styles:[\"lightbox{border-radius:4px;box-shadow:0 11px 15px -7px rgba(0,0,0,.2),0 24px 38px 3px rgba(0,0,0,.14),0 9px 46px 8px rgba(0,0,0,.12);display:block;height:800px;max-height:90vh;max-width:94vw;overflow:hidden;position:relative;width:1100px}  lightbox:focus{outline:none}  lightbox gallery{display:block;height:100%;margin:0;overflow:hidden;width:100%}  .g-backdrop{background-color:rgba(0,0,0,.32)}  .fullscreen{width:100%}  .fullscreen   lightbox{border-radius:0;bottom:0;height:100%;left:0;max-height:unset;max-width:unset;position:fixed;right:0;top:0;width:100%}  .g-overlay{margin:auto}@media only screen and (max-width:480px){  .g-overlay{width:100%}  .g-overlay   lightbox{border-radius:0;bottom:0;height:100%;left:0;max-height:unset;max-width:unset;position:fixed;right:0;top:0;width:100%}}  .g-btn-close{cursor:pointer;height:20px;position:absolute;right:.9em;top:.9em;width:20px;z-index:60}@media only screen and (max-width:480px){  .g-btn-close{right:.7em;top:.7em}}\"],data:{animation:[lightboxAnimation]},changeDetection:0}),LightboxComponent})();const ng_gallery_lightbox_defaultConfig={backdropClass:\"g-backdrop\",panelClass:\"g-overlay\",hasBackdrop:!0,keyboardShortcuts:!0,role:\"lightbox\",startAnimationTime:150,exitAnimationTime:75,closeIcon:'<?xml version=\"1.0\" encoding=\"UTF-8\"?>\\n<svg width=\"512px\" height=\"512px\" enable-background=\"new 0 0 47.971 47.971\" version=\"1.1\" viewBox=\"0 0 47.971 47.971\" xml:space=\"preserve\" xmlns=\"http://www.w3.org/2000/svg\">\\n\\t<path d=\"M28.228,23.986L47.092,5.122c1.172-1.171,1.172-3.071,0-4.242c-1.172-1.172-3.07-1.172-4.242,0L23.986,19.744L5.121,0.88   c-1.172-1.172-3.07-1.172-4.242,0c-1.172,1.171-1.172,3.071,0,4.242l18.865,18.864L0.879,42.85c-1.172,1.171-1.172,3.071,0,4.242   C1.465,47.677,2.233,47.97,3,47.97s1.535-0.293,2.121-0.879l18.865-18.864L42.85,47.091c0.586,0.586,1.354,0.879,2.121,0.879   s1.535-0.293,2.121-0.879c1.172-1.171,1.172-3.071,0-4.242L28.228,23.986z\" fill=\"#fff\"/>\\n</svg>\\n'};let ng_gallery_lightbox_Lightbox=(()=>{class Lightbox{constructor(config,_gallery,_overlay){this._gallery=_gallery,this._overlay=_overlay,this.opened=new Subject.a,this.closed=new Subject.a,this._config=config?Object.assign(Object.assign({},ng_gallery_lightbox_defaultConfig),config):ng_gallery_lightbox_defaultConfig}setConfig(config){this._config=Object.assign(Object.assign({},this._config),config)}open(i=0,id=\"lightbox\",config){const _config=config?Object.assign(Object.assign({},this._config),config):this._config,overlayConfig={backdropClass:_config.backdropClass,panelClass:_config.panelClass,hasBackdrop:_config.hasBackdrop,positionStrategy:this._overlay.position().global().centerHorizontally().centerVertically(),scrollStrategy:this._overlay.scrollStrategies.block(),disposeOnNavigation:!0},galleryRef=this._gallery.ref(id);galleryRef.set(i),this._overlayRef=this._overlay.create(overlayConfig),this._overlayRef.attachments().subscribe(()=>this.opened.next(id)),this._overlayRef.detachments().subscribe(()=>this.closed.next(id));const galleryPortal=new ComponentPortal(ng_gallery_lightbox_LightboxComponent),lightboxRef=this._overlayRef.attach(galleryPortal);lightboxRef.instance.id=id,lightboxRef.instance.overlayRef=this._overlayRef,lightboxRef.instance.closeIcon=this._config.closeIcon,lightboxRef.instance.role=this._config.role,lightboxRef.instance.ariaLabel=this._config.ariaLabel,lightboxRef.instance.ariaLabelledBy=this._config.ariaLabelledBy,lightboxRef.instance.ariaDescribedBy=this._config.ariaDescribedBy,lightboxRef.instance.startAnimationTime=this._config.startAnimationTime,lightboxRef.instance.exitAnimationTime=this._config.exitAnimationTime,_config.hasBackdrop&&this._overlayRef.backdropClick().subscribe(()=>this.close()),_config.keyboardShortcuts&&this._overlayRef.keydownEvents().subscribe(event=>{switch(event.keyCode){case 37:galleryRef.prev();break;case 39:galleryRef.next();break;case 27:this.close()}})}close(){this._overlayRef.hasAttached()&&this._overlayRef.detach()}}return Lightbox.ɵfac=function(t){return new(t||Lightbox)(core.Zb(LIGHTBOX_CONFIG,8),core.Zb(ng_gallery_Gallery),core.Zb(overlay_Overlay))},Lightbox.ɵprov=core.Lb({token:Lightbox,factory:Lightbox.ɵfac}),Lightbox})(),ng_gallery_lightbox_GallerizeDirective=(()=>{class GallerizeDirective{constructor(_zone,_el,_gallery,_lightbox,_renderer,platform,_document,_galleryCmp){this._zone=_zone,this._el=_el,this._gallery=_gallery,this._lightbox=_lightbox,this._renderer=_renderer,this._document=_document,this._galleryCmp=_galleryCmp,this._galleryId=\"lightbox\",this.selector=\"img\",Object(common.w)(platform)&&(this._mode=_galleryCmp?\"gallery\":\"detector\")}ngOnInit(){this._zone.runOutsideAngular(()=>{this._galleryId=this.gallerize||this._galleryId;const ref=this._gallery.ref(this._galleryId);switch(this._mode){case\"detector\":this.detectorMode(ref);break;case\"gallery\":this.galleryMode(ref)}})}ngOnDestroy(){switch(this._mode){case\"detector\":this._detector$.complete(),this._observer$.disconnect();break;case\"gallery\":this._itemClick$.unsubscribe(),this._itemChange$.unsubscribe()}}galleryMode(galleryRef){this._itemClick$=this._galleryCmp.galleryRef.itemClick.subscribe(i=>this._lightbox.open(i,this._galleryId)),this._itemChange$=this._galleryCmp.galleryRef.itemsChanged.subscribe(state=>galleryRef.load(state.items))}detectorMode(galleryRef){this._detector$=new Subject.a,this._detector$.pipe(debounceTime(300),Object(switchMap.a)(()=>{const imageElements=this._el.nativeElement.querySelectorAll(this.selector);if(imageElements&&imageElements.length){const images=[];return Object(observable_from.a)(imageElements).pipe(Object(map.a)((el,i)=>{if(this._renderer.setStyle(el,\"cursor\",\"pointer\"),this._renderer.setProperty(el,\"onclick\",()=>this._zone.run(()=>this._lightbox.open(i,this._galleryId))),el instanceof HTMLImageElement)return{src:el.getAttribute(\"imageSrc\")||el.src,thumb:el.getAttribute(\"thumbSrc\")||el.src};{const background=(el.currentStyle||this._document.defaultView.getComputedStyle(el,null)).backgroundImage.slice(4,-1).replace(/\"/g,\"\");return{src:el.getAttribute(\"imageSrc\")||background,thumb:el.getAttribute(\"thumbSrc\")||background}}}),Object(tap.a)(data=>images.push(new ImageItem(data))),Object(finalize.a)(()=>galleryRef.load(images)))}return empty.a})).subscribe(),this._observer$=new MutationObserver(()=>this._detector$.next()),this._observer$.observe(this._el.nativeElement,{childList:!0,subtree:!0})}}return GallerizeDirective.ɵfac=function(t){return new(t||GallerizeDirective)(core.Pb(core.B),core.Pb(core.m),core.Pb(ng_gallery_Gallery),core.Pb(ng_gallery_lightbox_Lightbox),core.Pb(core.G),core.Pb(core.D),core.Pb(common.e),core.Pb(ng_gallery_GalleryComponent,11))},GallerizeDirective.ɵdir=core.Kb({type:GallerizeDirective,selectors:[[\"\",\"gallerize\",\"\"]],inputs:{selector:\"selector\",gallerize:\"gallerize\"}}),GallerizeDirective})(),ng_gallery_lightbox_LightboxModule=(()=>{class LightboxModule{static withConfig(config){return{ngModule:LightboxModule,providers:[{provide:LIGHTBOX_CONFIG,useValue:config}]}}}return LightboxModule.ɵmod=core.Nb({type:LightboxModule}),LightboxModule.ɵinj=core.Mb({factory:function(t){return new(t||LightboxModule)},providers:[ng_gallery_lightbox_Lightbox],imports:[[overlay_OverlayModule,ng_gallery_GalleryModule,a11y_A11yModule]]}),LightboxModule})();var ngx=__webpack_require__(\"/XPu\"),empty_view=__webpack_require__(\"4ro/\"),ngx_skeleton_loader=__webpack_require__(\"xJkR\"),ng_lazyload_image=__webpack_require__(\"wf0l\");const place_detail_c0=[\"itemGalleryTemplate\"];function PlaceDetailPage_empty_view_13_Template(rf,ctx){1&rf&&(core.Qb(0,\"empty-view\",24),core.gc(1,\"translate\")),2&rf&&core.lc(\"text\",core.hc(1,1,\"EMPTY_DATA\"))}function PlaceDetailPage_empty_view_14_Template(rf,ctx){1&rf&&(core.Qb(0,\"empty-view\",24),core.gc(1,\"translate\")),2&rf&&core.lc(\"text\",core.hc(1,1,\"ERROR_NETWORK\"))}function PlaceDetailPage_ng_template_15_Template(rf,ctx){if(1&rf&&(core.Tb(0),core.Vb(1,\"ion-slides\",25),core.Vb(2,\"ion-slide\"),core.Vb(3,\"div\",26),core.Qb(4,\"img\",27),core.Ub(),core.Ub(),core.Ub(),core.Sb()),2&rf){const data_r9=ctx.data,ctx_r4=core.fc();core.Db(1),core.lc(\"options\",ctx_r4.sliderGalleryOpts),core.Db(3),core.lc(\"src\",data_r9.src,core.zc)}}const place_detail_c1=function(){return{width:\"150px\",height:\"150px\",\"border-radius\":\"4px\"}};function PlaceDetailPage_section_25_ion_col_2_Template(rf,ctx){1&rf&&(core.Vb(0,\"ion-col\",38),core.Qb(1,\"ngx-skeleton-loader\",39),core.Ub()),2&rf&&(core.Db(1),core.lc(\"theme\",core.oc(1,place_detail_c1)))}const place_detail_c2=function(){return{width:\"80px\",height:\"80px\"}},place_detail_c3=function(){return{width:\"30%\",\"border-radius\":\"0\",height:\"15px\",\"margin-bottom\":\"10px\"}},place_detail_c4=function(){return{width:\"70%\",\"border-radius\":\"0\",height:\"15px\"}},_c5=function(){return{width:\"100px\",height:\"100px\"}};function PlaceDetailPage_section_25_Template(rf,ctx){if(1&rf&&(core.Vb(0,\"section\",28),core.Vb(1,\"ion-row\",29),core.Ec(2,PlaceDetailPage_section_25_ion_col_2_Template,2,2,\"ion-col\",30),core.Ub(),core.Vb(3,\"div\",31),core.Vb(4,\"div\",32),core.Vb(5,\"div\",33),core.Qb(6,\"ngx-skeleton-loader\",34),core.Ub(),core.Vb(7,\"div\",35),core.Vb(8,\"div\"),core.Qb(9,\"ngx-skeleton-loader\",36),core.Ub(),core.Vb(10,\"div\"),core.Qb(11,\"ngx-skeleton-loader\",36),core.Ub(),core.Ub(),core.Ub(),core.Ub(),core.Vb(12,\"ion-row\"),core.Vb(13,\"ion-col\",37),core.Vb(14,\"div\"),core.Qb(15,\"ngx-skeleton-loader\",34),core.Ub(),core.Ub(),core.Vb(16,\"ion-col\",37),core.Vb(17,\"div\"),core.Qb(18,\"ngx-skeleton-loader\",34),core.Ub(),core.Ub(),core.Vb(19,\"ion-col\",37),core.Vb(20,\"div\"),core.Qb(21,\"ngx-skeleton-loader\",34),core.Ub(),core.Ub(),core.Ub(),core.Ub()),2&rf){const ctx_r5=core.fc();core.Db(2),core.lc(\"ngForOf\",ctx_r5.skeletonImages),core.Db(4),core.lc(\"theme\",core.oc(7,place_detail_c2)),core.Db(3),core.lc(\"theme\",core.oc(8,place_detail_c3)),core.Db(2),core.lc(\"theme\",core.oc(9,place_detail_c4)),core.Db(4),core.lc(\"theme\",core.oc(10,_c5)),core.Db(3),core.lc(\"theme\",core.oc(11,_c5)),core.Db(3),core.lc(\"theme\",core.oc(12,_c5))}}function PlaceDetailPage_section_26_div_1_Template(rf,ctx){1&rf&&(core.Vb(0,\"div\",41),core.Vb(1,\"div\",32),core.Vb(2,\"div\",33),core.Qb(3,\"ngx-skeleton-loader\",34),core.Ub(),core.Vb(4,\"div\",35),core.Vb(5,\"div\"),core.Qb(6,\"ngx-skeleton-loader\",36),core.Ub(),core.Vb(7,\"div\"),core.Qb(8,\"ngx-skeleton-loader\",36),core.Ub(),core.Ub(),core.Ub(),core.Ub()),2&rf&&(core.Db(3),core.lc(\"theme\",core.oc(3,place_detail_c2)),core.Db(3),core.lc(\"theme\",core.oc(4,place_detail_c3)),core.Db(2),core.lc(\"theme\",core.oc(5,place_detail_c4)))}function PlaceDetailPage_section_26_Template(rf,ctx){if(1&rf&&(core.Vb(0,\"section\"),core.Ec(1,PlaceDetailPage_section_26_div_1_Template,9,6,\"div\",40),core.Ub()),2&rf){const ctx_r6=core.fc();core.Db(1),core.lc(\"ngForOf\",ctx_r6.skeletonReviews)}}function PlaceDetailPage_section_27_ion_slide_5_Template(rf,ctx){if(1&rf&&(core.Vb(0,\"ion-slide\"),core.Qb(1,\"div\",58),core.Ub()),2&rf){const image_r18=ctx.$implicit,ctx_r14=core.fc(2);core.Db(1),core.lc(\"lazyLoad\",image_r18.url())(\"customObservable\",ctx_r14.loadAndScroll),core.Eb(\"imageSrc\",image_r18.url())(\"thumbSrc\",image_r18.url())}}function PlaceDetailPage_section_27_ion_thumbnail_8_Template(rf,ctx){if(1&rf&&(core.Vb(0,\"ion-thumbnail\",59),core.Qb(1,\"img\",60),core.Ub()),2&rf){const ctx_r15=core.fc(2);core.Db(1),core.lc(\"alt\",ctx_r15.place.title)(\"lazyLoad\",null==ctx_r15.place||null==ctx_r15.place.imageThumb?null:ctx_r15.place.imageThumb.url())(\"customObservable\",ctx_r15.loadAndScroll)}}function PlaceDetailPage_section_27_bar_rating_21_Template(rf,ctx){if(1&rf&&core.Qb(0,\"bar-rating\",61),2&rf){const ctx_r16=core.fc(2);core.lc(\"rate\",ctx_r16.place.ratingAvg)(\"readOnly\",!0)(\"max\",5)(\"theme\",\"stars\")}}function PlaceDetailPage_section_27_div_26_Template(rf,ctx){if(1&rf){const _r20=core.Wb();core.Vb(0,\"div\",62),core.dc(\"click\",function($event){return core.vc(_r20),core.fc(2).onContentTouched($event)}),core.Ub()}if(2&rf){const ctx_r17=core.fc(2);core.lc(\"innerHTML\",ctx_r17.description,core.wc)}}function PlaceDetailPage_section_27_Template(rf,ctx){if(1&rf){const _r22=core.Wb();core.Vb(0,\"section\"),core.Vb(1,\"ion-row\"),core.Vb(2,\"ion-col\",42),core.Vb(3,\"div\",43),core.Vb(4,\"ion-slides\",44),core.dc(\"ionSlidesDidLoad\",function(){return core.vc(_r22),core.fc().onSlidesDidLoad()})(\"ionSlideDrag\",function(){return core.vc(_r22),core.fc().onSlidesDrag()}),core.Ec(5,PlaceDetailPage_section_27_ion_slide_5_Template,2,4,\"ion-slide\",45),core.Ub(),core.Vb(6,\"div\",46),core.Vb(7,\"ion-item\",47),core.Ec(8,PlaceDetailPage_section_27_ion_thumbnail_8_Template,2,3,\"ion-thumbnail\",48),core.Vb(9,\"ion-label\",49),core.Vb(10,\"ion-text\",50),core.Vb(11,\"h2\",51),core.Gc(12),core.Ub(),core.Ub(),core.Vb(13,\"div\",49),core.Vb(14,\"ion-text\",52),core.Vb(15,\"p\"),core.Vb(16,\"span\",53),core.Gc(17),core.Ub(),core.Vb(18,\"span\",54),core.Gc(19),core.Ub(),core.Ub(),core.Ub(),core.Ub(),core.Vb(20,\"div\"),core.Ec(21,PlaceDetailPage_section_27_bar_rating_21_Template,1,4,\"bar-rating\",55),core.Ub(),core.Ub(),core.Ub(),core.Vb(22,\"div\",56),core.Vb(23,\"ion-text\",52),core.Vb(24,\"p\",54),core.Gc(25),core.Ub(),core.Ub(),core.Ub(),core.Ub(),core.Ub(),core.Ub(),core.Ub(),core.Ec(26,PlaceDetailPage_section_27_div_26_Template,1,1,\"div\",57),core.Ub()}if(2&rf){const ctx_r7=core.fc();core.Db(4),core.lc(\"options\",ctx_r7.slidesConfig),core.Db(1),core.lc(\"ngForOf\",ctx_r7.images),core.Db(3),core.lc(\"ngIf\",null==ctx_r7.place?null:ctx_r7.place.imageThumb),core.Db(4),core.Ic(\" \",null==ctx_r7.place?null:ctx_r7.place.title,\" \"),core.Db(5),core.Ic(\" \",ctx_r7.place.categories.join(\" • \"),\" \"),core.Db(1),core.Hb(\"hidden\",!ctx_r7.location&&!ctx_r7.preference.unit),core.Db(1),core.Ic(\" - \",null==ctx_r7.place?null:ctx_r7.place.distance(ctx_r7.location,ctx_r7.preference.unit),\" \"),core.Db(2),core.lc(\"ngIf\",ctx_r7.place.ratingAvg),core.Db(4),core.Hc(null==ctx_r7.place?null:ctx_r7.place.description),core.Db(1),core.lc(\"ngIf\",ctx_r7.description)}}function PlaceDetailPage_section_28_ion_col_2_div_12_Template(rf,ctx){1&rf&&(core.Vb(0,\"div\",84),core.Vb(1,\"div\",85),core.Vb(2,\"ion-text\",52),core.Vb(3,\"p\",86),core.Gc(4),core.gc(5,\"translate\"),core.Ub(),core.Ub(),core.Ub(),core.Ub()),2&rf&&(core.Db(4),core.Ic(\" \",core.hc(5,1,\"EMPTY_REVIEWS\"),\" \"))}function PlaceDetailPage_section_28_ion_col_2_div_14_Template(rf,ctx){if(1&rf&&(core.Vb(0,\"div\",87),core.Vb(1,\"ion-item\",88),core.Vb(2,\"ion-avatar\",2),core.Qb(3,\"img\",89),core.Ub(),core.Vb(4,\"ion-label\",90),core.Vb(5,\"ion-text\",91),core.Vb(6,\"span\",92),core.Gc(7),core.gc(8,\"date\"),core.Ub(),core.Ub(),core.Vb(9,\"ion-text\",50),core.Vb(10,\"h3\",93),core.Gc(11),core.Ub(),core.Ub(),core.Qb(12,\"bar-rating\",61),core.Vb(13,\"ion-text\",50),core.Vb(14,\"p\",94),core.Gc(15),core.Ub(),core.Ub(),core.Ub(),core.Ub(),core.Ub()),2&rf){const review_r34=ctx.$implicit,ctx_r32=core.fc(3);core.Db(3),core.lc(\"alt\",null==review_r34.user?null:review_r34.user.name)(\"lazyLoad\",null==review_r34.user||null==review_r34.user.photo?null:review_r34.user.photo.url())(\"customObservable\",ctx_r32.loadAndScroll),core.Db(4),core.Ic(\" \",core.ic(8,10,review_r34.createdAt,\"mediumDate\"),\" \"),core.Db(4),core.Hc(null==review_r34.user?null:review_r34.user.name),core.Db(1),core.lc(\"rate\",review_r34.rating)(\"readOnly\",!0)(\"max\",5)(\"theme\",\"stars\"),core.Db(3),core.Hc(review_r34.comment)}}const _c6=function(){return[\"./reviews\"]};function PlaceDetailPage_section_28_ion_col_2_div_15_Template(rf,ctx){1&rf&&(core.Vb(0,\"div\",70),core.Vb(1,\"ion-button\",95),core.Gc(2),core.gc(3,\"translate\"),core.Qb(4,\"ion-icon\",96),core.Ub(),core.Ub()),2&rf&&(core.Db(1),core.lc(\"routerLink\",core.oc(4,_c6)),core.Db(1),core.Ic(\" \",core.hc(3,2,\"VIEW_ALL_REVIEWS\"),\" \"))}function PlaceDetailPage_section_28_ion_col_2_Template(rf,ctx){if(1&rf){const _r36=core.Wb();core.Vb(0,\"ion-col\",73),core.Vb(1,\"div\",28),core.Vb(2,\"ion-row\",74),core.Vb(3,\"ion-col\",75),core.Vb(4,\"h5\",76),core.Qb(5,\"ion-icon\",77),core.Gc(6),core.gc(7,\"translate\"),core.Ub(),core.Ub(),core.Vb(8,\"ion-col\",78),core.Vb(9,\"ion-button\",79),core.dc(\"click\",function(){return core.vc(_r36),core.fc(2).onRate()}),core.Gc(10),core.gc(11,\"translate\"),core.Ub(),core.Ub(),core.Ub(),core.Ec(12,PlaceDetailPage_section_28_ion_col_2_div_12_Template,6,3,\"div\",80),core.Vb(13,\"ion-list\",81),core.Ec(14,PlaceDetailPage_section_28_ion_col_2_div_14_Template,16,13,\"div\",82),core.Ub(),core.Ec(15,PlaceDetailPage_section_28_ion_col_2_div_15_Template,5,5,\"div\",83),core.Ub(),core.Ub()}if(2&rf){const ctx_r24=core.fc(2);core.Db(6),core.Ic(\" \",core.hc(7,5,\"REVIEWS\"),\" \"),core.Db(4),core.Ic(\" \",core.hc(11,7,\"POST_REVIEW\"),\" \"),core.Db(2),core.lc(\"ngIf\",!ctx_r24.reviews.length),core.Db(2),core.lc(\"ngForOf\",ctx_r24.reviews),core.Db(1),core.lc(\"ngIf\",ctx_r24.reviews.length)}}function PlaceDetailPage_section_28_ion_item_7_Template(rf,ctx){if(1&rf){const _r38=core.Wb();core.Vb(0,\"ion-item\",88),core.Qb(1,\"ion-icon\",97),core.Vb(2,\"ion-label\",90),core.Vb(3,\"span\",86),core.Gc(4),core.Ub(),core.Vb(5,\"ion-label\",98),core.Vb(6,\"span\",99),core.dc(\"click\",function(){return core.vc(_r38),core.fc(2).onDirectionsButtonTouched()}),core.Gc(7),core.gc(8,\"translate\"),core.Ub(),core.Ub(),core.Ub(),core.Ub()}if(2&rf){const ctx_r25=core.fc(2);core.Db(4),core.Hc(null==ctx_r25.place?null:ctx_r25.place.address),core.Db(3),core.Ic(\" \",core.hc(8,2,\"GET_DIRECTIONS\"),\" \")}}function PlaceDetailPage_section_28_ion_item_8_Template(rf,ctx){if(1&rf){const _r40=core.Wb();core.Vb(0,\"ion-item\",100),core.dc(\"click\",function(){core.vc(_r40);const ctx_r39=core.fc(2);return ctx_r39.openUrl(ctx_r39.place.website)}),core.Qb(1,\"ion-icon\",101),core.Vb(2,\"ion-label\"),core.Vb(3,\"ion-text\",98),core.Vb(4,\"span\",102),core.Gc(5),core.Ub(),core.Ub(),core.Ub(),core.Ub()}if(2&rf){const ctx_r26=core.fc(2);core.Db(5),core.Hc(null==ctx_r26.place?null:ctx_r26.place.website)}}function PlaceDetailPage_section_28_ion_item_9_Template(rf,ctx){if(1&rf){const _r42=core.Wb();core.Vb(0,\"ion-item\",100),core.dc(\"click\",function(){return core.vc(_r42),core.fc(2).onCall()}),core.Qb(1,\"ion-icon\",103),core.Vb(2,\"ion-label\"),core.Vb(3,\"ion-text\",98),core.Vb(4,\"span\",102),core.Gc(5),core.Ub(),core.Ub(),core.Ub(),core.Ub()}if(2&rf){const ctx_r27=core.fc(2);core.Db(5),core.Hc(null==ctx_r27.place?null:ctx_r27.place.phone)}}function PlaceDetailPage_section_28_ion_item_10_Template(rf,ctx){if(1&rf){const _r44=core.Wb();core.Vb(0,\"ion-item\",100),core.dc(\"click\",function(){core.vc(_r44);const ctx_r43=core.fc(2);return ctx_r43.openUrl(ctx_r43.place.facebook)}),core.Qb(1,\"ion-icon\",104),core.Vb(2,\"ion-label\"),core.Vb(3,\"ion-text\",98),core.Vb(4,\"span\",102),core.Gc(5),core.Ub(),core.Ub(),core.Ub(),core.Ub()}if(2&rf){const ctx_r28=core.fc(2);core.Db(5),core.Hc(null==ctx_r28.place?null:ctx_r28.place.facebook)}}function PlaceDetailPage_section_28_ion_item_11_Template(rf,ctx){if(1&rf){const _r46=core.Wb();core.Vb(0,\"ion-item\",100),core.dc(\"click\",function(){core.vc(_r46);const ctx_r45=core.fc(2);return ctx_r45.openUrl(ctx_r45.place.instagram)}),core.Qb(1,\"ion-icon\",105),core.Vb(2,\"ion-label\"),core.Vb(3,\"ion-text\",98),core.Vb(4,\"span\",102),core.Gc(5),core.Ub(),core.Ub(),core.Ub(),core.Ub()}if(2&rf){const ctx_r29=core.fc(2);core.Db(5),core.Hc(null==ctx_r29.place?null:ctx_r29.place.instagram)}}function PlaceDetailPage_section_28_ion_item_12_Template(rf,ctx){if(1&rf){const _r48=core.Wb();core.Vb(0,\"ion-item\",100),core.dc(\"click\",function(){core.vc(_r48);const ctx_r47=core.fc(2);return ctx_r47.openUrl(ctx_r47.place.youtube)}),core.Qb(1,\"ion-icon\",106),core.Vb(2,\"ion-label\"),core.Vb(3,\"ion-text\",98),core.Vb(4,\"span\",102),core.Gc(5),core.Ub(),core.Ub(),core.Ub(),core.Ub()}if(2&rf){const ctx_r30=core.fc(2);core.Db(5),core.Hc(null==ctx_r30.place?null:ctx_r30.place.youtube)}}function PlaceDetailPage_section_28_Template(rf,ctx){if(1&rf){const _r50=core.Wb();core.Vb(0,\"section\",63),core.Vb(1,\"ion-row\"),core.Ec(2,PlaceDetailPage_section_28_ion_col_2_Template,16,9,\"ion-col\",64),core.Vb(3,\"ion-col\",65),core.Vb(4,\"div\",28),core.Qb(5,\"img\",66),core.Vb(6,\"ion-list\",67),core.Ec(7,PlaceDetailPage_section_28_ion_item_7_Template,9,4,\"ion-item\",68),core.Ec(8,PlaceDetailPage_section_28_ion_item_8_Template,6,1,\"ion-item\",69),core.Ec(9,PlaceDetailPage_section_28_ion_item_9_Template,6,1,\"ion-item\",69),core.Ec(10,PlaceDetailPage_section_28_ion_item_10_Template,6,1,\"ion-item\",69),core.Ec(11,PlaceDetailPage_section_28_ion_item_11_Template,6,1,\"ion-item\",69),core.Ec(12,PlaceDetailPage_section_28_ion_item_12_Template,6,1,\"ion-item\",69),core.Ub(),core.Vb(13,\"div\",70),core.Vb(14,\"ion-button\",71),core.dc(\"click\",function(){return core.vc(_r50),core.fc().onReportButtonTouched()}),core.Vb(15,\"span\",72),core.Gc(16),core.gc(17,\"translate\"),core.Ub(),core.Ub(),core.Ub(),core.Ub(),core.Ub(),core.Ub(),core.Ub()}if(2&rf){const ctx_r8=core.fc();core.Db(2),core.lc(\"ngIf\",ctx_r8.isReviewsEnabled),core.Db(3),core.nc(\"src\",\"https://maps.googleapis.com/maps/api/staticmap?key=\",ctx_r8.apiKey,\"&markers=color:0xff7676%7C\",null==ctx_r8.place?null:ctx_r8.place.location.latitude,\",\",null==ctx_r8.place?null:ctx_r8.place.location.longitude,\"&zoom=17&format=png&size=600x300&zoom=17\",core.zc),core.Db(2),core.lc(\"ngIf\",null==ctx_r8.place?null:ctx_r8.place.address),core.Db(1),core.lc(\"ngIf\",null==ctx_r8.place?null:ctx_r8.place.website),core.Db(1),core.lc(\"ngIf\",null==ctx_r8.place?null:ctx_r8.place.phone),core.Db(1),core.lc(\"ngIf\",null==ctx_r8.place?null:ctx_r8.place.facebook),core.Db(1),core.lc(\"ngIf\",null==ctx_r8.place?null:ctx_r8.place.instagram),core.Db(1),core.lc(\"ngIf\",null==ctx_r8.place?null:ctx_r8.place.youtube),core.Db(4),core.Ic(\" \",core.hc(17,11,\"REPORT_LISTING\"),\" \")}}let place_detail_PlaceDetailPage=(()=>{class PlaceDetailPage extends base_page.a{constructor(injector,placeService,sanitizer,geolocationService,reviewService,gallery,localStorage,appConfigService,lightboxService,zone,socialSharing){super(injector),this.placeService=placeService,this.sanitizer=sanitizer,this.geolocationService=geolocationService,this.reviewService=reviewService,this.gallery=gallery,this.localStorage=localStorage,this.appConfigService=appConfigService,this.lightboxService=lightboxService,this.zone=zone,this.socialSharing=socialSharing,this.apiKey=environment.a.googleMapsApiKey,this.images=[],this.rating=0,this.isLiked=!1,this.isStarred=!1,this.reviews=[],this.slidesConfig={},this.webSocialShare={show:!1,share:{config:[{facebook:{socialShareUrl:\"\"}},{twitter:{socialShareUrl:\"\"}},{whatsapp:{socialShareText:\"\",socialShareUrl:\"\"}},{copy:{socialShareUrl:\"\"}}]},onClosed:()=>{this.webSocialShare.show=!1}},this.sliderGalleryOpts={allowSlidePrev:!1,allowSlideNext:!1,zoom:{maxRatio:3}},this.isReviewsEnabled=!0,this.skeletonImages=Array(6),this.skeletonReviews=Array(5)}ngOnDestroy(){this.lightboxSubscriptionOpen.unsubscribe(),this.lightboxSubscriptionClosed.unsubscribe(),document.removeEventListener(\"ionBackButton\",this.backButtonListener)}ngOnInit(){this.setupObservable(),this.setupGallery(),this.setupDistanceUnit()}ionViewDidEnter(){return Object(tslib_es6.a)(this,void 0,void 0,function*(){this.place?(this.setPageTitle(this.place.title),this.setMetaTags({title:this.place.title,description:this.place.description,image:this.place.image?this.place.image.url():\"\",slug:this.place.getSlug()})):(this.setupSlider(),yield this.showLoadingView({showOverlay:!1}),this.loadPlace(),this.loadLocation())})}enableMenuSwipe(){return!1}onSlidesDidLoad(){this.contentLoaded.next()}onSlidesDrag(){this.contentLoaded.next()}setupDistanceUnit(){return Object(tslib_es6.a)(this,void 0,void 0,function*(){let unit=null;try{unit=yield this.localStorage.getUnit(),null===unit&&(unit=environment.a.defaultUnit)}catch(error){unit=environment.a.defaultUnit}this.preference.unit=unit})}setupObservable(){this.contentLoaded=new Subject.a,this.loadAndScroll=Object(merge.a)(this.container.ionScroll,this.contentLoaded)}setupGallery(){const config={gestures:!1,imageSize:ImageSize.Cover,thumbPosition:ThumbnailsPosition.Bottom,itemTemplate:this.itemGalleryTemplate};this.gallery.ref(\"placeGallery\").setConfig(config),this.backButtonListener=ev=>{ev.detail.register(10,()=>{this.zone.run(()=>{this.isLightboxOpen?this.lightboxService.close():this.goBack()})})},document.addEventListener(\"ionBackButton\",this.backButtonListener),this.lightboxSubscriptionOpen=this.lightboxService.opened.subscribe(()=>{this.isLightboxOpen=!0}),this.lightboxSubscriptionClosed=this.lightboxService.closed.subscribe(()=>{this.isLightboxOpen=!1})}onContentLoaded(){setTimeout(()=>{this.contentLoaded.next()},400)}loadPlace(){return Object(tslib_es6.a)(this,void 0,void 0,function*(){try{const appConfig=yield this.appConfigService.load();appConfig&&appConfig.reviews&&(this.isReviewsEnabled=!appConfig.reviews.disabled),this.place=yield this.placeService.loadOne(this.getParams().id),this.place.longDescription&&(this.description=this.sanitizer.bypassSecurityTrustHtml(this.place.longDescription)),this.setPageTitle(this.place.title),this.setMetaTags({title:this.place.title,description:this.place.description,image:this.place.image?this.place.image.url():\"\",slug:this.place.getSlug()}),this.webSocialShare.share.config.forEach(item=>{item.whatsapp?item.whatsapp.socialShareUrl=this.getShareUrl(this.place.getSlug()):item.facebook?item.facebook.socialShareUrl=this.getShareUrl(this.place.getSlug()):item.twitter?item.twitter.socialShareUrl=this.getShareUrl(this.place.getSlug()):item.copy&&(item.copy.socialShareUrl=this.getShareUrl(this.place.getSlug()))}),this.rating=this.place.rating,user_service.a.getCurrent()&&(this.checkIfIsLiked(),this.checkIfIsStarred()),this.loadReviews(),this.place.image&&this.images.push(this.place.image),this.place.imageTwo&&this.images.push(this.place.imageTwo),this.place.imageThree&&this.images.push(this.place.imageThree),this.place.imageFour&&this.images.push(this.place.imageFour),Array.isArray(this.place.images)&&this.place.images.length&&this.images.push(...this.place.images),this.showContentView(),this.onContentLoaded(),this.onRefreshComplete(this.place)}catch(err){101===err.code?this.showEmptyView():this.showErrorView(),this.onRefreshComplete()}})}setupSlider(){this.slidesConfig={grabCursor:!0,slidesPerView:2.5,slidesOffsetBefore:16,breakpointsInverse:!0,zoom:!1,touchStartPreventDefault:!1,breakpoints:{320:{slidesPerView:2.4,spaceBetween:6},400:{slidesPerView:2.5,spaceBetween:5},600:{slidesPerView:3.5,spaceBetween:10},800:{slidesPerView:4.5,spaceBetween:10}}}}checkIfIsLiked(){return Object(tslib_es6.a)(this,void 0,void 0,function*(){try{const isLiked=yield this.placeService.isLiked(this.place);this.isLiked=isLiked}catch(err){console.warn(err.message)}})}checkIfIsStarred(){return Object(tslib_es6.a)(this,void 0,void 0,function*(){try{const isStarred=yield this.placeService.isStarred(this.place);this.isStarred=isStarred}catch(err){console.warn(err.message)}})}loadLocation(){return Object(tslib_es6.a)(this,void 0,void 0,function*(){try{const coords=yield this.geolocationService.getCurrentPosition();this.location=coords}catch(err){console.warn(err)}})}loadReviews(){return Object(tslib_es6.a)(this,void 0,void 0,function*(){try{this.reviews=yield this.reviewService.load({place:this.place,limit:5})}catch(err){console.warn(err.message)}})}openSignInModal(){return Object(tslib_es6.a)(this,void 0,void 0,function*(){yield this.showLoadingView({showOverlay:!0});const modal=yield this.modalCtrl.create({component:sign_in.a});yield modal.present(),yield this.dismissLoadingView()})}openAddReviewModal(){return Object(tslib_es6.a)(this,void 0,void 0,function*(){yield this.showLoadingView({showOverlay:!0});const modal=yield this.modalCtrl.create({component:review_add_ReviewAddPage,componentProps:{place:this.place}});yield modal.present(),yield this.dismissLoadingView();const{data:data}=yield modal.onWillDismiss();data&&this.reviews.unshift(data)})}openShareModal(){return Object(tslib_es6.a)(this,void 0,void 0,function*(){yield this.showLoadingView({showOverlay:!0});const modal=yield this.modalCtrl.create({component:share_page.a});yield modal.present(),yield this.dismissLoadingView()})}onLike(){user_service.a.getCurrent()?(this.isLiked=!this.isLiked,this.placeService.like(this.place)):this.openSignInModal()}onRate(){user_service.a.getCurrent()?this.openAddReviewModal():this.openSignInModal()}onContentTouched(ev={}){const href=ev.target.getAttribute(\"href\");href&&(ev.preventDefault(),this.openUrl(href))}onShare(){return Object(tslib_es6.a)(this,void 0,void 0,function*(){if(this.isCordova)try{const url=this.getShareUrl(this.place.getSlug());yield this.socialSharing.share(null,null,null,url)}catch(err){console.warn(err)}else this.isPwa||this.isMobile?this.webSocialShare.show=!0:this.openShareModal()})}onCall(){return Object(tslib_es6.a)(this,void 0,void 0,function*(){this.openSimpleUrl(\"tel:\"+this.place.phone)})}onDirectionsButtonTouched(){return Object(tslib_es6.a)(this,void 0,void 0,function*(){this.openSimpleUrl(`https://maps.google.com/maps?q=${this.place.location.latitude},${this.place.location.longitude}`)})}onReportButtonTouched(){return Object(tslib_es6.a)(this,void 0,void 0,function*(){if(!user_service.a.getCurrent())return this.openSignInModal();const str=yield this.getTrans([\"REPORT_LISTING\",\"REPORT_REASON\",\"CONFIRM\",\"DISMISS\"]),{value:text}=yield this.showSweetTextArea(str.REPORT_PROFILE,str.REPORT_REASON,str.CONFIRM,str.DISMISS);if(text)try{const report=new report_service_Report;report.place=this.place,report.reason=text,yield report.save(),this.translate.get(\"SENT\").subscribe(str=>this.showToast(str))}catch(error){this.translate.get(\"ERROR_NETWORK\").subscribe(str=>this.showToast(str))}})}}return PlaceDetailPage.ɵfac=function(t){return new(t||PlaceDetailPage)(core.Pb(core.t),core.Pb(place_service.a),core.Pb(platform_browser.b),core.Pb(geolocation_service.a),core.Pb(review_service.a),core.Pb(ng_gallery_Gallery),core.Pb(local_storage.a),core.Pb(app_config_service.a),core.Pb(ng_gallery_lightbox_Lightbox),core.Pb(core.B),core.Pb(ngx.a))},PlaceDetailPage.ɵcmp=core.Jb({type:PlaceDetailPage,selectors:[[\"place-detail-page\"]],viewQuery:function(rf,ctx){if(1&rf&&(core.Kc(ionic_angular.r,3),core.Kc(place_detail_c0,3)),2&rf){let _t;core.tc(_t=core.ec())&&(ctx.container=_t.first),core.tc(_t=core.ec())&&(ctx.itemGalleryTemplate=_t.first)}},features:[core.Ab],decls:29,vars:12,consts:[[1,\"ion-no-border\"],[\"color\",\"primary\",\"fixed\",\"\"],[\"slot\",\"start\"],[\"defaultHref\",\"/\"],[\"slot\",\"end\"],[3,\"disabled\",\"click\"],[\"slot\",\"icon-only\",3,\"name\"],[1,\"btn-share\",3,\"disabled\",\"click\"],[\"slot\",\"icon-only\",\"name\",\"share-social-outline\"],[\"scrollEvents\",\"true\"],[\"container\",\"\"],[\"icon\",\"alert-circle-outline\",3,\"text\",4,\"ngIf\"],[\"itemGalleryTemplate\",\"\"],[3,\"show\",\"share\",\"closed\"],[\"name\",\"logo-facebook\",\"slot\",\"facebook\",1,\"block\",2,\"color\",\"var(--ion-color-fb)\",\"width\",\"36px\",\"height\",\"36px\"],[\"name\",\"logo-twitter\",\"slot\",\"twitter\",1,\"block\",2,\"color\",\"var(--ion-color-twitter)\",\"width\",\"36px\",\"height\",\"36px\"],[\"name\",\"logo-whatsapp\",\"slot\",\"whatsapp\",1,\"block\",2,\"color\",\"var(--ion-color-whatsapp)\",\"width\",\"36px\",\"height\",\"36px\"],[\"name\",\"copy-outline\",\"slot\",\"copy\",1,\"block\",2,\"color\",\"var(--ion-color-medium)\",\"width\",\"36px\",\"height\",\"36px\"],[\"fixed\",\"\"],[1,\"ion-justify-content-center\"],[\"size-xs\",\"12\",\"size-lg\",\"10\"],[\"class\",\"light-bg radius ion-padding\",4,\"ngIf\"],[4,\"ngIf\"],[\"class\",\"ion-margin-top\",4,\"ngIf\"],[\"icon\",\"alert-circle-outline\",3,\"text\"],[2,\"width\",\"100%\",\"height\",\"100%\",3,\"options\"],[1,\"swiper-zoom-container\"],[2,\"width\",\"100%\",\"height\",\"100%\",\"object-fit\",\"contain\",3,\"src\"],[1,\"light-bg\",\"radius\",\"ion-padding\"],[1,\"ion-nowrap\"],[\"size-xs\",\"6\",\"size-sm\",\"6\",\"size-md\",\"6\",\"size-lg\",\"2\",4,\"ngFor\",\"ngForOf\"],[1,\"skeleton-item\"],[1,\"wrapper\"],[1,\"avatar\"],[\"appearance\",\"circle\",3,\"theme\"],[1,\"title\"],[3,\"theme\"],[\"size\",\"4\",1,\"ion-text-center\"],[\"size-xs\",\"6\",\"size-sm\",\"6\",\"size-md\",\"6\",\"size-lg\",\"2\"],[\"count\",\"1\",\"appearance\",\"circle\",3,\"theme\"],[\"class\",\"skeleton-item light-bg radius\",4,\"ngFor\",\"ngForOf\"],[1,\"skeleton-item\",\"light-bg\",\"radius\"],[\"size\",\"12\"],[1,\"light-bg\",\"radius\",\"ion-padding-vertical\",\"fade-in\"],[\"pager\",\"false\",\"gallerize\",\"placeGallery\",\"selector\",\".bg-img\",3,\"options\",\"ionSlidesDidLoad\",\"ionSlideDrag\"],[4,\"ngFor\",\"ngForOf\"],[1,\"ion-padding\"],[\"lines\",\"none\",\"color\",\"light\",1,\"ion-margin-vertical\"],[\"class\",\"img-featured\",\"slot\",\"start\",4,\"ngIf\"],[1,\"ion-text-nowrap\"],[\"color\",\"dark\"],[1,\"bold\",\"ellipsis\"],[\"color\",\"medium\"],[1,\"text-medium\",\"bold\",\"ion-margin-top\"],[1,\"text-medium\",\"bold\"],[\"class\",\"rating\",3,\"rate\",\"readOnly\",\"max\",\"theme\",4,\"ngIf\"],[1,\"ion-text-wrap\",\"ion-margin-top\"],[\"class\",\"html-content\",3,\"innerHTML\",\"click\",4,\"ngIf\"],[\"defaultImage\",\"./assets/img/placeholder.png\",1,\"bg-img\",\"radius\",3,\"lazyLoad\",\"customObservable\"],[\"slot\",\"start\",1,\"img-featured\"],[\"defaultImage\",\"./assets/img/placeholder.png\",3,\"alt\",\"lazyLoad\",\"customObservable\"],[1,\"rating\",3,\"rate\",\"readOnly\",\"max\",\"theme\"],[1,\"html-content\",3,\"innerHTML\",\"click\"],[1,\"ion-margin-top\"],[\"size-xs\",\"12\",\"size-lg\",\"7\",4,\"ngIf\"],[\"size-xs\",\"12\",\"size-lg\",\"5\"],[3,\"src\"],[\"color\",\"light\",1,\"ion-no-margin\"],[\"color\",\"light\",4,\"ngIf\"],[\"color\",\"light\",3,\"click\",4,\"ngIf\"],[1,\"ion-text-center\"],[\"strong\",\"\",\"fill\",\"clear\",\"color\",\"dark\",3,\"click\"],[1,\"ion-text-capitalize\"],[\"size-xs\",\"12\",\"size-lg\",\"7\"],[1,\"ion-align-items-center\"],[\"size-xs\",\"6\",\"size-md\",\"8\",\"size-lg\",\"8\"],[\"no-margin\",\"\"],[\"name\",\"chatbubbles\",1,\"text-medium\"],[\"size-xs\",\"6\",\"size-md\",\"4\",\"size-lg\",\"4\",\"text-end\",\"\"],[\"size\",\"small\",\"expand\",\"block\",\"shape\",\"round\",\"color\",\"secondary\",1,\"bold\",3,\"click\"],[\"style\",\"height:170px;\",\"class\",\"ion-text-center\",4,\"ngIf\"],[1,\"ion-no-margin\"],[\"class\",\"radius light-bg\",4,\"ngFor\",\"ngForOf\"],[\"class\",\"ion-text-center\",4,\"ngIf\"],[1,\"ion-text-center\",2,\"height\",\"170px\"],[1,\"flex-center\"],[1,\"text-medium\"],[1,\"radius\",\"light-bg\"],[\"color\",\"light\"],[\"defaultImage\",\"./assets/img/avatar.png\",3,\"alt\",\"lazyLoad\",\"customObservable\"],[1,\"ion-text-wrap\"],[\"color\",\"medium\",1,\"ion-float-end\"],[1,\"text-small\"],[1,\"bold\",\"no-margin\"],[1,\"text-medium\",\"no-margin\"],[\"fill\",\"clear\",\"color\",\"dark\",1,\"bold\",3,\"routerLink\"],[\"slot\",\"end\",\"name\",\"chevron-forward\"],[\"slot\",\"start\",\"name\",\"map\"],[\"color\",\"primary\"],[1,\"text-medium\",\"link\",3,\"click\"],[\"color\",\"light\",3,\"click\"],[\"slot\",\"start\",\"name\",\"globe\"],[1,\"text-medium\",\"link\"],[\"slot\",\"start\",\"name\",\"call\"],[\"slot\",\"start\",\"name\",\"logo-facebook\"],[\"slot\",\"start\",\"name\",\"logo-instagram\"],[\"slot\",\"start\",\"name\",\"logo-youtube\"]],template:function(rf,ctx){1&rf&&(core.Vb(0,\"ion-header\",0),core.Vb(1,\"ion-toolbar\",1),core.Vb(2,\"ion-buttons\",2),core.Qb(3,\"ion-back-button\",3),core.Ub(),core.Vb(4,\"ion-title\"),core.Gc(5),core.Ub(),core.Vb(6,\"ion-buttons\",4),core.Vb(7,\"ion-button\",5),core.dc(\"click\",function(){return ctx.onLike()}),core.Qb(8,\"ion-icon\",6),core.Ub(),core.Vb(9,\"ion-button\",7),core.dc(\"click\",function(){return ctx.onShare()}),core.Qb(10,\"ion-icon\",8),core.Ub(),core.Ub(),core.Ub(),core.Ub(),core.Vb(11,\"ion-content\",9,10),core.Ec(13,PlaceDetailPage_empty_view_13_Template,2,3,\"empty-view\",11),core.Ec(14,PlaceDetailPage_empty_view_14_Template,2,3,\"empty-view\",11),core.Ec(15,PlaceDetailPage_ng_template_15_Template,5,2,\"ng-template\",null,12,core.Fc),core.Vb(17,\"web-social-share\",13),core.dc(\"closed\",function(){return ctx.webSocialShare.onClosed()}),core.Qb(18,\"ion-icon\",14),core.Qb(19,\"ion-icon\",15),core.Qb(20,\"ion-icon\",16),core.Qb(21,\"ion-icon\",17),core.Ub(),core.Vb(22,\"ion-grid\",18),core.Vb(23,\"ion-row\",19),core.Vb(24,\"ion-col\",20),core.Ec(25,PlaceDetailPage_section_25_Template,22,13,\"section\",21),core.Ec(26,PlaceDetailPage_section_26_Template,2,1,\"section\",22),core.Ec(27,PlaceDetailPage_section_27_Template,27,11,\"section\",22),core.Ec(28,PlaceDetailPage_section_28_Template,18,13,\"section\",23),core.Ub(),core.Ub(),core.Ub(),core.Ub()),2&rf&&(core.Db(5),core.Hc(null==ctx.place?null:ctx.place.title),core.Db(2),core.lc(\"disabled\",!ctx.place),core.Db(1),core.lc(\"name\",ctx.isLiked?\"heart\":\"heart-outline\"),core.Db(1),core.lc(\"disabled\",!ctx.place),core.Db(4),core.lc(\"ngIf\",ctx.isEmptyViewVisible),core.Db(1),core.lc(\"ngIf\",ctx.isErrorViewVisible),core.Db(3),core.lc(\"show\",ctx.webSocialShare.show)(\"share\",ctx.webSocialShare.share),core.Db(8),core.lc(\"ngIf\",ctx.isLoadingViewVisible),core.Db(1),core.lc(\"ngIf\",ctx.isLoadingViewVisible),core.Db(1),core.lc(\"ngIf\",ctx.isContentViewVisible),core.Db(1),core.lc(\"ngIf\",ctx.isContentViewVisible))},directives:[ionic_angular.w,ionic_angular.db,ionic_angular.l,ionic_angular.h,ionic_angular.i,ionic_angular.bb,ionic_angular.k,ionic_angular.x,ionic_angular.r,common.m,ionic_angular.v,ionic_angular.O,ionic_angular.q,empty_view.a,ionic_angular.T,ionic_angular.S,common.l,ngx_skeleton_loader.a,ng_gallery_lightbox_GallerizeDirective,ionic_angular.B,ionic_angular.E,ionic_angular.Y,ng_lazyload_image.b,ionic_angular.ab,ngx_bar_rating.a,ionic_angular.F,ionic_angular.g,ionic_angular.lb,router.i],pipes:[ngx_translate_core.c,common.f],styles:[\"ion-grid[_ngcontent-%COMP%]{padding:0}ion-slides[_ngcontent-%COMP%]{height:auto}ion-slides[_ngcontent-%COMP%]   .bg-img[_ngcontent-%COMP%]{background-size:cover;background-position:50%;height:150px;width:150px}ion-slides[_ngcontent-%COMP%]   .swiper-pagination-bullet-active[_ngcontent-%COMP%]{background:var(--ion-color-light)}ion-avatar[_ngcontent-%COMP%]{margin:0 12px 0 0!important}ion-avatar[_ngcontent-%COMP%]   img[_ngcontent-%COMP%]{background:var(--ion-color-dark)}ion-thumbnail[_ngcontent-%COMP%]{--border-radius:6px;width:80px;height:80px}ion-list[_ngcontent-%COMP%]{background:var(--ion-color-light)}ion-item[_ngcontent-%COMP%]{--padding-start:0}ion-row[nowrap][_ngcontent-%COMP%]{overflow:hidden}.flex-start[_ngcontent-%COMP%]{display:flex;align-items:flex-start}.review-count[_ngcontent-%COMP%]{margin-left:6px}.icon-share[_ngcontent-%COMP%]{font-size:48px}.skeleton-item[_ngcontent-%COMP%]{width:auto;height:auto;margin:10px auto;padding:10px}.skeleton-item[_ngcontent-%COMP%]   .wrapper[_ngcontent-%COMP%]{display:inline-flex;width:100%;height:auto;flex:1}.skeleton-item[_ngcontent-%COMP%]   .wrapper[_ngcontent-%COMP%]   .avatar[_ngcontent-%COMP%]{width:100px;height:90px}.skeleton-item[_ngcontent-%COMP%]   .wrapper[_ngcontent-%COMP%]   .title[_ngcontent-%COMP%]{width:100%;padding:10px;height:80px}@media (min-width:992px){ion-thumbnail[_ngcontent-%COMP%]{width:100px;height:100px}}\"]}),PlaceDetailPage})();var shared_module=__webpack_require__(\"d2mR\");let review_add_module_ReviewAddPageModule=(()=>{class ReviewAddPageModule{}return ReviewAddPageModule.ɵmod=core.Nb({type:ReviewAddPageModule}),ReviewAddPageModule.ɵinj=core.Mb({factory:function(t){return new(t||ReviewAddPageModule)},imports:[[shared_module.a,fesm2015_forms.e]]}),ReviewAddPageModule})();var sign_in_module=__webpack_require__(\"b8Qw\"),share_module=__webpack_require__(\"Hr7V\");let place_detail_module_PlaceDetailPageModule=(()=>{class PlaceDetailPageModule{}return PlaceDetailPageModule.ɵmod=core.Nb({type:PlaceDetailPageModule}),PlaceDetailPageModule.ɵinj=core.Mb({factory:function(t){return new(t||PlaceDetailPageModule)},imports:[[shared_module.a,review_add_module_ReviewAddPageModule,sign_in_module.a,share_module.a,ng_gallery_GalleryModule,ng_gallery_lightbox_LightboxModule,router.j.forChild([{path:\"\",component:place_detail_PlaceDetailPage}])]]}),PlaceDetailPageModule})()}}]);","name":"3-es2015.2a2b11b9c7dd078a00f0.js","input":"(window[\"webpackJsonp\"] = window[\"webpackJsonp\"] || []).push([[3],{\n\n/***/ \"OB40\":\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n// ESM COMPAT FLAG\n__webpack_require__.r(__webpack_exports__);\n\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, \"PlaceDetailPageModule\", function() { return /* binding */ place_detail_module_PlaceDetailPageModule; });\n\n// EXTERNAL MODULE: ./node_modules/@angular/router/__ivy_ngcc__/fesm2015/router.js + 4 modules\nvar router = __webpack_require__(\"tyNb\");\n\n// EXTERNAL MODULE: ./node_modules/tslib/tslib.es6.js\nvar tslib_es6 = __webpack_require__(\"mrSG\");\n\n// EXTERNAL MODULE: ./node_modules/@ionic/angular/__ivy_ngcc__/fesm2015/ionic-angular.js + 5 modules\nvar ionic_angular = __webpack_require__(\"TEn/\");\n\n// EXTERNAL MODULE: ./src/app/pages/base-page/base-page.ts\nvar base_page = __webpack_require__(\"NV1z\");\n\n// EXTERNAL MODULE: ./node_modules/@angular/core/__ivy_ngcc__/fesm2015/core.js\nvar core = __webpack_require__(\"fXoL\");\n\n// EXTERNAL MODULE: ./src/app/services/review-service.ts\nvar review_service = __webpack_require__(\"nFsf\");\n\n// EXTERNAL MODULE: ./node_modules/ngx-bar-rating/__ivy_ngcc__/fesm2015/ngx-bar-rating.js\nvar ngx_bar_rating = __webpack_require__(\"Qsw1\");\n\n// EXTERNAL MODULE: ./node_modules/@angular/forms/__ivy_ngcc__/fesm2015/forms.js\nvar fesm2015_forms = __webpack_require__(\"3Pt+\");\n\n// EXTERNAL MODULE: ./node_modules/@angular/common/__ivy_ngcc__/fesm2015/common.js\nvar common = __webpack_require__(\"ofXK\");\n\n// EXTERNAL MODULE: ./node_modules/@ngx-translate/core/__ivy_ngcc__/fesm2015/ngx-translate-core.js\nvar ngx_translate_core = __webpack_require__(\"sYmb\");\n\n// CONCATENATED MODULE: ./src/app/pages/review-add/review-add.ts\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nfunction ReviewAddPage_ion_spinner_15_Template(rf, ctx) {\r\n    if (rf & 1) {\r\n        core[\"Qb\" /* ɵɵelement */](0, \"ion-spinner\");\r\n    }\r\n}\r\nfunction ReviewAddPage_span_16_Template(rf, ctx) {\r\n    if (rf & 1) {\r\n        core[\"Vb\" /* ɵɵelementStart */](0, \"span\");\r\n        core[\"Gc\" /* ɵɵtext */](1);\r\n        core[\"gc\" /* ɵɵpipe */](2, \"translate\");\r\n        core[\"Ub\" /* ɵɵelementEnd */]();\r\n    }\r\n    if (rf & 2) {\r\n        core[\"Db\" /* ɵɵadvance */](1);\r\n        core[\"Hc\" /* ɵɵtextInterpolate */](core[\"hc\" /* ɵɵpipeBind1 */](2, 1, \"SUBMIT\"));\r\n    }\r\n}\r\nlet review_add_ReviewAddPage = /*@__PURE__*/ (() => {\r\n    class ReviewAddPage extends base_page[\"a\" /* BasePage */] {\r\n        constructor(injector, reviewService) {\r\n            super(injector);\r\n            this.reviewService = reviewService;\r\n            this.review = {\r\n                rating: 3,\r\n                comment: ''\r\n            };\r\n        }\r\n        enableMenuSwipe() {\r\n            return false;\r\n        }\r\n        onSubmit() {\r\n            return Object(tslib_es6[\"a\" /* __awaiter */])(this, void 0, void 0, function* () {\r\n                if (!this.review.rating) {\r\n                    const message = yield this.getTrans('PLEASE_SELECT_A_RATING');\r\n                    this.showToast(message);\r\n                    return;\r\n                }\r\n                try {\r\n                    yield this.showLoadingView({ showOverlay: false });\r\n                    this.review.place = this.place;\r\n                    const review = yield this.reviewService.create(this.review);\r\n                    this.translate.get('REVIEW_ADDED')\r\n                        .subscribe(str => this.showToast(str));\r\n                    this.showContentView();\r\n                    if (review.status === 'Published') {\r\n                        this.onDismiss(review);\r\n                    }\r\n                    else {\r\n                        this.onDismiss();\r\n                    }\r\n                }\r\n                catch (err) {\r\n                    this.showContentView();\r\n                    if (err.code === 5000) {\r\n                        this.translate.get('REVIEW_ALREADY_EXISTS')\r\n                            .subscribe(str => this.showToast(str));\r\n                    }\r\n                    else if (err.code === 5003) {\r\n                        this.translate.get('REVIEWS_DISABLED')\r\n                            .subscribe(str => this.showToast(str));\r\n                    }\r\n                    else {\r\n                        this.translate.get('ERROR_NETWORK')\r\n                            .subscribe(str => this.showToast(str));\r\n                    }\r\n                }\r\n            });\r\n        }\r\n        onDismiss(review = null) {\r\n            this.modalCtrl.dismiss(review);\r\n        }\r\n    }\r\n    ReviewAddPage.ɵfac = function ReviewAddPage_Factory(t) { return new (t || ReviewAddPage)(core[\"Pb\" /* ɵɵdirectiveInject */](core[\"t\" /* Injector */]), core[\"Pb\" /* ɵɵdirectiveInject */](review_service[\"a\" /* Review */])); };\r\n    ReviewAddPage.ɵcmp = core[\"Jb\" /* ɵɵdefineComponent */]({ type: ReviewAddPage, selectors: [[\"page-review-add\"]], inputs: { place: \"place\" }, features: [core[\"Ab\" /* ɵɵInheritDefinitionFeature */]], decls: 17, vars: 14, consts: [[1, \"ion-no-border\"], [\"color\", \"primary\"], [\"slot\", \"end\"], [\"fill\", \"clear\", 3, \"click\"], [\"name\", \"close\"], [1, \"ion-padding\"], [1, \"ion-text-center\"], [1, \"rating\", 3, \"rate\", \"readOnly\", \"max\", \"theme\", \"rateChange\"], [\"lines\", \"none\", \"color\", \"light\", 1, \"radius\", \"ion-margin-vertical\"], [\"rows\", \"8\", 3, \"ngModel\", \"placeholder\", \"ngModelChange\", \"keyup.enter\"], [\"strong\", \"\", \"shape\", \"round\", \"color\", \"secondary\", 3, \"disabled\", \"click\"], [4, \"ngIf\"]], template: function ReviewAddPage_Template(rf, ctx) {\r\n            if (rf & 1) {\r\n                core[\"Vb\" /* ɵɵelementStart */](0, \"ion-header\", 0);\r\n                core[\"Vb\" /* ɵɵelementStart */](1, \"ion-toolbar\", 1);\r\n                core[\"Vb\" /* ɵɵelementStart */](2, \"ion-buttons\", 2);\r\n                core[\"Vb\" /* ɵɵelementStart */](3, \"ion-button\", 3);\r\n                core[\"dc\" /* ɵɵlistener */](\"click\", function ReviewAddPage_Template_ion_button_click_3_listener() { return ctx.onDismiss(); });\r\n                core[\"Qb\" /* ɵɵelement */](4, \"ion-icon\", 4);\r\n                core[\"Ub\" /* ɵɵelementEnd */]();\r\n                core[\"Ub\" /* ɵɵelementEnd */]();\r\n                core[\"Vb\" /* ɵɵelementStart */](5, \"ion-title\");\r\n                core[\"Gc\" /* ɵɵtext */](6);\r\n                core[\"gc\" /* ɵɵpipe */](7, \"translate\");\r\n                core[\"Ub\" /* ɵɵelementEnd */]();\r\n                core[\"Ub\" /* ɵɵelementEnd */]();\r\n                core[\"Ub\" /* ɵɵelementEnd */]();\r\n                core[\"Vb\" /* ɵɵelementStart */](8, \"ion-content\", 5);\r\n                core[\"Vb\" /* ɵɵelementStart */](9, \"div\", 6);\r\n                core[\"Vb\" /* ɵɵelementStart */](10, \"bar-rating\", 7);\r\n                core[\"dc\" /* ɵɵlistener */](\"rateChange\", function ReviewAddPage_Template_bar_rating_rateChange_10_listener($event) { return ctx.review.rating = $event; });\r\n                core[\"Ub\" /* ɵɵelementEnd */]();\r\n                core[\"Vb\" /* ɵɵelementStart */](11, \"ion-item\", 8);\r\n                core[\"Vb\" /* ɵɵelementStart */](12, \"ion-textarea\", 9);\r\n                core[\"dc\" /* ɵɵlistener */](\"ngModelChange\", function ReviewAddPage_Template_ion_textarea_ngModelChange_12_listener($event) { return ctx.review.comment = $event; })(\"keyup.enter\", function ReviewAddPage_Template_ion_textarea_keyup_enter_12_listener() { return ctx.onSubmit(); });\r\n                core[\"gc\" /* ɵɵpipe */](13, \"translate\");\r\n                core[\"Ub\" /* ɵɵelementEnd */]();\r\n                core[\"Ub\" /* ɵɵelementEnd */]();\r\n                core[\"Vb\" /* ɵɵelementStart */](14, \"ion-button\", 10);\r\n                core[\"dc\" /* ɵɵlistener */](\"click\", function ReviewAddPage_Template_ion_button_click_14_listener() { return ctx.onSubmit(); });\r\n                core[\"Ec\" /* ɵɵtemplate */](15, ReviewAddPage_ion_spinner_15_Template, 1, 0, \"ion-spinner\", 11);\r\n                core[\"Ec\" /* ɵɵtemplate */](16, ReviewAddPage_span_16_Template, 3, 3, \"span\", 11);\r\n                core[\"Ub\" /* ɵɵelementEnd */]();\r\n                core[\"Ub\" /* ɵɵelementEnd */]();\r\n                core[\"Ub\" /* ɵɵelementEnd */]();\r\n            }\r\n            if (rf & 2) {\r\n                core[\"Db\" /* ɵɵadvance */](6);\r\n                core[\"Ic\" /* ɵɵtextInterpolate1 */](\" \", core[\"hc\" /* ɵɵpipeBind1 */](7, 10, \"ADD_REVIEW\"), \" \");\r\n                core[\"Db\" /* ɵɵadvance */](4);\r\n                core[\"lc\" /* ɵɵproperty */](\"rate\", ctx.review.rating)(\"readOnly\", false)(\"max\", 5)(\"theme\", \"stars\");\r\n                core[\"Db\" /* ɵɵadvance */](2);\r\n                core[\"lc\" /* ɵɵproperty */](\"ngModel\", ctx.review.comment)(\"placeholder\", core[\"hc\" /* ɵɵpipeBind1 */](13, 12, \"COMMENT\"));\r\n                core[\"Db\" /* ɵɵadvance */](2);\r\n                core[\"lc\" /* ɵɵproperty */](\"disabled\", ctx.isLoadingViewVisible);\r\n                core[\"Db\" /* ɵɵadvance */](1);\r\n                core[\"lc\" /* ɵɵproperty */](\"ngIf\", ctx.isLoadingViewVisible);\r\n                core[\"Db\" /* ɵɵadvance */](1);\r\n                core[\"lc\" /* ɵɵproperty */](\"ngIf\", !ctx.isLoadingViewVisible);\r\n            }\r\n        }, directives: [ionic_angular[\"w\" /* IonHeader */], ionic_angular[\"db\" /* IonToolbar */], ionic_angular[\"l\" /* IonButtons */], ionic_angular[\"k\" /* IonButton */], ionic_angular[\"x\" /* IonIcon */], ionic_angular[\"bb\" /* IonTitle */], ionic_angular[\"r\" /* IonContent */], ngx_bar_rating[\"a\" /* BarRating */], ionic_angular[\"B\" /* IonItem */], ionic_angular[\"Z\" /* IonTextarea */], ionic_angular[\"nb\" /* TextValueAccessor */], fesm2015_forms[\"i\" /* NgControlStatus */], fesm2015_forms[\"k\" /* NgModel */], common[\"m\" /* NgIf */], ionic_angular[\"U\" /* IonSpinner */]], pipes: [ngx_translate_core[\"c\" /* TranslatePipe */]], styles: [\"ion-content[_ngcontent-%COMP%]{--padding-top:60px}ion-item[_ngcontent-%COMP%]{--border-radius:4px;margin-top:40px}\"] });\r\n    return ReviewAddPage;\r\n})();\r\n\n// EXTERNAL MODULE: ./src/app/services/user-service.ts\nvar user_service = __webpack_require__(\"dexi\");\n\n// EXTERNAL MODULE: ./src/app/pages/sign-in/sign-in.ts + 2 modules\nvar sign_in = __webpack_require__(\"GvuD\");\n\n// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/Subject.js\nvar Subject = __webpack_require__(\"XNiG\");\n\n// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/observable/merge.js\nvar merge = __webpack_require__(\"VRyK\");\n\n// EXTERNAL MODULE: ./src/environments/environment.ts\nvar environment = __webpack_require__(\"AytR\");\n\n// EXTERNAL MODULE: ./src/app/pages/share/share.page.ts\nvar share_page = __webpack_require__(\"7asV\");\n\n// EXTERNAL MODULE: ./node_modules/parse/index.js\nvar parse = __webpack_require__(\"v0iw\");\n\n// CONCATENATED MODULE: ./src/app/services/report.service.ts\n\r\n\r\nlet report_service_Report = /*@__PURE__*/ (() => {\r\n    class Report extends parse[\"Object\"] {\r\n        constructor() {\r\n            super('Report');\r\n        }\r\n        set reason(reason) {\r\n            this.set('reason', reason);\r\n        }\r\n        get reason() {\r\n            return this.get('reason');\r\n        }\r\n        set place(place) {\r\n            this.set('place', place);\r\n        }\r\n        get place() {\r\n            return this.get('place');\r\n        }\r\n        set reportedBy(user) {\r\n            this.set('reportedBy', user);\r\n        }\r\n        get reportedBy() {\r\n            return this.get('reportedBy');\r\n        }\r\n    }\r\n    Report.ɵfac = function Report_Factory(t) { return new (t || Report)(); };\r\n    Report.ɵprov = core[\"Lb\" /* ɵɵdefineInjectable */]({ token: Report, factory: Report.ɵfac, providedIn: 'root' });\r\n    return Report;\r\n})();\r\nparse[\"Object\"].registerSubclass('Report', report_service_Report);\r\n\n// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/BehaviorSubject.js\nvar BehaviorSubject = __webpack_require__(\"2Vo4\");\n\n// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/observable/of.js\nvar of = __webpack_require__(\"LRne\");\n\n// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/observable/empty.js\nvar empty = __webpack_require__(\"EY2u\");\n\n// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/Subscription.js + 1 modules\nvar Subscription = __webpack_require__(\"quSY\");\n\n// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/observable/fromEvent.js\nvar fromEvent = __webpack_require__(\"xgIS\");\n\n// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/observable/fromArray.js\nvar fromArray = __webpack_require__(\"yCtX\");\n\n// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/util/isArray.js\nvar isArray = __webpack_require__(\"DH7j\");\n\n// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/Subscriber.js\nvar Subscriber = __webpack_require__(\"7o/Q\");\n\n// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/OuterSubscriber.js\nvar OuterSubscriber = __webpack_require__(\"l7GE\");\n\n// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/util/subscribeToResult.js\nvar subscribeToResult = __webpack_require__(\"ZUHj\");\n\n// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/symbol/iterator.js\nvar iterator = __webpack_require__(\"Lhse\");\n\n// CONCATENATED MODULE: ./node_modules/rxjs/_esm2015/internal/observable/zip.js\n\n\n\n\n\n\nfunction zip(...observables) {\n    const resultSelector = observables[observables.length - 1];\n    if (typeof resultSelector === 'function') {\n        observables.pop();\n    }\n    return Object(fromArray[\"a\" /* fromArray */])(observables, undefined).lift(new ZipOperator(resultSelector));\n}\nclass ZipOperator {\n    constructor(resultSelector) {\n        this.resultSelector = resultSelector;\n    }\n    call(subscriber, source) {\n        return source.subscribe(new zip_ZipSubscriber(subscriber, this.resultSelector));\n    }\n}\nclass zip_ZipSubscriber extends Subscriber[\"a\" /* Subscriber */] {\n    constructor(destination, resultSelector, values = Object.create(null)) {\n        super(destination);\n        this.iterators = [];\n        this.active = 0;\n        this.resultSelector = (typeof resultSelector === 'function') ? resultSelector : null;\n        this.values = values;\n    }\n    _next(value) {\n        const iterators = this.iterators;\n        if (Object(isArray[\"a\" /* isArray */])(value)) {\n            iterators.push(new zip_StaticArrayIterator(value));\n        }\n        else if (typeof value[iterator[\"a\" /* iterator */]] === 'function') {\n            iterators.push(new StaticIterator(value[iterator[\"a\" /* iterator */]]()));\n        }\n        else {\n            iterators.push(new zip_ZipBufferIterator(this.destination, this, value));\n        }\n    }\n    _complete() {\n        const iterators = this.iterators;\n        const len = iterators.length;\n        this.unsubscribe();\n        if (len === 0) {\n            this.destination.complete();\n            return;\n        }\n        this.active = len;\n        for (let i = 0; i < len; i++) {\n            let iterator = iterators[i];\n            if (iterator.stillUnsubscribed) {\n                const destination = this.destination;\n                destination.add(iterator.subscribe(iterator, i));\n            }\n            else {\n                this.active--;\n            }\n        }\n    }\n    notifyInactive() {\n        this.active--;\n        if (this.active === 0) {\n            this.destination.complete();\n        }\n    }\n    checkIterators() {\n        const iterators = this.iterators;\n        const len = iterators.length;\n        const destination = this.destination;\n        for (let i = 0; i < len; i++) {\n            let iterator = iterators[i];\n            if (typeof iterator.hasValue === 'function' && !iterator.hasValue()) {\n                return;\n            }\n        }\n        let shouldComplete = false;\n        const args = [];\n        for (let i = 0; i < len; i++) {\n            let iterator = iterators[i];\n            let result = iterator.next();\n            if (iterator.hasCompleted()) {\n                shouldComplete = true;\n            }\n            if (result.done) {\n                destination.complete();\n                return;\n            }\n            args.push(result.value);\n        }\n        if (this.resultSelector) {\n            this._tryresultSelector(args);\n        }\n        else {\n            destination.next(args);\n        }\n        if (shouldComplete) {\n            destination.complete();\n        }\n    }\n    _tryresultSelector(args) {\n        let result;\n        try {\n            result = this.resultSelector.apply(this, args);\n        }\n        catch (err) {\n            this.destination.error(err);\n            return;\n        }\n        this.destination.next(result);\n    }\n}\nclass StaticIterator {\n    constructor(iterator) {\n        this.iterator = iterator;\n        this.nextResult = iterator.next();\n    }\n    hasValue() {\n        return true;\n    }\n    next() {\n        const result = this.nextResult;\n        this.nextResult = this.iterator.next();\n        return result;\n    }\n    hasCompleted() {\n        const nextResult = this.nextResult;\n        return nextResult && nextResult.done;\n    }\n}\nclass zip_StaticArrayIterator {\n    constructor(array) {\n        this.array = array;\n        this.index = 0;\n        this.length = 0;\n        this.length = array.length;\n    }\n    [iterator[\"a\" /* iterator */]]() {\n        return this;\n    }\n    next(value) {\n        const i = this.index++;\n        const array = this.array;\n        return i < this.length ? { value: array[i], done: false } : { value: null, done: true };\n    }\n    hasValue() {\n        return this.array.length > this.index;\n    }\n    hasCompleted() {\n        return this.array.length === this.index;\n    }\n}\nclass zip_ZipBufferIterator extends OuterSubscriber[\"a\" /* OuterSubscriber */] {\n    constructor(destination, parent, observable) {\n        super(destination);\n        this.parent = parent;\n        this.observable = observable;\n        this.stillUnsubscribed = true;\n        this.buffer = [];\n        this.isComplete = false;\n    }\n    [iterator[\"a\" /* iterator */]]() {\n        return this;\n    }\n    next() {\n        const buffer = this.buffer;\n        if (buffer.length === 0 && this.isComplete) {\n            return { value: null, done: true };\n        }\n        else {\n            return { value: buffer.shift(), done: false };\n        }\n    }\n    hasValue() {\n        return this.buffer.length > 0;\n    }\n    hasCompleted() {\n        return this.buffer.length === 0 && this.isComplete;\n    }\n    notifyComplete() {\n        if (this.buffer.length > 0) {\n            this.isComplete = true;\n            this.parent.notifyInactive();\n        }\n        else {\n            this.destination.complete();\n        }\n    }\n    notifyNext(outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n        this.buffer.push(innerValue);\n        this.parent.checkIterators();\n    }\n    subscribe(value, index) {\n        return Object(subscribeToResult[\"a\" /* subscribeToResult */])(this, this.observable, this, index);\n    }\n}\n//# sourceMappingURL=zip.js.map\n\n// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/operators/filter.js\nvar filter = __webpack_require__(\"pLZG\");\n\n// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/operators/switchMap.js\nvar switchMap = __webpack_require__(\"eIep\");\n\n// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/operators/delay.js + 1 modules\nvar operators_delay = __webpack_require__(\"3E0/\");\n\n// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/operators/tap.js\nvar tap = __webpack_require__(\"vkgz\");\n\n// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/operators/map.js\nvar map = __webpack_require__(\"lJxs\");\n\n// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/scheduler/async.js\nvar scheduler_async = __webpack_require__(\"D0XW\");\n\n// CONCATENATED MODULE: ./node_modules/rxjs/_esm2015/internal/operators/debounceTime.js\n\n\nfunction debounceTime(dueTime, scheduler = scheduler_async[\"a\" /* async */]) {\n    return (source) => source.lift(new DebounceTimeOperator(dueTime, scheduler));\n}\nclass DebounceTimeOperator {\n    constructor(dueTime, scheduler) {\n        this.dueTime = dueTime;\n        this.scheduler = scheduler;\n    }\n    call(subscriber, source) {\n        return source.subscribe(new debounceTime_DebounceTimeSubscriber(subscriber, this.dueTime, this.scheduler));\n    }\n}\nclass debounceTime_DebounceTimeSubscriber extends Subscriber[\"a\" /* Subscriber */] {\n    constructor(destination, dueTime, scheduler) {\n        super(destination);\n        this.dueTime = dueTime;\n        this.scheduler = scheduler;\n        this.debouncedSubscription = null;\n        this.lastValue = null;\n        this.hasValue = false;\n    }\n    _next(value) {\n        this.clearDebounce();\n        this.lastValue = value;\n        this.hasValue = true;\n        this.add(this.debouncedSubscription = this.scheduler.schedule(dispatchNext, this.dueTime, this));\n    }\n    _complete() {\n        this.debouncedNext();\n        this.destination.complete();\n    }\n    debouncedNext() {\n        this.clearDebounce();\n        if (this.hasValue) {\n            const { lastValue } = this;\n            this.lastValue = null;\n            this.hasValue = false;\n            this.destination.next(lastValue);\n        }\n    }\n    clearDebounce() {\n        const debouncedSubscription = this.debouncedSubscription;\n        if (debouncedSubscription !== null) {\n            this.remove(debouncedSubscription);\n            debouncedSubscription.unsubscribe();\n            this.debouncedSubscription = null;\n        }\n    }\n}\nfunction dispatchNext(subscriber) {\n    subscriber.debouncedNext();\n}\n//# sourceMappingURL=debounceTime.js.map\n\n// EXTERNAL MODULE: ./node_modules/@angular/animations/__ivy_ngcc__/fesm2015/animations.js\nvar animations = __webpack_require__(\"R0Ic\");\n\n// EXTERNAL MODULE: ./node_modules/@angular/platform-browser/__ivy_ngcc__/fesm2015/platform-browser.js\nvar platform_browser = __webpack_require__(\"jhN1\");\n\n// CONCATENATED MODULE: ./node_modules/ng-gallery/__ivy_ngcc__/fesm2015/ng-gallery.js\n\n\n\n\n\n\n\n\n\nconst _c0 = [\"*\"];\nconst _c1 = [\"iframe\"];\nfunction GalleryImageComponent_div_2_Template(rf, ctx) {\n    if (rf & 1) {\n        core[\"Qb\" /* ɵɵelement */](0, \"div\", 4);\n    }\n    if (rf & 2) {\n        const ctx_r0 = core[\"fc\" /* ɵɵnextContext */]();\n        core[\"Bc\" /* ɵɵstyleProp */](\"background-image\", ctx_r0.imageUrl);\n        core[\"lc\" /* ɵɵproperty */](\"@fadeIn\", undefined);\n    }\n}\nfunction GalleryImageComponent_div_3_div_1_Template(rf, ctx) {\n    if (rf & 1) {\n        core[\"Qb\" /* ɵɵelement */](0, \"div\", 8);\n    }\n    if (rf & 2) {\n        const ctx_r3 = core[\"fc\" /* ɵɵnextContext */](2);\n        core[\"lc\" /* ɵɵproperty */](\"innerHTML\", ctx_r3.errorTemplate, core[\"wc\" /* ɵɵsanitizeHtml */]);\n    }\n}\nfunction GalleryImageComponent_div_3_ng_template_2_ng_container_0_Template(rf, ctx) {\n    if (rf & 1) {\n        core[\"Tb\" /* ɵɵelementContainerStart */](0);\n        core[\"Vb\" /* ɵɵelementStart */](1, \"h4\");\n        core[\"Gc\" /* ɵɵtext */](2, \"\\u26A0\");\n        core[\"Ub\" /* ɵɵelementEnd */]();\n        core[\"Sb\" /* ɵɵelementContainerEnd */]();\n    }\n}\nfunction GalleryImageComponent_div_3_ng_template_2_ng_template_1_Template(rf, ctx) {\n    if (rf & 1) {\n        core[\"Vb\" /* ɵɵelementStart */](0, \"h2\");\n        core[\"Gc\" /* ɵɵtext */](1, \"\\u26A0\");\n        core[\"Ub\" /* ɵɵelementEnd */]();\n        core[\"Vb\" /* ɵɵelementStart */](2, \"p\");\n        core[\"Gc\" /* ɵɵtext */](3, \"Unable to load the image!\");\n        core[\"Ub\" /* ɵɵelementEnd */]();\n    }\n}\nfunction GalleryImageComponent_div_3_ng_template_2_Template(rf, ctx) {\n    if (rf & 1) {\n        core[\"Ec\" /* ɵɵtemplate */](0, GalleryImageComponent_div_3_ng_template_2_ng_container_0_Template, 3, 0, \"ng-container\", 9);\n        core[\"Ec\" /* ɵɵtemplate */](1, GalleryImageComponent_div_3_ng_template_2_ng_template_1_Template, 4, 0, \"ng-template\", null, 10, core[\"Fc\" /* ɵɵtemplateRefExtractor */]);\n    }\n    if (rf & 2) {\n        const _r7 = core[\"uc\" /* ɵɵreference */](2);\n        const ctx_r5 = core[\"fc\" /* ɵɵnextContext */](2);\n        core[\"lc\" /* ɵɵproperty */](\"ngIf\", ctx_r5.isThumbnail)(\"ngIfElse\", _r7);\n    }\n}\nfunction GalleryImageComponent_div_3_Template(rf, ctx) {\n    if (rf & 1) {\n        core[\"Vb\" /* ɵɵelementStart */](0, \"div\", 5);\n        core[\"Ec\" /* ɵɵtemplate */](1, GalleryImageComponent_div_3_div_1_Template, 1, 1, \"div\", 6);\n        core[\"Ec\" /* ɵɵtemplate */](2, GalleryImageComponent_div_3_ng_template_2_Template, 3, 2, \"ng-template\", null, 7, core[\"Fc\" /* ɵɵtemplateRefExtractor */]);\n        core[\"Ub\" /* ɵɵelementEnd */]();\n    }\n    if (rf & 2) {\n        const _r4 = core[\"uc\" /* ɵɵreference */](3);\n        const ctx_r1 = core[\"fc\" /* ɵɵnextContext */]();\n        core[\"Db\" /* ɵɵadvance */](1);\n        core[\"lc\" /* ɵɵproperty */](\"ngIf\", ctx_r1.errorTemplate)(\"ngIfElse\", _r4);\n    }\n}\nfunction GalleryImageComponent_ng_container_4_div_1_Template(rf, ctx) {\n    if (rf & 1) {\n        core[\"Qb\" /* ɵɵelement */](0, \"div\", 13);\n    }\n    if (rf & 2) {\n        const ctx_r9 = core[\"fc\" /* ɵɵnextContext */](2);\n        core[\"lc\" /* ɵɵproperty */](\"innerHTML\", ctx_r9.loaderTemplate, core[\"wc\" /* ɵɵsanitizeHtml */]);\n    }\n}\nfunction GalleryImageComponent_ng_container_4_ng_template_2_div_0_Template(rf, ctx) {\n    if (rf & 1) {\n        core[\"Qb\" /* ɵɵelement */](0, \"div\", 15);\n    }\n}\nfunction GalleryImageComponent_ng_container_4_ng_template_2_Template(rf, ctx) {\n    if (rf & 1) {\n        core[\"Ec\" /* ɵɵtemplate */](0, GalleryImageComponent_ng_container_4_ng_template_2_div_0_Template, 1, 0, \"div\", 14);\n    }\n    if (rf & 2) {\n        const ctx_r11 = core[\"fc\" /* ɵɵnextContext */](2);\n        core[\"lc\" /* ɵɵproperty */](\"ngIf\", ctx_r11.isThumbnail);\n    }\n}\nfunction GalleryImageComponent_ng_container_4_Template(rf, ctx) {\n    if (rf & 1) {\n        core[\"Tb\" /* ɵɵelementContainerStart */](0);\n        core[\"Ec\" /* ɵɵtemplate */](1, GalleryImageComponent_ng_container_4_div_1_Template, 1, 1, \"div\", 11);\n        core[\"Ec\" /* ɵɵtemplate */](2, GalleryImageComponent_ng_container_4_ng_template_2_Template, 1, 1, \"ng-template\", null, 12, core[\"Fc\" /* ɵɵtemplateRefExtractor */]);\n        core[\"Sb\" /* ɵɵelementContainerEnd */]();\n    }\n    if (rf & 2) {\n        const _r10 = core[\"uc\" /* ɵɵreference */](3);\n        const ctx_r2 = core[\"fc\" /* ɵɵnextContext */]();\n        core[\"Db\" /* ɵɵadvance */](1);\n        core[\"lc\" /* ɵɵproperty */](\"ngIf\", ctx_r2.loaderTemplate)(\"ngIfElse\", _r10);\n    }\n}\nconst _c2 = [\"video\"];\nfunction GalleryVideoComponent_source_2_Template(rf, ctx) {\n    if (rf & 1) {\n        core[\"Qb\" /* ɵɵelement */](0, \"source\", 3);\n    }\n    if (rf & 2) {\n        const src_r2 = ctx.$implicit;\n        core[\"lc\" /* ɵɵproperty */](\"src\", src_r2 == null ? null : src_r2.url, core[\"zc\" /* ɵɵsanitizeUrl */])(\"type\", src_r2 == null ? null : src_r2.type);\n    }\n}\nfunction GalleryNavComponent_i_0_Template(rf, ctx) {\n    if (rf & 1) {\n        const _r3 = core[\"Wb\" /* ɵɵgetCurrentView */]();\n        core[\"Vb\" /* ɵɵelementStart */](0, \"i\", 2);\n        core[\"dc\" /* ɵɵlistener */](\"tapClick\", function GalleryNavComponent_i_0_Template_i_tapClick_0_listener() { core[\"vc\" /* ɵɵrestoreView */](_r3); const ctx_r2 = core[\"fc\" /* ɵɵnextContext */](); return ctx_r2.action.emit(\"prev\"); });\n        core[\"Ub\" /* ɵɵelementEnd */]();\n    }\n    if (rf & 2) {\n        const ctx_r0 = core[\"fc\" /* ɵɵnextContext */]();\n        core[\"lc\" /* ɵɵproperty */](\"innerHtml\", ctx_r0.navIcon, core[\"wc\" /* ɵɵsanitizeHtml */]);\n    }\n}\nfunction GalleryNavComponent_i_1_Template(rf, ctx) {\n    if (rf & 1) {\n        const _r5 = core[\"Wb\" /* ɵɵgetCurrentView */]();\n        core[\"Vb\" /* ɵɵelementStart */](0, \"i\", 3);\n        core[\"dc\" /* ɵɵlistener */](\"tapClick\", function GalleryNavComponent_i_1_Template_i_tapClick_0_listener() { core[\"vc\" /* ɵɵrestoreView */](_r5); const ctx_r4 = core[\"fc\" /* ɵɵnextContext */](); return ctx_r4.action.emit(\"next\"); });\n        core[\"Ub\" /* ɵɵelementEnd */]();\n    }\n    if (rf & 2) {\n        const ctx_r1 = core[\"fc\" /* ɵɵnextContext */]();\n        core[\"lc\" /* ɵɵproperty */](\"innerHtml\", ctx_r1.navIcon, core[\"wc\" /* ɵɵsanitizeHtml */]);\n    }\n}\nfunction GalleryCoreComponent_gallery_thumbs_0_Template(rf, ctx) {\n    if (rf & 1) {\n        const _r5 = core[\"Wb\" /* ɵɵgetCurrentView */]();\n        core[\"Vb\" /* ɵɵelementStart */](0, \"gallery-thumbs\", 5);\n        core[\"dc\" /* ɵɵlistener */](\"action\", function GalleryCoreComponent_gallery_thumbs_0_Template_gallery_thumbs_action_0_listener($event) { core[\"vc\" /* ɵɵrestoreView */](_r5); const ctx_r4 = core[\"fc\" /* ɵɵnextContext */](); return ctx_r4.action.emit($event); })(\"thumbClick\", function GalleryCoreComponent_gallery_thumbs_0_Template_gallery_thumbs_thumbClick_0_listener($event) { core[\"vc\" /* ɵɵrestoreView */](_r5); const ctx_r6 = core[\"fc\" /* ɵɵnextContext */](); return ctx_r6.thumbClick.emit($event); });\n        core[\"Ub\" /* ɵɵelementEnd */]();\n    }\n    if (rf & 2) {\n        const ctx_r0 = core[\"fc\" /* ɵɵnextContext */]();\n        core[\"lc\" /* ɵɵproperty */](\"state\", ctx_r0.state)(\"config\", ctx_r0.config);\n    }\n}\nfunction GalleryCoreComponent_gallery_nav_3_Template(rf, ctx) {\n    if (rf & 1) {\n        const _r8 = core[\"Wb\" /* ɵɵgetCurrentView */]();\n        core[\"Vb\" /* ɵɵelementStart */](0, \"gallery-nav\", 6);\n        core[\"dc\" /* ɵɵlistener */](\"action\", function GalleryCoreComponent_gallery_nav_3_Template_gallery_nav_action_0_listener($event) { core[\"vc\" /* ɵɵrestoreView */](_r8); const ctx_r7 = core[\"fc\" /* ɵɵnextContext */](); return ctx_r7.action.emit($event); });\n        core[\"Ub\" /* ɵɵelementEnd */]();\n    }\n    if (rf & 2) {\n        const ctx_r1 = core[\"fc\" /* ɵɵnextContext */]();\n        core[\"lc\" /* ɵɵproperty */](\"state\", ctx_r1.state)(\"config\", ctx_r1.config);\n    }\n}\nfunction GalleryCoreComponent_gallery_dots_4_Template(rf, ctx) {\n    if (rf & 1) {\n        const _r10 = core[\"Wb\" /* ɵɵgetCurrentView */]();\n        core[\"Vb\" /* ɵɵelementStart */](0, \"gallery-dots\", 6);\n        core[\"dc\" /* ɵɵlistener */](\"action\", function GalleryCoreComponent_gallery_dots_4_Template_gallery_dots_action_0_listener($event) { core[\"vc\" /* ɵɵrestoreView */](_r10); const ctx_r9 = core[\"fc\" /* ɵɵnextContext */](); return ctx_r9.action.emit($event); });\n        core[\"Ub\" /* ɵɵelementEnd */]();\n    }\n    if (rf & 2) {\n        const ctx_r2 = core[\"fc\" /* ɵɵnextContext */]();\n        core[\"lc\" /* ɵɵproperty */](\"state\", ctx_r2.state)(\"config\", ctx_r2.config);\n    }\n}\nfunction GalleryCoreComponent_gallery_counter_5_Template(rf, ctx) {\n    if (rf & 1) {\n        core[\"Qb\" /* ɵɵelement */](0, \"gallery-counter\", 7);\n    }\n    if (rf & 2) {\n        const ctx_r3 = core[\"fc\" /* ɵɵnextContext */]();\n        core[\"lc\" /* ɵɵproperty */](\"state\", ctx_r3.state);\n    }\n}\nfunction GalleryDotsComponent_div_0_Template(rf, ctx) {\n    if (rf & 1) {\n        const _r4 = core[\"Wb\" /* ɵɵgetCurrentView */]();\n        core[\"Vb\" /* ɵɵelementStart */](0, \"div\", 1);\n        core[\"dc\" /* ɵɵlistener */](\"tapClick\", function GalleryDotsComponent_div_0_Template_div_tapClick_0_listener() { core[\"vc\" /* ɵɵrestoreView */](_r4); const i_r2 = ctx.index; const ctx_r3 = core[\"fc\" /* ɵɵnextContext */](); return ctx_r3.action.emit(i_r2); });\n        core[\"Qb\" /* ɵɵelement */](1, \"div\", 2);\n        core[\"Ub\" /* ɵɵelementEnd */]();\n    }\n    if (rf & 2) {\n        const i_r2 = ctx.index;\n        const ctx_r0 = core[\"fc\" /* ɵɵnextContext */]();\n        core[\"Bc\" /* ɵɵstyleProp */](\"width\", ctx_r0.config == null ? null : ctx_r0.config.dotsSize, \"px\")(\"height\", ctx_r0.config == null ? null : ctx_r0.config.dotsSize, \"px\");\n        core[\"Hb\" /* ɵɵclassProp */](\"g-dot-active\", i_r2 === ctx_r0.state.currIndex);\n    }\n}\nfunction GalleryThumbsComponent_div_0_gallery_thumb_2_Template(rf, ctx) {\n    if (rf & 1) {\n        const _r6 = core[\"Wb\" /* ɵɵgetCurrentView */]();\n        core[\"Vb\" /* ɵɵelementStart */](0, \"gallery-thumb\", 4);\n        core[\"dc\" /* ɵɵlistener */](\"tapClick\", function GalleryThumbsComponent_div_0_gallery_thumb_2_Template_gallery_thumb_tapClick_0_listener() { core[\"vc\" /* ɵɵrestoreView */](_r6); const i_r4 = ctx.index; const ctx_r5 = core[\"fc\" /* ɵɵnextContext */](2); return ctx_r5.thumbClick.emit(i_r4); })(\"error\", function GalleryThumbsComponent_div_0_gallery_thumb_2_Template_gallery_thumb_error_0_listener($event) { core[\"vc\" /* ɵɵrestoreView */](_r6); const i_r4 = ctx.index; const ctx_r7 = core[\"fc\" /* ɵɵnextContext */](2); return ctx_r7.error.emit({ itemIndex: i_r4, error: $event }); });\n        core[\"Ub\" /* ɵɵelementEnd */]();\n    }\n    if (rf & 2) {\n        const item_r3 = ctx.$implicit;\n        const i_r4 = ctx.index;\n        const ctx_r2 = core[\"fc\" /* ɵɵnextContext */](2);\n        core[\"lc\" /* ɵɵproperty */](\"type\", item_r3.type)(\"config\", ctx_r2.config)(\"data\", item_r3.data)(\"currIndex\", ctx_r2.state.currIndex)(\"index\", i_r4)(\"tapClickDisabled\", ctx_r2.config.disableThumb);\n    }\n}\nfunction GalleryThumbsComponent_div_0_Template(rf, ctx) {\n    if (rf & 1) {\n        core[\"Vb\" /* ɵɵelementStart */](0, \"div\", 1);\n        core[\"Vb\" /* ɵɵelementStart */](1, \"div\", 2);\n        core[\"Ec\" /* ɵɵtemplate */](2, GalleryThumbsComponent_div_0_gallery_thumb_2_Template, 1, 6, \"gallery-thumb\", 3);\n        core[\"Ub\" /* ɵɵelementEnd */]();\n        core[\"Ub\" /* ɵɵelementEnd */]();\n    }\n    if (rf & 2) {\n        const sliderState_r1 = ctx.$implicit;\n        const ctx_r0 = core[\"fc\" /* ɵɵnextContext */]();\n        core[\"Db\" /* ɵɵadvance */](1);\n        core[\"Hb\" /* ɵɵclassProp */](\"g-no-transition\", sliderState_r1.active);\n        core[\"lc\" /* ɵɵproperty */](\"ngStyle\", sliderState_r1.style);\n        core[\"Db\" /* ɵɵadvance */](1);\n        core[\"lc\" /* ɵɵproperty */](\"ngForOf\", ctx_r0.state.items);\n    }\n}\nfunction GallerySliderComponent_div_0_gallery_item_2_Template(rf, ctx) {\n    if (rf & 1) {\n        const _r6 = core[\"Wb\" /* ɵɵgetCurrentView */]();\n        core[\"Vb\" /* ɵɵelementStart */](0, \"gallery-item\", 4);\n        core[\"dc\" /* ɵɵlistener */](\"tapClick\", function GallerySliderComponent_div_0_gallery_item_2_Template_gallery_item_tapClick_0_listener() { core[\"vc\" /* ɵɵrestoreView */](_r6); const i_r4 = ctx.index; const ctx_r5 = core[\"fc\" /* ɵɵnextContext */](2); return ctx_r5.itemClick.emit(i_r4); })(\"error\", function GallerySliderComponent_div_0_gallery_item_2_Template_gallery_item_error_0_listener($event) { core[\"vc\" /* ɵɵrestoreView */](_r6); const i_r4 = ctx.index; const ctx_r7 = core[\"fc\" /* ɵɵnextContext */](2); return ctx_r7.error.emit({ itemIndex: i_r4, error: $event }); });\n        core[\"Ub\" /* ɵɵelementEnd */]();\n    }\n    if (rf & 2) {\n        const item_r3 = ctx.$implicit;\n        const i_r4 = ctx.index;\n        const ctx_r2 = core[\"fc\" /* ɵɵnextContext */](2);\n        core[\"lc\" /* ɵɵproperty */](\"type\", item_r3.type)(\"config\", ctx_r2.config)(\"data\", item_r3.data)(\"currIndex\", ctx_r2.state.currIndex)(\"index\", i_r4);\n    }\n}\nfunction GallerySliderComponent_div_0_Template(rf, ctx) {\n    if (rf & 1) {\n        core[\"Vb\" /* ɵɵelementStart */](0, \"div\", 1);\n        core[\"Vb\" /* ɵɵelementStart */](1, \"div\", 2);\n        core[\"Ec\" /* ɵɵtemplate */](2, GallerySliderComponent_div_0_gallery_item_2_Template, 1, 5, \"gallery-item\", 3);\n        core[\"Ub\" /* ɵɵelementEnd */]();\n        core[\"Ub\" /* ɵɵelementEnd */]();\n    }\n    if (rf & 2) {\n        const sliderState_r1 = ctx.$implicit;\n        const ctx_r0 = core[\"fc\" /* ɵɵnextContext */]();\n        core[\"lc\" /* ɵɵproperty */](\"ngStyle\", ctx_r0.zoom);\n        core[\"Db\" /* ɵɵadvance */](1);\n        core[\"Hb\" /* ɵɵclassProp */](\"g-no-transition\", sliderState_r1.active);\n        core[\"lc\" /* ɵɵproperty */](\"ngStyle\", sliderState_r1.style);\n        core[\"Db\" /* ɵɵadvance */](1);\n        core[\"lc\" /* ɵɵproperty */](\"ngForOf\", ctx_r0.state.items);\n    }\n}\nfunction GalleryItemComponent_ng_container_0_ng_container_1_ng_container_3_Template(rf, ctx) {\n    if (rf & 1) {\n        core[\"Rb\" /* ɵɵelementContainer */](0);\n    }\n}\nconst _c3 = function (a0, a1, a2, a3) { return { index: a0, currIndex: a1, type: a2, data: a3 }; };\nfunction GalleryItemComponent_ng_container_0_ng_container_1_Template(rf, ctx) {\n    if (rf & 1) {\n        const _r8 = core[\"Wb\" /* ɵɵgetCurrentView */]();\n        core[\"Tb\" /* ɵɵelementContainerStart */](0);\n        core[\"Vb\" /* ɵɵelementStart */](1, \"gallery-image\", 7);\n        core[\"dc\" /* ɵɵlistener */](\"error\", function GalleryItemComponent_ng_container_0_ng_container_1_Template_gallery_image_error_1_listener($event) { core[\"vc\" /* ɵɵrestoreView */](_r8); const ctx_r7 = core[\"fc\" /* ɵɵnextContext */](2); return ctx_r7.error.emit($event); });\n        core[\"Ub\" /* ɵɵelementEnd */]();\n        core[\"Vb\" /* ɵɵelementStart */](2, \"div\", 8);\n        core[\"Ec\" /* ɵɵtemplate */](3, GalleryItemComponent_ng_container_0_ng_container_1_ng_container_3_Template, 1, 0, \"ng-container\", 9);\n        core[\"Ub\" /* ɵɵelementEnd */]();\n        core[\"Sb\" /* ɵɵelementContainerEnd */]();\n    }\n    if (rf & 2) {\n        const ctx_r1 = core[\"fc\" /* ɵɵnextContext */](2);\n        core[\"Db\" /* ɵɵadvance */](1);\n        core[\"lc\" /* ɵɵproperty */](\"src\", ctx_r1.data.src)(\"loadingIcon\", ctx_r1.config.loadingIcon)(\"loadingError\", ctx_r1.config.loadingError);\n        core[\"Db\" /* ɵɵadvance */](2);\n        core[\"lc\" /* ɵɵproperty */](\"ngTemplateOutlet\", ctx_r1.config.itemTemplate)(\"ngTemplateOutletContext\", core[\"sc\" /* ɵɵpureFunction4 */](5, _c3, ctx_r1.index, ctx_r1.currIndex, ctx_r1.type, ctx_r1.data));\n    }\n}\nfunction GalleryItemComponent_ng_container_0_gallery_video_2_Template(rf, ctx) {\n    if (rf & 1) {\n        const _r10 = core[\"Wb\" /* ɵɵgetCurrentView */]();\n        core[\"Vb\" /* ɵɵelementStart */](0, \"gallery-video\", 10);\n        core[\"dc\" /* ɵɵlistener */](\"error\", function GalleryItemComponent_ng_container_0_gallery_video_2_Template_gallery_video_error_0_listener($event) { core[\"vc\" /* ɵɵrestoreView */](_r10); const ctx_r9 = core[\"fc\" /* ɵɵnextContext */](2); return ctx_r9.error.emit($event); });\n        core[\"Ub\" /* ɵɵelementEnd */]();\n    }\n    if (rf & 2) {\n        const ctx_r2 = core[\"fc\" /* ɵɵnextContext */](2);\n        core[\"lc\" /* ɵɵproperty */](\"src\", ctx_r2.data.src)(\"poster\", ctx_r2.data.poster)(\"controls\", ctx_r2.data.controls)(\"play\", ctx_r2.isAutoPlay)(\"pause\", ctx_r2.currIndex !== ctx_r2.index);\n    }\n}\nfunction GalleryItemComponent_ng_container_0_gallery_iframe_3_Template(rf, ctx) {\n    if (rf & 1) {\n        core[\"Qb\" /* ɵɵelement */](0, \"gallery-iframe\", 11);\n    }\n    if (rf & 2) {\n        const ctx_r3 = core[\"fc\" /* ɵɵnextContext */](2);\n        core[\"lc\" /* ɵɵproperty */](\"src\", ctx_r3.youtubeSrc)(\"autoplay\", ctx_r3.isAutoPlay)(\"pause\", ctx_r3.currIndex !== ctx_r3.index);\n    }\n}\nfunction GalleryItemComponent_ng_container_0_gallery_iframe_4_Template(rf, ctx) {\n    if (rf & 1) {\n        core[\"Qb\" /* ɵɵelement */](0, \"gallery-iframe\", 12);\n    }\n    if (rf & 2) {\n        const ctx_r4 = core[\"fc\" /* ɵɵnextContext */](2);\n        core[\"lc\" /* ɵɵproperty */](\"src\", ctx_r4.data.src);\n    }\n}\nfunction GalleryItemComponent_ng_container_0_ng_container_5_ng_container_2_Template(rf, ctx) {\n    if (rf & 1) {\n        core[\"Rb\" /* ɵɵelementContainer */](0);\n    }\n}\nfunction GalleryItemComponent_ng_container_0_ng_container_5_Template(rf, ctx) {\n    if (rf & 1) {\n        core[\"Tb\" /* ɵɵelementContainerStart */](0);\n        core[\"Vb\" /* ɵɵelementStart */](1, \"div\", 8);\n        core[\"Ec\" /* ɵɵtemplate */](2, GalleryItemComponent_ng_container_0_ng_container_5_ng_container_2_Template, 1, 0, \"ng-container\", 9);\n        core[\"Ub\" /* ɵɵelementEnd */]();\n        core[\"Sb\" /* ɵɵelementContainerEnd */]();\n    }\n    if (rf & 2) {\n        const ctx_r5 = core[\"fc\" /* ɵɵnextContext */](2);\n        core[\"Db\" /* ɵɵadvance */](2);\n        core[\"lc\" /* ɵɵproperty */](\"ngTemplateOutlet\", ctx_r5.config.itemTemplate)(\"ngTemplateOutletContext\", core[\"sc\" /* ɵɵpureFunction4 */](2, _c3, ctx_r5.index, ctx_r5.currIndex, ctx_r5.type, ctx_r5.data));\n    }\n}\nfunction GalleryItemComponent_ng_container_0_Template(rf, ctx) {\n    if (rf & 1) {\n        core[\"Tb\" /* ɵɵelementContainerStart */](0, 1);\n        core[\"Ec\" /* ɵɵtemplate */](1, GalleryItemComponent_ng_container_0_ng_container_1_Template, 4, 10, \"ng-container\", 2);\n        core[\"Ec\" /* ɵɵtemplate */](2, GalleryItemComponent_ng_container_0_gallery_video_2_Template, 1, 5, \"gallery-video\", 3);\n        core[\"Ec\" /* ɵɵtemplate */](3, GalleryItemComponent_ng_container_0_gallery_iframe_3_Template, 1, 3, \"gallery-iframe\", 4);\n        core[\"Ec\" /* ɵɵtemplate */](4, GalleryItemComponent_ng_container_0_gallery_iframe_4_Template, 1, 1, \"gallery-iframe\", 5);\n        core[\"Ec\" /* ɵɵtemplate */](5, GalleryItemComponent_ng_container_0_ng_container_5_Template, 3, 7, \"ng-container\", 6);\n        core[\"Sb\" /* ɵɵelementContainerEnd */]();\n    }\n    if (rf & 2) {\n        const ctx_r0 = core[\"fc\" /* ɵɵnextContext */]();\n        core[\"lc\" /* ɵɵproperty */](\"ngSwitch\", ctx_r0.type);\n        core[\"Db\" /* ɵɵadvance */](1);\n        core[\"lc\" /* ɵɵproperty */](\"ngSwitchCase\", ctx_r0.Types.Image);\n        core[\"Db\" /* ɵɵadvance */](1);\n        core[\"lc\" /* ɵɵproperty */](\"ngSwitchCase\", ctx_r0.Types.Video);\n        core[\"Db\" /* ɵɵadvance */](1);\n        core[\"lc\" /* ɵɵproperty */](\"ngSwitchCase\", ctx_r0.Types.Youtube);\n        core[\"Db\" /* ɵɵadvance */](1);\n        core[\"lc\" /* ɵɵproperty */](\"ngSwitchCase\", ctx_r0.Types.Iframe);\n    }\n}\nfunction GalleryThumbComponent_div_1_ng_container_1_Template(rf, ctx) {\n    if (rf & 1) {\n        core[\"Rb\" /* ɵɵelementContainer */](0);\n    }\n}\nconst _c4 = function (a0, a1, a2) { return { index: a0, type: a1, data: a2 }; };\nfunction GalleryThumbComponent_div_1_Template(rf, ctx) {\n    if (rf & 1) {\n        core[\"Vb\" /* ɵɵelementStart */](0, \"div\", 2);\n        core[\"Ec\" /* ɵɵtemplate */](1, GalleryThumbComponent_div_1_ng_container_1_Template, 1, 0, \"ng-container\", 3);\n        core[\"Ub\" /* ɵɵelementEnd */]();\n    }\n    if (rf & 2) {\n        const ctx_r0 = core[\"fc\" /* ɵɵnextContext */]();\n        core[\"Db\" /* ɵɵadvance */](1);\n        core[\"lc\" /* ɵɵproperty */](\"ngTemplateOutlet\", ctx_r0.config.thumbTemplate)(\"ngTemplateOutletContext\", core[\"rc\" /* ɵɵpureFunction3 */](2, _c4, ctx_r0.index, ctx_r0.type, ctx_r0.data));\n    }\n}\nvar GalleryAction = /*@__PURE__*/ (function (GalleryAction) {\n    GalleryAction[\"INITIALIZED\"] = \"initialized\";\n    GalleryAction[\"ITEMS_CHANGED\"] = \"itemsChanged\";\n    GalleryAction[\"INDEX_CHANGED\"] = \"indexChanged\";\n    GalleryAction[\"PLAY\"] = \"play\";\n    GalleryAction[\"STOP\"] = \"stop\";\n    return GalleryAction;\n})({});\nvar ImageSize = /*@__PURE__*/ (function (ImageSize) {\n    ImageSize[\"Cover\"] = \"cover\";\n    ImageSize[\"Contain\"] = \"contain\";\n    return ImageSize;\n})({});\nvar LoadingStrategy = /*@__PURE__*/ (function (LoadingStrategy) {\n    LoadingStrategy[\"Preload\"] = \"preload\";\n    LoadingStrategy[\"Lazy\"] = \"lazy\";\n    LoadingStrategy[\"Default\"] = \"default\";\n    return LoadingStrategy;\n})({});\nvar ThumbnailsPosition = /*@__PURE__*/ (function (ThumbnailsPosition) {\n    ThumbnailsPosition[\"Top\"] = \"top\";\n    ThumbnailsPosition[\"Left\"] = \"left\";\n    ThumbnailsPosition[\"Right\"] = \"right\";\n    ThumbnailsPosition[\"Bottom\"] = \"bottom\";\n    return ThumbnailsPosition;\n})({});\nvar ImageLoaderMode = /*@__PURE__*/ (function (ImageLoaderMode) {\n    ImageLoaderMode[\"Determinate\"] = \"determinate\";\n    ImageLoaderMode[\"Indeterminate\"] = \"indeterminate\";\n    return ImageLoaderMode;\n})({});\nvar DotsPosition = /*@__PURE__*/ (function (DotsPosition) {\n    DotsPosition[\"Top\"] = \"top\";\n    DotsPosition[\"Bottom\"] = \"bottom\";\n    return DotsPosition;\n})({});\nvar CounterPosition = /*@__PURE__*/ (function (CounterPosition) {\n    CounterPosition[\"Top\"] = \"top\";\n    CounterPosition[\"Bottom\"] = \"bottom\";\n    return CounterPosition;\n})({});\nvar ThumbnailsMode = /*@__PURE__*/ (function (ThumbnailsMode) {\n    ThumbnailsMode[\"Free\"] = \"free\";\n    ThumbnailsMode[\"Strict\"] = \"strict\";\n    return ThumbnailsMode;\n})({});\nvar SlidingDirection = /*@__PURE__*/ (function (SlidingDirection) {\n    SlidingDirection[\"Horizontal\"] = \"horizontal\";\n    SlidingDirection[\"Vertical\"] = \"vertical\";\n    return SlidingDirection;\n})({});\nvar GalleryItemType = /*@__PURE__*/ (function (GalleryItemType) {\n    GalleryItemType[\"Image\"] = \"image\";\n    GalleryItemType[\"Video\"] = \"video\";\n    GalleryItemType[\"Youtube\"] = \"youtube\";\n    GalleryItemType[\"Iframe\"] = \"iframe\";\n    return GalleryItemType;\n})({});\n/** Initial state */\nconst defaultState = {\n    action: GalleryAction.INITIALIZED,\n    isPlaying: false,\n    hasNext: false,\n    hasPrev: false,\n    currIndex: 0,\n    items: []\n};\nconst defaultConfig = {\n    nav: true,\n    loop: true,\n    zoomOut: 0,\n    dots: false,\n    thumb: true,\n    dotsSize: 30,\n    counter: true,\n    gestures: true,\n    autoPlay: false,\n    thumbWidth: 120,\n    thumbHeight: 90,\n    panSensitivity: 25,\n    disableThumb: false,\n    playerInterval: 3000,\n    imageSize: ImageSize.Contain,\n    thumbMode: ThumbnailsMode.Strict,\n    dotsPosition: DotsPosition.Bottom,\n    counterPosition: CounterPosition.Top,\n    thumbPosition: ThumbnailsPosition.Bottom,\n    loadingStrategy: LoadingStrategy.Default,\n    slidingDirection: SlidingDirection.Horizontal,\n    navIcon: `<?xml version=\"1.0\" encoding=\"UTF-8\"?><svg width=\"512px\" height=\"512px\" enable-background=\"new 0 0 240.823 240.823\" version=\"1.1\" viewBox=\"0 0 240.823 240.823\" xml:space=\"preserve\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"m183.19 111.82l-108.3-108.26c-4.752-4.74-12.451-4.74-17.215 0-4.752 4.74-4.752 12.439 0 17.179l99.707 99.671-99.695 99.671c-4.752 4.74-4.752 12.439 0 17.191 4.752 4.74 12.463 4.74 17.215 0l108.3-108.26c4.68-4.691 4.68-12.511-0.012-17.19z\" fill=\"#fff\"/></svg>`,\n    loadingIcon: `<?xml version=\"1.0\" encoding=\"UTF-8\"?><svg stroke=\"#fff\" viewBox=\"0 0 44 44\" xmlns=\"http://www.w3.org/2000/svg\"><g fill=\"none\" fill-rule=\"evenodd\" stroke-width=\"2\"><circle cx=\"22\" cy=\"22\" r=\"1\"><animate attributeName=\"r\" begin=\"0s\" calcMode=\"spline\" dur=\"1.8s\" keySplines=\"0.165, 0.84, 0.44, 1\" keyTimes=\"0; 1\" repeatCount=\"indefinite\" values=\"1; 20\"/><animate attributeName=\"stroke-opacity\" begin=\"0s\" calcMode=\"spline\" dur=\"1.8s\" keySplines=\"0.3, 0.61, 0.355, 1\" keyTimes=\"0; 1\" repeatCount=\"indefinite\" values=\"1; 0\"/></circle><circle cx=\"22\" cy=\"22\" r=\"1\"><animate attributeName=\"r\" begin=\"-0.9s\" calcMode=\"spline\" dur=\"1.8s\" keySplines=\"0.165, 0.84, 0.44, 1\" keyTimes=\"0; 1\" repeatCount=\"indefinite\" values=\"1; 20\"/><animate attributeName=\"stroke-opacity\" begin=\"-0.9s\" calcMode=\"spline\" dur=\"1.8s\" keySplines=\"0.3, 0.61, 0.355, 1\" keyTimes=\"0; 1\" repeatCount=\"indefinite\" values=\"1; 0\"/></circle></g></svg>`\n};\nclass ImageItem {\n    constructor(data) {\n        this.data = data;\n        this.type = GalleryItemType.Image;\n    }\n}\nclass VideoItem {\n    constructor(data) {\n        this.data = data;\n        this.type = GalleryItemType.Video;\n    }\n}\nclass IframeItem {\n    constructor(data) {\n        this.data = data;\n        this.type = GalleryItemType.Iframe;\n    }\n}\nclass YoutubeItem {\n    constructor(data) {\n        this.data = Object.assign(Object.assign({}, data), {\n            src: `https://youtube.com/embed/${data.src}`,\n            thumb: data.thumb ? data.thumb : `//img.youtube.com/vi/${data.src}/default.jpg`\n        });\n        this.type = GalleryItemType.Youtube;\n    }\n}\nconst filterActions = (actions) => {\n    return Object(filter[\"a\" /* filter */])((state) => actions.indexOf(state.action) > -1);\n};\nconst ɵ0 = filterActions;\nclass ng_gallery_GalleryRef {\n    constructor(config, deleteInstance) {\n        this.deleteInstance = deleteInstance;\n        /** Stream that emits on item click */\n        this.itemClick = new Subject[\"a\" /* Subject */]();\n        /** Stream that emits on thumbnail click */\n        this.thumbClick = new Subject[\"a\" /* Subject */]();\n        /** Stream that emits on an error occurs */\n        this.error = new Subject[\"a\" /* Subject */]();\n        this._state = new BehaviorSubject[\"a\" /* BehaviorSubject */](defaultState);\n        this._config = new BehaviorSubject[\"a\" /* BehaviorSubject */](config);\n        this.state = this._state.asObservable();\n        this.config = this._config.asObservable();\n    }\n    /** Stream that emits when gallery is initialized/reset */\n    get initialized() {\n        return this.state.pipe(filterActions([GalleryAction.INITIALIZED]));\n    }\n    /** Stream that emits when items is changed (items loaded, item added, item removed) */\n    get itemsChanged() {\n        return this.state.pipe(filterActions([GalleryAction.ITEMS_CHANGED]));\n    }\n    /** Stream that emits when current item is changed */\n    get indexChanged() {\n        return this.state.pipe(filterActions([GalleryAction.INDEX_CHANGED]));\n    }\n    /** Stream that emits when the player should start or stop */\n    get playingChanged() {\n        return this.state.pipe(filterActions([GalleryAction.PLAY, GalleryAction.STOP]));\n    }\n    /** Stream that emits when the player should start or stop */\n    get playerActions() {\n        return this.state.pipe(filterActions([GalleryAction.PLAY, GalleryAction.STOP, GalleryAction.INDEX_CHANGED]));\n    }\n    /**\n     * Activate player actions listener\n     */\n    activatePlayer() {\n        return this.playerActions.pipe(Object(switchMap[\"a\" /* switchMap */])((e) => e.isPlaying ? Object(of[\"a\" /* of */])({}).pipe(Object(operators_delay[\"a\" /* delay */])(this._config.value.playerInterval), Object(tap[\"a\" /* tap */])(() => this.next())) : empty[\"a\" /* EMPTY */]));\n    }\n    /**\n     * Set gallery state\n     */\n    setState(state) {\n        this._state.next(Object.assign(Object.assign({}, this._state.value), state));\n    }\n    /**\n     * Set gallery config\n     */\n    setConfig(config) {\n        this._config.next(Object.assign(Object.assign({}, this._config.value), config));\n    }\n    /**\n     * Add gallery item\n     */\n    add(item, active) {\n        const items = [...this._state.value.items, item];\n        this.setState({\n            action: GalleryAction.ITEMS_CHANGED,\n            items,\n            hasNext: items.length > 1,\n            currIndex: active ? items.length - 1 : this._state.value.currIndex\n        });\n    }\n    /**\n     * Add image item\n     */\n    addImage(data, active) {\n        this.add(new ImageItem(data), active);\n    }\n    /**\n     * Add video item\n     */\n    addVideo(data, active) {\n        this.add(new VideoItem(data), active);\n    }\n    /**\n     * Add iframe item\n     */\n    addIframe(data, active) {\n        this.add(new IframeItem(data), active);\n    }\n    /**\n     * Add youtube item\n     */\n    addYoutube(data, active) {\n        this.add(new YoutubeItem(data), active);\n    }\n    /**\n     * Remove gallery item\n     */\n    remove(i) {\n        const items = [\n            ...this._state.value.items.slice(0, i),\n            ...this._state.value.items.slice(i + 1, this._state.value.items.length)\n        ];\n        this.setState({\n            action: GalleryAction.ITEMS_CHANGED,\n            items,\n            hasNext: items.length > 1,\n            hasPrev: i > 0\n        });\n    }\n    /**\n     * Load items and reset the state\n     */\n    load(items) {\n        if (items) {\n            this.setState({\n                action: GalleryAction.ITEMS_CHANGED,\n                items,\n                hasNext: items.length > 1,\n                hasPrev: false\n            });\n        }\n    }\n    /**\n     * Set active item\n     */\n    set(i) {\n        if (i !== this._state.value.currIndex) {\n            this.setState({\n                action: GalleryAction.INDEX_CHANGED,\n                currIndex: i,\n                hasNext: i < this._state.value.items.length - 1,\n                hasPrev: i > 0\n            });\n        }\n    }\n    /**\n     * Next item\n     */\n    next() {\n        if (this._state.value.hasNext) {\n            this.set(this._state.value.currIndex + 1);\n        }\n        else if (this._config.value.loop) {\n            this.set(0);\n        }\n    }\n    /**\n     * Prev item\n     */\n    prev() {\n        if (this._state.value.hasPrev) {\n            this.set(this._state.value.currIndex - 1);\n        }\n        else if (this._config.value.loop) {\n            this.set(this._state.value.items.length - 1);\n        }\n    }\n    /**\n     * Start gallery player\n     */\n    play(interval) {\n        if (interval) {\n            this.setConfig({ playerInterval: interval });\n        }\n        this.setState({ action: GalleryAction.PLAY, isPlaying: true });\n    }\n    /**\n     * Stop gallery player\n     */\n    stop() {\n        this.setState({ action: GalleryAction.STOP, isPlaying: false });\n    }\n    /**\n     * Reset gallery to initial state\n     */\n    reset() {\n        this.setState(defaultState);\n    }\n    /**\n     * Destroy gallery\n     */\n    destroy() {\n        this._state.complete();\n        this._config.complete();\n        this.itemClick.complete();\n        this.thumbClick.complete();\n        this.deleteInstance();\n    }\n}\nconst GALLERY_CONFIG = new core[\"s\" /* InjectionToken */]('GALLERY_CONFIG');\nlet ng_gallery_Gallery = /*@__PURE__*/ (() => {\n    class Gallery {\n        constructor(config) {\n            /** Store gallery instances */\n            this._instances = new Map();\n            this.config = config ? Object.assign(Object.assign({}, defaultConfig), config) : defaultConfig;\n        }\n        /**\n         * Get or create gallery by ID\n         * @param id\n         * @param config\n         */\n        ref(id = 'root', config) {\n            if (this._instances.has(id)) {\n                const galleryRef = this._instances.get(id);\n                if (config) {\n                    galleryRef.setConfig(Object.assign(Object.assign({}, this.config), config));\n                }\n                return galleryRef;\n            }\n            else {\n                return this._instances.set(id, new ng_gallery_GalleryRef(Object.assign(Object.assign({}, this.config), config), this.deleteInstance(id))).get(id);\n            }\n        }\n        /**\n         * Destroy all gallery instances\n         */\n        destroyAll() {\n            this._instances.forEach((ref) => ref.destroy());\n        }\n        /**\n         * Reset all gallery instances\n         */\n        resetAll() {\n            this._instances.forEach((ref) => ref.reset());\n        }\n        /**\n         * A destroyer function for each gallery instance\n         */\n        deleteInstance(id) {\n            return () => {\n                if (this._instances.has(id)) {\n                    this._instances.delete(id);\n                }\n            };\n        }\n    }\n    Gallery.ɵfac = function Gallery_Factory(t) { return new (t || Gallery)(core[\"Zb\" /* ɵɵinject */](GALLERY_CONFIG, 8)); };\n    Gallery.ɵprov = Object(core[\"Lb\" /* ɵɵdefineInjectable */])({ factory: function Gallery_Factory() { return new Gallery(Object(core[\"Zb\" /* ɵɵinject */])(GALLERY_CONFIG, 8)); }, token: Gallery, providedIn: \"root\" });\n    return Gallery;\n})();\nlet ng_gallery_GalleryComponent = /*@__PURE__*/ (() => {\n    class GalleryComponent {\n        constructor(_gallery) {\n            this._gallery = _gallery;\n            this.nav = this._gallery.config.nav;\n            this.dots = this._gallery.config.dots;\n            this.loop = this._gallery.config.loop;\n            this.thumb = this._gallery.config.thumb;\n            this.zoomOut = this._gallery.config.zoomOut;\n            this.counter = this._gallery.config.counter;\n            this.dotsSize = this._gallery.config.dotsSize;\n            this.autoPlay = this._gallery.config.autoPlay;\n            this.gestures = this._gallery.config.gestures;\n            this.thumbWidth = this._gallery.config.thumbWidth;\n            this.thumbHeight = this._gallery.config.thumbHeight;\n            this.disableThumb = this._gallery.config.disableThumb;\n            this.panSensitivity = this._gallery.config.panSensitivity;\n            this.playerInterval = this._gallery.config.playerInterval;\n            this.itemTemplate = this._gallery.config.itemTemplate;\n            this.thumbTemplate = this._gallery.config.thumbTemplate;\n            this.thumbMode = this._gallery.config.thumbMode;\n            this.imageSize = this._gallery.config.imageSize;\n            this.dotsPosition = this._gallery.config.dotsPosition;\n            this.counterPosition = this._gallery.config.counterPosition;\n            this.slidingDirection = this._gallery.config.slidingDirection;\n            this.loadingStrategy = this._gallery.config.loadingStrategy;\n            this.thumbPosition = this._gallery.config.thumbPosition;\n            // Inputs used by the lightbox\n            /** Destroy gallery ref on component destroy event */\n            this.destroyRef = true;\n            /** Skip initializing the config with components inputs (Lightbox mode) */\n            this.skipInitConfig = false;\n            this.itemClick = new core[\"o\" /* EventEmitter */]();\n            this.thumbClick = new core[\"o\" /* EventEmitter */]();\n            this.playingChange = new core[\"o\" /* EventEmitter */]();\n            this.indexChange = new core[\"o\" /* EventEmitter */]();\n            this.itemsChange = new core[\"o\" /* EventEmitter */]();\n            this.error = new core[\"o\" /* EventEmitter */]();\n            this._itemClick$ = Subscription[\"a\" /* Subscription */].EMPTY;\n            this._thumbClick$ = Subscription[\"a\" /* Subscription */].EMPTY;\n            this._itemChange$ = Subscription[\"a\" /* Subscription */].EMPTY;\n            this._indexChange$ = Subscription[\"a\" /* Subscription */].EMPTY;\n            this._playingChange$ = Subscription[\"a\" /* Subscription */].EMPTY;\n            this._playerListener$ = Subscription[\"a\" /* Subscription */].EMPTY;\n        }\n        getConfig() {\n            return {\n                nav: this.nav,\n                dots: this.dots,\n                loop: this.loop,\n                thumb: this.thumb,\n                zoomOut: this.zoomOut,\n                counter: this.counter,\n                autoPlay: this.autoPlay,\n                gestures: this.gestures,\n                dotsSize: this.dotsSize,\n                imageSize: this.imageSize,\n                thumbMode: this.thumbMode,\n                thumbWidth: this.thumbWidth,\n                thumbHeight: this.thumbHeight,\n                disableThumb: this.disableThumb,\n                dotsPosition: this.dotsPosition,\n                itemTemplate: this.itemTemplate,\n                thumbTemplate: this.thumbTemplate,\n                thumbPosition: this.thumbPosition,\n                panSensitivity: this.panSensitivity,\n                playerInterval: this.playerInterval,\n                counterPosition: this.counterPosition,\n                loadingStrategy: this.loadingStrategy,\n                slidingDirection: this.slidingDirection\n            };\n        }\n        onAction(i) {\n            switch (i) {\n                case 'next':\n                    this.galleryRef.next();\n                    break;\n                case 'prev':\n                    this.galleryRef.prev();\n                    break;\n                default:\n                    this.galleryRef.set(i);\n            }\n        }\n        ngOnChanges(changes) {\n            if (this.galleryRef) {\n                this.galleryRef.setConfig(this.getConfig());\n                if (changes.items && changes.items.currentValue !== changes.items.previousValue) {\n                    this.load(this.items);\n                }\n            }\n        }\n        ngOnInit() {\n            // Get gallery instance by id\n            if (this.skipInitConfig) {\n                this.galleryRef = this._gallery.ref(this.id);\n            }\n            else {\n                this.galleryRef = this._gallery.ref(this.id, this.getConfig());\n            }\n            // Load gallery items\n            this.load(this.items);\n            // Activate player listener\n            this._playerListener$ = this.galleryRef.activatePlayer().subscribe();\n            // Subscribes to events on demand\n            if (this.indexChange.observers.length) {\n                this._indexChange$ = this.galleryRef.indexChanged.subscribe((state) => this.indexChange.emit(state));\n            }\n            if (this.itemsChange.observers.length) {\n                this._itemChange$ = this.galleryRef.itemsChanged.subscribe((state) => this.itemsChange.emit(state));\n            }\n            if (this.playingChange.observers.length) {\n                this._playingChange$ = this.galleryRef.playingChanged.subscribe((state) => this.playingChange.emit(state));\n            }\n            // Start playing if auto-play is set to true\n            if (this.autoPlay) {\n                this.play();\n            }\n        }\n        ngOnDestroy() {\n            this._itemClick$.unsubscribe();\n            this._thumbClick$.unsubscribe();\n            this._itemChange$.unsubscribe();\n            this._indexChange$.unsubscribe();\n            this._playingChange$.unsubscribe();\n            this._playerListener$.unsubscribe();\n            if (this.destroyRef) {\n                this.galleryRef.destroy();\n            }\n        }\n        onItemClick(i) {\n            this.itemClick.emit(i);\n            this.galleryRef.itemClick.next(i);\n        }\n        onThumbClick(i) {\n            this.galleryRef.set(i);\n            this.thumbClick.emit(i);\n            this.galleryRef.thumbClick.next(i);\n        }\n        onError(err) {\n            this.error.emit(err);\n            this.galleryRef.error.next(err);\n        }\n        load(items) {\n            this.galleryRef.load(items);\n        }\n        add(item, active) {\n            this.galleryRef.add(item, active);\n        }\n        addImage(data, active) {\n            this.add(new ImageItem(data), active);\n        }\n        addVideo(data, active) {\n            this.add(new VideoItem(data), active);\n        }\n        addIframe(data, active) {\n            this.add(new IframeItem(data), active);\n        }\n        addYoutube(data, active) {\n            this.add(new YoutubeItem(data), active);\n        }\n        remove(i) {\n            this.galleryRef.remove(i);\n        }\n        next() {\n            this.galleryRef.next();\n        }\n        prev() {\n            this.galleryRef.prev();\n        }\n        set(i) {\n            this.galleryRef.set(i);\n        }\n        reset() {\n            this.galleryRef.reset();\n        }\n        play(interval) {\n            this.galleryRef.play(interval);\n        }\n        stop() {\n            this.galleryRef.stop();\n        }\n    }\n    GalleryComponent.ɵfac = function GalleryComponent_Factory(t) { return new (t || GalleryComponent)(core[\"Pb\" /* ɵɵdirectiveInject */](ng_gallery_Gallery)); };\n    GalleryComponent.ɵcmp = core[\"Jb\" /* ɵɵdefineComponent */]({ type: GalleryComponent, selectors: [[\"gallery\"]], inputs: { nav: \"nav\", dots: \"dots\", loop: \"loop\", thumb: \"thumb\", zoomOut: \"zoomOut\", counter: \"counter\", dotsSize: \"dotsSize\", autoPlay: \"autoPlay\", gestures: \"gestures\", thumbWidth: \"thumbWidth\", thumbHeight: \"thumbHeight\", disableThumb: \"disableThumb\", panSensitivity: \"panSensitivity\", playerInterval: \"playerInterval\", itemTemplate: \"itemTemplate\", thumbTemplate: \"thumbTemplate\", thumbMode: \"thumbMode\", imageSize: \"imageSize\", dotsPosition: \"dotsPosition\", counterPosition: \"counterPosition\", slidingDirection: \"slidingDirection\", loadingStrategy: \"loadingStrategy\", thumbPosition: \"thumbPosition\", destroyRef: \"destroyRef\", skipInitConfig: \"skipInitConfig\", id: \"id\", items: \"items\" }, outputs: { itemClick: \"itemClick\", thumbClick: \"thumbClick\", playingChange: \"playingChange\", indexChange: \"indexChange\", itemsChange: \"itemsChange\", error: \"error\" }, features: [core[\"Bb\" /* ɵɵNgOnChangesFeature */]], ngContentSelectors: _c0, decls: 4, vars: 6, consts: [[3, \"state\", \"config\", \"action\", \"itemClick\", \"thumbClick\", \"error\"]], template: function GalleryComponent_Template(rf, ctx) {\n            if (rf & 1) {\n                core[\"kc\" /* ɵɵprojectionDef */]();\n                core[\"Vb\" /* ɵɵelementStart */](0, \"gallery-core\", 0);\n                core[\"dc\" /* ɵɵlistener */](\"action\", function GalleryComponent_Template_gallery_core_action_0_listener($event) { return ctx.onAction($event); })(\"itemClick\", function GalleryComponent_Template_gallery_core_itemClick_0_listener($event) { return ctx.onItemClick($event); })(\"thumbClick\", function GalleryComponent_Template_gallery_core_thumbClick_0_listener($event) { return ctx.onThumbClick($event); })(\"error\", function GalleryComponent_Template_gallery_core_error_0_listener($event) { return ctx.onError($event); });\n                core[\"gc\" /* ɵɵpipe */](1, \"async\");\n                core[\"gc\" /* ɵɵpipe */](2, \"async\");\n                core[\"Ub\" /* ɵɵelementEnd */]();\n                core[\"jc\" /* ɵɵprojection */](3);\n            }\n            if (rf & 2) {\n                core[\"lc\" /* ɵɵproperty */](\"state\", core[\"hc\" /* ɵɵpipeBind1 */](1, 2, ctx.galleryRef.state))(\"config\", core[\"hc\" /* ɵɵpipeBind1 */](2, 4, ctx.galleryRef.config));\n            }\n        }, directives: function () { return [ng_gallery_GalleryCoreComponent]; }, pipes: function () { return [common[\"b\" /* AsyncPipe */]]; }, styles: [\"gallery-core[dotsPosition=top] gallery-dots{top:0}  gallery-core[dotsPosition=bottom] gallery-dots{bottom:0}  gallery-dots{left:50%;margin:7px;position:absolute;transform:translateX(-50%)}  .g-dot{cursor:pointer;z-index:20}  .g-dot:hover .g-dot-inner{opacity:1}  .g-dot-active .g-dot-inner{opacity:1;transform:scale(1.5)!important}  .g-dot-inner{background-color:#fff;border-radius:50%;box-shadow:0 0 1px #000;height:30%;opacity:.6;transition:all .2s ease;width:30%}  .g-dot,   .g-dot-inner,   gallery-dots{align-items:center;display:flex;justify-content:center}  .g-nav-next,   .g-nav-prev{cursor:pointer;height:40px;position:absolute;top:50%;width:30px;z-index:999}  .g-nav-next{right:.5em;transform:translateY(-50%) perspective(1px)}  .g-nav-prev{left:.5em;transform:translateY(-50%) perspective(1px) scale(-1)}@media only screen and (max-width:480px){  .g-nav-next{right:.2em}  .g-nav-prev{left:.2em}}  .g-items-container{height:100%}  .g-slider{position:absolute;transition:transform .4s cubic-bezier(.5,0,.5,1)}  gallery-core[slidingDirection=horizontal] .g-slider{flex-direction:row}  gallery-core[slidingDirection=vertical] .g-slider{flex-direction:column}  gallery-thumbs{display:block;overflow:unset;z-index:1}  .g-thumbs-container{display:flex;height:100%;left:0;overflow:unset;position:relative;top:0;width:100%;z-index:206}  gallery-core[disableThumb=true] gallery-thumb{cursor:default}  gallery-core[thumbPosition=bottom] gallery-thumbs .g-slider,   gallery-core[thumbPosition=top] gallery-thumbs .g-slider{flex-direction:row;left:50%;top:0}  gallery-core[thumbPosition=bottom] gallery-thumb,   gallery-core[thumbPosition=top] gallery-thumb{padding:1px 0 1px 1px}  gallery-core[thumbPosition=left] gallery-thumbs .g-slider,   gallery-core[thumbPosition=right] gallery-thumbs .g-slider{flex-direction:column;left:0;top:50%}  gallery-core[thumbPosition=left] gallery-thumb,   gallery-core[thumbPosition=right] gallery-thumb{padding:0 1px 1px}  gallery-core[thumbPosition=top]{flex-direction:column}  gallery-core[thumbPosition=left]{flex-direction:row}  gallery-core[thumbPosition=right]{flex-direction:row-reverse}  gallery-core[thumbPosition=bottom]{flex-direction:column-reverse}  gallery-thumb.g-active-thumb .g-thumb-loading{background-color:#464646}  .g-thumb-loading{background-color:#262626;height:100%;overflow:hidden;position:relative}  .g-thumb-loading:before{-webkit-animation:phAnimation .8s linear infinite;animation:phAnimation .8s linear infinite;background:linear-gradient(90deg,hsla(0,0%,100%,0) 46%,hsla(0,0%,100%,.35) 50%,hsla(0,0%,100%,0) 54%) 50% 50%;bottom:0;content:\\\"\\\";left:50%;margin-left:-250%;position:absolute;right:0;top:0;width:500%;z-index:1}@-webkit-keyframes phAnimation{0%{transform:translate3d(-30%,0,0)}to{transform:translate3d(30%,0,0)}}@keyframes phAnimation{0%{transform:translate3d(-30%,0,0)}to{transform:translate3d(30%,0,0)}}  gallery-core[counterPosition=top] .g-counter{border-bottom-left-radius:4px;border-bottom-right-radius:4px;top:0}  gallery-core[counterPosition=bottom] .g-counter{border-top-left-radius:4px;border-top-right-radius:4px;bottom:0}  .g-counter{background-color:rgba(0,0,0,.5);color:#fff;font-size:12px;left:50%;padding:4px 10px;position:absolute;transform:translateX(-50%) perspective(1px);z-index:50}  gallery[gallerize] gallery-item{cursor:pointer}  gallery-item,   gallery-thumb{display:block;height:100%;overflow:hidden;position:relative;width:100%}  gallery-item h2,   gallery-item h4,   gallery-thumb h2,   gallery-thumb h4{color:coral;margin:0}  gallery-item h2,   gallery-thumb h2{font-size:3.5em;margin-bottom:.3em}  gallery-item h4,   gallery-thumb h4{font-size:1.6em}  gallery-item{z-index:10}  gallery-item iframe,   gallery-item video{height:100%;position:absolute;width:100%}  gallery-thumb{cursor:pointer;opacity:.5;transition:opacity .3s cubic-bezier(.5,0,.5,1)}  gallery-thumb.g-active-thumb{opacity:1}  .g-image-item{background-position:50%;background-repeat:no-repeat;background-size:cover;height:100%;width:100%}  .g-image-error-message,   .g-template{align-items:center;bottom:0;color:#fff;display:flex;flex-direction:column;justify-content:center;left:0;position:absolute;right:0;top:0;z-index:10}  .g-loading{height:80px;left:50%;position:absolute;top:50%;transform:translate3d(-50%,-50%,0);width:80px}  gallery-core[imageSize=contain] gallery-slider .g-image-item{background-size:contain}  gallery-image{align-items:center;display:flex;height:100%;justify-content:center}  gallery{background-color:#000;display:block;height:500px;overflow:hidden;position:relative;z-index:1}  gallery *{box-sizing:border-box}  gallery,   gallery-core{overflow:hidden;position:relative}  .g-box,   .g-slider,   gallery-core{display:flex;height:100%;width:100%}  gallery[fluid]{left:50%;transform:translateX(-50vw);width:100vw}  gallery[fluid][fluid=false]{left:auto;transform:none;width:auto}  .g-no-transition{transition:unset!important}  .g-box,   gallery-slider{display:flex;flex:1;flex-direction:column;height:100%;order:1;overflow:hidden;position:relative}  .g-btn-close svg,   gallery-nav svg{-webkit-filter:drop-shadow(0 0 1px #000);filter:drop-shadow(0 0 1px black);height:100%;opacity:.6;transition:opacity .2s linear;width:100%}  .g-btn-close svg:hover,   gallery-nav svg:hover{opacity:1}\"], changeDetection: 0 });\n    return GalleryComponent;\n})();\nlet ng_gallery_GalleryIframeComponent = /*@__PURE__*/ (() => {\n    class GalleryIframeComponent {\n        constructor(_sanitizer) {\n            this._sanitizer = _sanitizer;\n        }\n        set src(src) {\n            this.iframeSrc = this._sanitizer.bypassSecurityTrustResourceUrl(src);\n        }\n        set pauseVideo(shouldPause) {\n            if (this.iframe.nativeElement) {\n                if (shouldPause) {\n                    const iframe = this.iframe.nativeElement;\n                    iframe.src = null;\n                }\n            }\n        }\n    }\n    GalleryIframeComponent.ɵfac = function GalleryIframeComponent_Factory(t) { return new (t || GalleryIframeComponent)(core[\"Pb\" /* ɵɵdirectiveInject */](platform_browser[\"b\" /* DomSanitizer */])); };\n    GalleryIframeComponent.ɵcmp = core[\"Jb\" /* ɵɵdefineComponent */]({ type: GalleryIframeComponent, selectors: [[\"gallery-iframe\"]], viewQuery: function GalleryIframeComponent_Query(rf, ctx) {\n            if (rf & 1) {\n                core[\"Kc\" /* ɵɵviewQuery */](_c1, 3);\n            }\n            if (rf & 2) {\n                let _t;\n                core[\"tc\" /* ɵɵqueryRefresh */](_t = core[\"ec\" /* ɵɵloadQuery */]()) && (ctx.iframe = _t.first);\n            }\n        }, inputs: { src: \"src\", pauseVideo: [\"pause\", \"pauseVideo\"], autoplay: \"autoplay\" }, decls: 2, vars: 2, consts: [[\"frameborder\", \"0\", \"allowfullscreen\", \"\", 3, \"src\"], [\"iframe\", \"\"]], template: function GalleryIframeComponent_Template(rf, ctx) {\n            if (rf & 1) {\n                core[\"Qb\" /* ɵɵelement */](0, \"iframe\", 0, 1);\n            }\n            if (rf & 2) {\n                core[\"lc\" /* ɵɵproperty */](\"src\", ctx.iframeSrc, core[\"xc\" /* ɵɵsanitizeResourceUrl */]);\n                core[\"Eb\" /* ɵɵattribute */](\"allow\", ctx.autoplay ? \"autoplay\" : \"\");\n            }\n        }, encapsulation: 2, changeDetection: 0 });\n    return GalleryIframeComponent;\n})();\nlet ng_gallery_GalleryImageComponent = /*@__PURE__*/ (() => {\n    class GalleryImageComponent {\n        constructor(_sanitizer) {\n            this._sanitizer = _sanitizer;\n            /** Stream that emits the state */\n            this._state = new BehaviorSubject[\"a\" /* BehaviorSubject */]('loading');\n            this.state = this._state.asObservable();\n            /** Progress value */\n            this.progress = 0;\n            /** Stream that emits when an error occurs */\n            this.error = new core[\"o\" /* EventEmitter */]();\n        }\n        get imageLoadSuccess() {\n            return !!this.imageUrl;\n        }\n        get imageLoadFailed() {\n            return !!this.loadError;\n        }\n        ngOnInit() {\n            if (this.loadingIcon) {\n                this.loaderTemplate = this._sanitizer.bypassSecurityTrustHtml(this.loadingIcon);\n            }\n            if (this.loadingError) {\n                this.errorTemplate = this._sanitizer.bypassSecurityTrustHtml(this.loadingError);\n            }\n        }\n        ngOnDestroy() {\n            this._state.complete();\n        }\n        onProgress({ loaded, total }) {\n            this.progress = loaded * 100 / total;\n        }\n        onLoaded(blobUrl) {\n            this.imageUrl = this._sanitizer.bypassSecurityTrustStyle(`url(\"${blobUrl}\")`);\n            this._state.next('success');\n        }\n        onError(err) {\n            this.loadError = err;\n            this._state.next('failed');\n            this.error.emit(err);\n        }\n    }\n    GalleryImageComponent.ɵfac = function GalleryImageComponent_Factory(t) { return new (t || GalleryImageComponent)(core[\"Pb\" /* ɵɵdirectiveInject */](platform_browser[\"b\" /* DomSanitizer */])); };\n    GalleryImageComponent.ɵcmp = core[\"Jb\" /* ɵɵdefineComponent */]({ type: GalleryImageComponent, selectors: [[\"gallery-image\"]], hostVars: 4, hostBindings: function GalleryImageComponent_HostBindings(rf, ctx) {\n            if (rf & 2) {\n                core[\"Hb\" /* ɵɵclassProp */](\"g-image-loaded\", ctx.imageLoadSuccess)(\"g-image-error\", ctx.imageLoadFailed);\n            }\n        }, inputs: { isThumbnail: \"isThumbnail\", src: \"src\", loadingIcon: \"loadingIcon\", loadingError: \"loadingError\" }, outputs: { error: \"error\" }, decls: 5, vars: 7, consts: [[3, \"lazyImage\", \"ngSwitch\", \"progress\", \"loaded\", \"error\"], [\"class\", \"g-image-item\", 3, \"backgroundImage\", 4, \"ngSwitchCase\"], [\"class\", \"g-image-error-message\", 4, \"ngSwitchCase\"], [4, \"ngSwitchCase\"], [1, \"g-image-item\"], [1, \"g-image-error-message\"], [3, \"innerHTML\", 4, \"ngIf\", \"ngIfElse\"], [\"defaultError\", \"\"], [3, \"innerHTML\"], [4, \"ngIf\", \"ngIfElse\"], [\"isLarge\", \"\"], [\"class\", \"g-loading\", 3, \"innerHTML\", 4, \"ngIf\", \"ngIfElse\"], [\"defaultLoader\", \"\"], [1, \"g-loading\", 3, \"innerHTML\"], [\"class\", \"g-thumb-loading\", 4, \"ngIf\"], [1, \"g-thumb-loading\"]], template: function GalleryImageComponent_Template(rf, ctx) {\n            if (rf & 1) {\n                core[\"Tb\" /* ɵɵelementContainerStart */](0, 0);\n                core[\"dc\" /* ɵɵlistener */](\"progress\", function GalleryImageComponent_Template_ng_container_progress_0_listener($event) { return ctx.onProgress($event); })(\"loaded\", function GalleryImageComponent_Template_ng_container_loaded_0_listener($event) { return ctx.onLoaded($event); })(\"error\", function GalleryImageComponent_Template_ng_container_error_0_listener($event) { return ctx.onError($event); });\n                core[\"gc\" /* ɵɵpipe */](1, \"async\");\n                core[\"Ec\" /* ɵɵtemplate */](2, GalleryImageComponent_div_2_Template, 1, 3, \"div\", 1);\n                core[\"Ec\" /* ɵɵtemplate */](3, GalleryImageComponent_div_3_Template, 4, 2, \"div\", 2);\n                core[\"Ec\" /* ɵɵtemplate */](4, GalleryImageComponent_ng_container_4_Template, 4, 2, \"ng-container\", 3);\n                core[\"Sb\" /* ɵɵelementContainerEnd */]();\n            }\n            if (rf & 2) {\n                core[\"lc\" /* ɵɵproperty */](\"lazyImage\", ctx.src)(\"ngSwitch\", core[\"hc\" /* ɵɵpipeBind1 */](1, 5, ctx.state));\n                core[\"Db\" /* ɵɵadvance */](2);\n                core[\"lc\" /* ɵɵproperty */](\"ngSwitchCase\", \"success\");\n                core[\"Db\" /* ɵɵadvance */](1);\n                core[\"lc\" /* ɵɵproperty */](\"ngSwitchCase\", \"failed\");\n                core[\"Db\" /* ɵɵadvance */](1);\n                core[\"lc\" /* ɵɵproperty */](\"ngSwitchCase\", \"loading\");\n            }\n        }, directives: function () { return [ng_gallery_LazyImage, common[\"o\" /* NgSwitch */], common[\"p\" /* NgSwitchCase */], common[\"m\" /* NgIf */]]; }, pipes: function () { return [common[\"b\" /* AsyncPipe */]]; }, encapsulation: 2, data: { animation: [\n                Object(animations[\"l\" /* trigger */])('fadeIn', [\n                    Object(animations[\"k\" /* transition */])(':enter', [\n                        Object(animations[\"j\" /* style */])({ opacity: 0 }),\n                        Object(animations[\"e\" /* animate */])('300ms ease-in', Object(animations[\"j\" /* style */])({ opacity: 1 }))\n                    ])\n                ])\n            ] }, changeDetection: 0 });\n    return GalleryImageComponent;\n})();\nlet ng_gallery_GalleryVideoComponent = /*@__PURE__*/ (() => {\n    class GalleryVideoComponent {\n        constructor() {\n            /** Stream that emits when an error occurs */\n            this.error = new core[\"o\" /* EventEmitter */]();\n        }\n        set pauseVideo(shouldPause) {\n            if (this.video.nativeElement) {\n                const video = this.video.nativeElement;\n                if (shouldPause && !video.paused) {\n                    video.pause();\n                }\n            }\n        }\n        set playVideo(shouldPlay) {\n            if (this.video.nativeElement) {\n                const video = this.video.nativeElement;\n                if (shouldPlay) {\n                    video.play();\n                }\n            }\n        }\n        ngOnInit() {\n            if (this.src instanceof Array) {\n                // If video has multiple sources\n                this.videoSources = [...this.src];\n            }\n            else {\n                this.videoSources = [{ url: this.src }];\n            }\n            this.controls = typeof this.controlsEnabled === 'boolean' ? this.controlsEnabled : true;\n        }\n    }\n    GalleryVideoComponent.ɵfac = function GalleryVideoComponent_Factory(t) { return new (t || GalleryVideoComponent)(); };\n    GalleryVideoComponent.ɵcmp = core[\"Jb\" /* ɵɵdefineComponent */]({ type: GalleryVideoComponent, selectors: [[\"gallery-video\"]], viewQuery: function GalleryVideoComponent_Query(rf, ctx) {\n            if (rf & 1) {\n                core[\"Kc\" /* ɵɵviewQuery */](_c2, 3);\n            }\n            if (rf & 2) {\n                let _t;\n                core[\"tc\" /* ɵɵqueryRefresh */](_t = core[\"ec\" /* ɵɵloadQuery */]()) && (ctx.video = _t.first);\n            }\n        }, inputs: { pauseVideo: [\"pause\", \"pauseVideo\"], playVideo: [\"play\", \"playVideo\"], src: \"src\", poster: \"poster\", controlsEnabled: [\"controls\", \"controlsEnabled\"] }, outputs: { error: \"error\" }, decls: 3, vars: 3, consts: [[3, \"controls\", \"poster\", \"error\"], [\"video\", \"\"], [3, \"src\", \"type\", 4, \"ngFor\", \"ngForOf\"], [3, \"src\", \"type\"]], template: function GalleryVideoComponent_Template(rf, ctx) {\n            if (rf & 1) {\n                core[\"Vb\" /* ɵɵelementStart */](0, \"video\", 0, 1);\n                core[\"dc\" /* ɵɵlistener */](\"error\", function GalleryVideoComponent_Template_video_error_0_listener($event) { return ctx.error.emit($event); });\n                core[\"Ec\" /* ɵɵtemplate */](2, GalleryVideoComponent_source_2_Template, 1, 2, \"source\", 2);\n                core[\"Ub\" /* ɵɵelementEnd */]();\n            }\n            if (rf & 2) {\n                core[\"lc\" /* ɵɵproperty */](\"controls\", ctx.controls)(\"poster\", ctx.poster, core[\"zc\" /* ɵɵsanitizeUrl */]);\n                core[\"Db\" /* ɵɵadvance */](2);\n                core[\"lc\" /* ɵɵproperty */](\"ngForOf\", ctx.videoSources);\n            }\n        }, directives: [common[\"l\" /* NgForOf */]], encapsulation: 2, changeDetection: 0 });\n    return GalleryVideoComponent;\n})();\nlet ng_gallery_GalleryNavComponent = /*@__PURE__*/ (() => {\n    class GalleryNavComponent {\n        constructor(_sanitizer) {\n            this._sanitizer = _sanitizer;\n            this.action = new core[\"o\" /* EventEmitter */]();\n        }\n        ngOnInit() {\n            this.navIcon = this._sanitizer.bypassSecurityTrustHtml(this.config.navIcon);\n        }\n    }\n    GalleryNavComponent.ɵfac = function GalleryNavComponent_Factory(t) { return new (t || GalleryNavComponent)(core[\"Pb\" /* ɵɵdirectiveInject */](platform_browser[\"b\" /* DomSanitizer */])); };\n    GalleryNavComponent.ɵcmp = core[\"Jb\" /* ɵɵdefineComponent */]({ type: GalleryNavComponent, selectors: [[\"gallery-nav\"]], inputs: { state: \"state\", config: \"config\" }, outputs: { action: \"action\" }, decls: 2, vars: 2, consts: [[\"class\", \"g-nav-prev\", \"aria-label\", \"Previous\", 3, \"innerHtml\", \"tapClick\", 4, \"ngIf\"], [\"class\", \"g-nav-next\", \"aria-label\", \"Next\", 3, \"innerHtml\", \"tapClick\", 4, \"ngIf\"], [\"aria-label\", \"Previous\", 1, \"g-nav-prev\", 3, \"innerHtml\", \"tapClick\"], [\"aria-label\", \"Next\", 1, \"g-nav-next\", 3, \"innerHtml\", \"tapClick\"]], template: function GalleryNavComponent_Template(rf, ctx) {\n            if (rf & 1) {\n                core[\"Ec\" /* ɵɵtemplate */](0, GalleryNavComponent_i_0_Template, 1, 1, \"i\", 0);\n                core[\"Ec\" /* ɵɵtemplate */](1, GalleryNavComponent_i_1_Template, 1, 1, \"i\", 1);\n            }\n            if (rf & 2) {\n                core[\"lc\" /* ɵɵproperty */](\"ngIf\", ctx.config.loop || ctx.state.hasPrev);\n                core[\"Db\" /* ɵɵadvance */](1);\n                core[\"lc\" /* ɵɵproperty */](\"ngIf\", ctx.config.loop || ctx.state.hasNext);\n            }\n        }, directives: function () { return [common[\"m\" /* NgIf */], ng_gallery_TapClick]; }, encapsulation: 2, changeDetection: 0 });\n    return GalleryNavComponent;\n})();\nlet ng_gallery_GalleryCoreComponent = /*@__PURE__*/ (() => {\n    class GalleryCoreComponent {\n        constructor() {\n            this.action = new core[\"o\" /* EventEmitter */]();\n            this.itemClick = new core[\"o\" /* EventEmitter */]();\n            this.thumbClick = new core[\"o\" /* EventEmitter */]();\n            this.error = new core[\"o\" /* EventEmitter */]();\n        }\n        /** Set thumbnails position */\n        get thumbPosition() {\n            return this.config.thumbPosition;\n        }\n        /** Set sliding direction */\n        get slidingDirection() {\n            return this.config.slidingDirection;\n        }\n        /** Disable thumbnails clicks */\n        get disableThumb() {\n            return this.config.disableThumb;\n        }\n        /** Set gallery image size */\n        get imageSize() {\n            return this.config.imageSize;\n        }\n        /** Set gallery dots position */\n        get dotsPosition() {\n            return this.config.dotsPosition;\n        }\n        /** Set gallery counter position */\n        get counterPosition() {\n            return this.config.counterPosition;\n        }\n    }\n    GalleryCoreComponent.ɵfac = function GalleryCoreComponent_Factory(t) { return new (t || GalleryCoreComponent)(); };\n    GalleryCoreComponent.ɵcmp = core[\"Jb\" /* ɵɵdefineComponent */]({ type: GalleryCoreComponent, selectors: [[\"gallery-core\"]], hostVars: 6, hostBindings: function GalleryCoreComponent_HostBindings(rf, ctx) {\n            if (rf & 2) {\n                core[\"Eb\" /* ɵɵattribute */](\"thumbPosition\", ctx.thumbPosition)(\"slidingDirection\", ctx.slidingDirection)(\"disableThumb\", ctx.disableThumb)(\"imageSize\", ctx.imageSize)(\"dotsPosition\", ctx.dotsPosition)(\"counterPosition\", ctx.counterPosition);\n            }\n        }, inputs: { state: \"state\", config: \"config\" }, outputs: { action: \"action\", itemClick: \"itemClick\", thumbClick: \"thumbClick\", error: \"error\" }, decls: 6, vars: 6, consts: [[3, \"state\", \"config\", \"action\", \"thumbClick\", 4, \"ngIf\"], [1, \"g-box\"], [3, \"state\", \"config\", \"action\", \"itemClick\", \"error\"], [3, \"state\", \"config\", \"action\", 4, \"ngIf\"], [3, \"state\", 4, \"ngIf\"], [3, \"state\", \"config\", \"action\", \"thumbClick\"], [3, \"state\", \"config\", \"action\"], [3, \"state\"]], template: function GalleryCoreComponent_Template(rf, ctx) {\n            if (rf & 1) {\n                core[\"Ec\" /* ɵɵtemplate */](0, GalleryCoreComponent_gallery_thumbs_0_Template, 1, 2, \"gallery-thumbs\", 0);\n                core[\"Vb\" /* ɵɵelementStart */](1, \"div\", 1);\n                core[\"Vb\" /* ɵɵelementStart */](2, \"gallery-slider\", 2);\n                core[\"dc\" /* ɵɵlistener */](\"action\", function GalleryCoreComponent_Template_gallery_slider_action_2_listener($event) { return ctx.action.emit($event); })(\"itemClick\", function GalleryCoreComponent_Template_gallery_slider_itemClick_2_listener($event) { return ctx.itemClick.emit($event); })(\"error\", function GalleryCoreComponent_Template_gallery_slider_error_2_listener($event) { return ctx.error.emit($event); });\n                core[\"Ec\" /* ɵɵtemplate */](3, GalleryCoreComponent_gallery_nav_3_Template, 1, 2, \"gallery-nav\", 3);\n                core[\"Ub\" /* ɵɵelementEnd */]();\n                core[\"Ec\" /* ɵɵtemplate */](4, GalleryCoreComponent_gallery_dots_4_Template, 1, 2, \"gallery-dots\", 3);\n                core[\"Ec\" /* ɵɵtemplate */](5, GalleryCoreComponent_gallery_counter_5_Template, 1, 1, \"gallery-counter\", 4);\n                core[\"Ub\" /* ɵɵelementEnd */]();\n            }\n            if (rf & 2) {\n                core[\"lc\" /* ɵɵproperty */](\"ngIf\", ctx.config.thumb);\n                core[\"Db\" /* ɵɵadvance */](2);\n                core[\"lc\" /* ɵɵproperty */](\"state\", ctx.state)(\"config\", ctx.config);\n                core[\"Db\" /* ɵɵadvance */](1);\n                core[\"lc\" /* ɵɵproperty */](\"ngIf\", ctx.config.nav && ctx.state.items.length > 1);\n                core[\"Db\" /* ɵɵadvance */](1);\n                core[\"lc\" /* ɵɵproperty */](\"ngIf\", ctx.config.dots);\n                core[\"Db\" /* ɵɵadvance */](1);\n                core[\"lc\" /* ɵɵproperty */](\"ngIf\", ctx.config.counter);\n            }\n        }, directives: function () { return [common[\"m\" /* NgIf */], ng_gallery_GallerySliderComponent, ng_gallery_GalleryThumbsComponent, ng_gallery_GalleryNavComponent, ng_gallery_GalleryDotsComponent, ng_gallery_GalleryCounterComponent]; }, encapsulation: 2, changeDetection: 0 });\n    return GalleryCoreComponent;\n})();\nlet ng_gallery_GalleryDotsComponent = /*@__PURE__*/ (() => {\n    class GalleryDotsComponent {\n        constructor() {\n            this.action = new core[\"o\" /* EventEmitter */]();\n        }\n    }\n    GalleryDotsComponent.ɵfac = function GalleryDotsComponent_Factory(t) { return new (t || GalleryDotsComponent)(); };\n    GalleryDotsComponent.ɵcmp = core[\"Jb\" /* ɵɵdefineComponent */]({ type: GalleryDotsComponent, selectors: [[\"gallery-dots\"]], inputs: { state: \"state\", config: \"config\" }, outputs: { action: \"action\" }, decls: 1, vars: 1, consts: [[\"class\", \"g-dot\", 3, \"g-dot-active\", \"width\", \"height\", \"tapClick\", 4, \"ngFor\", \"ngForOf\"], [1, \"g-dot\", 3, \"tapClick\"], [1, \"g-dot-inner\"]], template: function GalleryDotsComponent_Template(rf, ctx) {\n            if (rf & 1) {\n                core[\"Ec\" /* ɵɵtemplate */](0, GalleryDotsComponent_div_0_Template, 2, 6, \"div\", 0);\n            }\n            if (rf & 2) {\n                core[\"lc\" /* ɵɵproperty */](\"ngForOf\", ctx.state.items);\n            }\n        }, directives: function () { return [common[\"l\" /* NgForOf */], ng_gallery_TapClick]; }, encapsulation: 2, changeDetection: 0 });\n    return GalleryDotsComponent;\n})();\nlet ng_gallery_GalleryThumbsComponent = /*@__PURE__*/ (() => {\n    class GalleryThumbsComponent {\n        constructor(_el, _zone) {\n            this._el = _el;\n            this._zone = _zone;\n            /** Sliding worker */\n            this._slidingWorker$ = new BehaviorSubject[\"a\" /* BehaviorSubject */]({ value: 0, active: false });\n            /** Current slider position in free sliding mode */\n            this._freeModeCurrentOffset = 0;\n            /** Stream that emits when the active item should change */\n            this.action = new core[\"o\" /* EventEmitter */]();\n            /** Stream that emits when thumb is clicked */\n            this.thumbClick = new core[\"o\" /* EventEmitter */]();\n            /** Stream that emits when an error occurs */\n            this.error = new core[\"o\" /* EventEmitter */]();\n            // Activate sliding worker\n            this.sliderState$ = this._slidingWorker$.pipe(Object(map[\"a\" /* map */])((state) => ({\n                style: this.getSliderStyles(state),\n                active: state.active\n            })));\n        }\n        ngOnChanges() {\n            // Refresh the slider\n            this.updateSlider({ value: 0, active: false });\n            this._freeModeCurrentOffset = 0;\n        }\n        ngOnInit() {\n            if (this.config.gestures && !this.config.disableThumb && typeof Hammer !== 'undefined') {\n                let direction;\n                switch (this.config.thumbPosition) {\n                    case ThumbnailsPosition.Right:\n                    case ThumbnailsPosition.Left:\n                        direction = Hammer.DIRECTION_VERTICAL;\n                        break;\n                    case ThumbnailsPosition.Top:\n                    case ThumbnailsPosition.Bottom:\n                        direction = Hammer.DIRECTION_HORIZONTAL;\n                        break;\n                }\n                // Activate gestures\n                this._hammer = new Hammer(this._el.nativeElement);\n                this._hammer.get('pan').set({ direction });\n                this._zone.runOutsideAngular(() => {\n                    // Move the slider\n                    switch (this.config.thumbMode) {\n                        case ThumbnailsMode.Strict:\n                            this._hammer.on('pan', (e) => this.strictMode(e));\n                            break;\n                        case ThumbnailsMode.Free:\n                            this._hammer.on('pan', (e) => this.freeMode(e));\n                    }\n                });\n            }\n        }\n        ngOnDestroy() {\n            if (this._hammer) {\n                this._hammer.destroy();\n            }\n        }\n        /**\n         * Sliding strict mode\n         */\n        strictMode(e) {\n            switch (this.config.thumbPosition) {\n                case ThumbnailsPosition.Right:\n                case ThumbnailsPosition.Left:\n                    this.updateSlider({ value: e.deltaY, active: true });\n                    if (e.isFinal) {\n                        this.updateSlider({ value: 0, active: false });\n                        this.verticalPan(e);\n                    }\n                    break;\n                case ThumbnailsPosition.Top:\n                case ThumbnailsPosition.Bottom:\n                    this.updateSlider({ value: e.deltaX, active: true });\n                    if (e.isFinal) {\n                        this.updateSlider({ value: 0, active: false });\n                        this.horizontalPan(e);\n                    }\n            }\n        }\n        /**\n         * Sliding free mode\n         */\n        freeMode(e) {\n            switch (this.config.thumbPosition) {\n                case ThumbnailsPosition.Right:\n                case ThumbnailsPosition.Left:\n                    this.updateSlider({ value: this._freeModeCurrentOffset + e.deltaY, active: true });\n                    if (e.isFinal) {\n                        if (this.minFreeScrollExceeded(e.deltaY, this.config.thumbWidth, this.config.thumbHeight)) {\n                            this._freeModeCurrentOffset = -(this.state.items.length - 1 - this.state.currIndex) * this.config.thumbHeight;\n                        }\n                        else if (this.maxFreeScrollExceeded(e.deltaY, this.config.thumbHeight, this.config.thumbWidth)) {\n                            this._freeModeCurrentOffset = this.state.currIndex * this.config.thumbHeight;\n                        }\n                        else {\n                            this._freeModeCurrentOffset += e.deltaY;\n                        }\n                        this.updateSlider({ value: this._freeModeCurrentOffset, active: false });\n                    }\n                    break;\n                case ThumbnailsPosition.Top:\n                case ThumbnailsPosition.Bottom:\n                    this.updateSlider({ value: this._freeModeCurrentOffset + e.deltaX, active: true });\n                    if (e.isFinal) {\n                        if (this.minFreeScrollExceeded(e.deltaX, this.config.thumbHeight, this.config.thumbWidth)) {\n                            this._freeModeCurrentOffset = -(this.state.items.length - 1 - this.state.currIndex) * this.config.thumbWidth;\n                        }\n                        else if (this.maxFreeScrollExceeded(e.deltaX, this.config.thumbWidth, this.config.thumbHeight)) {\n                            this._freeModeCurrentOffset = this.state.currIndex * this.config.thumbWidth;\n                        }\n                        else {\n                            this._freeModeCurrentOffset += e.deltaX;\n                        }\n                        this.updateSlider({ value: this._freeModeCurrentOffset, active: false });\n                    }\n            }\n        }\n        /**\n         * Check if the minimum free scroll is exceeded (used in Bottom, Left directions)\n         */\n        minFreeScrollExceeded(delta, width, height) {\n            return -(this._freeModeCurrentOffset + delta - width / 2) > (this.state.items.length - this.state.currIndex) * height;\n        }\n        /**\n         * Check if the maximum free scroll is exceeded (used in Top, Right directions)\n         */\n        maxFreeScrollExceeded(delta, width, height) {\n            return this._freeModeCurrentOffset + delta > (this.state.currIndex * width) + (height / 2);\n        }\n        /**\n         * Convert sliding state to styles\n         */\n        getSliderStyles(state) {\n            let value;\n            switch (this.config.thumbPosition) {\n                case ThumbnailsPosition.Top:\n                case ThumbnailsPosition.Bottom:\n                    this.width = '100%';\n                    this.height = this.config.thumbHeight + 'px';\n                    value = -(this.state.currIndex * this.config.thumbWidth) - (this.config.thumbWidth / 2 - state.value);\n                    return {\n                        transform: `translate3d(${value}px, 0, 0)`,\n                        width: this.state.items.length * this.config.thumbWidth + 'px',\n                        height: '100%'\n                    };\n                case ThumbnailsPosition.Left:\n                case ThumbnailsPosition.Right:\n                    this.width = this.config.thumbWidth + 'px';\n                    this.height = '100%';\n                    value = -(this.state.currIndex * this.config.thumbHeight) - (this.config.thumbHeight / 2 - state.value);\n                    return {\n                        transform: `translate3d(0, ${value}px, 0)`,\n                        width: '100%',\n                        height: this.state.items.length * this.config.thumbHeight + 'px'\n                    };\n            }\n        }\n        verticalPan(e) {\n            if (!(e.direction & Hammer.DIRECTION_UP && e.offsetDirection & Hammer.DIRECTION_VERTICAL)) {\n                return;\n            }\n            if (e.velocityY > 0.3) {\n                this.prev();\n            }\n            else if (e.velocityY < -0.3) {\n                this.next();\n            }\n            else {\n                if (e.deltaY / 2 <= -this.config.thumbHeight * this.state.items.length / this.config.panSensitivity) {\n                    this.next();\n                }\n                else if (e.deltaY / 2 >= this.config.thumbHeight * this.state.items.length / this.config.panSensitivity) {\n                    this.prev();\n                }\n                else {\n                    this.action.emit(this.state.currIndex);\n                }\n            }\n        }\n        horizontalPan(e) {\n            if (!(e.direction & Hammer.DIRECTION_HORIZONTAL && e.offsetDirection & Hammer.DIRECTION_HORIZONTAL)) {\n                return;\n            }\n            if (e.velocityX > 0.3) {\n                this.prev();\n            }\n            else if (e.velocityX < -0.3) {\n                this.next();\n            }\n            else {\n                if (e.deltaX / 2 <= -this.config.thumbWidth * this.state.items.length / this.config.panSensitivity) {\n                    this.next();\n                }\n                else if (e.deltaX / 2 >= this.config.thumbWidth * this.state.items.length / this.config.panSensitivity) {\n                    this.prev();\n                }\n                else {\n                    this.action.emit(this.state.currIndex);\n                }\n            }\n        }\n        next() {\n            this.action.emit('next');\n        }\n        prev() {\n            this.action.emit('prev');\n        }\n        updateSlider(state) {\n            const newState = Object.assign(Object.assign({}, this._slidingWorker$.value), state);\n            this._slidingWorker$.next(newState);\n        }\n    }\n    GalleryThumbsComponent.ɵfac = function GalleryThumbsComponent_Factory(t) { return new (t || GalleryThumbsComponent)(core[\"Pb\" /* ɵɵdirectiveInject */](core[\"m\" /* ElementRef */]), core[\"Pb\" /* ɵɵdirectiveInject */](core[\"B\" /* NgZone */])); };\n    GalleryThumbsComponent.ɵcmp = core[\"Jb\" /* ɵɵdefineComponent */]({ type: GalleryThumbsComponent, selectors: [[\"gallery-thumbs\"]], hostVars: 4, hostBindings: function GalleryThumbsComponent_HostBindings(rf, ctx) {\n            if (rf & 2) {\n                core[\"Bc\" /* ɵɵstyleProp */](\"width\", ctx.width)(\"height\", ctx.height);\n            }\n        }, inputs: { state: \"state\", config: \"config\" }, outputs: { action: \"action\", thumbClick: \"thumbClick\", error: \"error\" }, features: [core[\"Bb\" /* ɵɵNgOnChangesFeature */]], decls: 2, vars: 3, consts: [[\"class\", \"g-thumbs-container\", 4, \"ngIf\"], [1, \"g-thumbs-container\"], [1, \"g-slider\", 3, \"ngStyle\"], [3, \"type\", \"config\", \"data\", \"currIndex\", \"index\", \"tapClickDisabled\", \"tapClick\", \"error\", 4, \"ngFor\", \"ngForOf\"], [3, \"type\", \"config\", \"data\", \"currIndex\", \"index\", \"tapClickDisabled\", \"tapClick\", \"error\"]], template: function GalleryThumbsComponent_Template(rf, ctx) {\n            if (rf & 1) {\n                core[\"Ec\" /* ɵɵtemplate */](0, GalleryThumbsComponent_div_0_Template, 3, 4, \"div\", 0);\n                core[\"gc\" /* ɵɵpipe */](1, \"async\");\n            }\n            if (rf & 2) {\n                core[\"lc\" /* ɵɵproperty */](\"ngIf\", core[\"hc\" /* ɵɵpipeBind1 */](1, 1, ctx.sliderState$));\n            }\n        }, directives: function () { return [common[\"m\" /* NgIf */], common[\"n\" /* NgStyle */], common[\"l\" /* NgForOf */], ng_gallery_GalleryThumbComponent, ng_gallery_TapClick]; }, pipes: function () { return [common[\"b\" /* AsyncPipe */]]; }, encapsulation: 2, changeDetection: 0 });\n    return GalleryThumbsComponent;\n})();\nlet ng_gallery_GallerySliderComponent = /*@__PURE__*/ (() => {\n    class GallerySliderComponent {\n        constructor(_el, _zone, platform) {\n            this._el = _el;\n            this._zone = _zone;\n            this.platform = platform;\n            /** Sliding worker */\n            this._slidingWorker$ = new BehaviorSubject[\"a\" /* BehaviorSubject */]({ value: 0, active: false });\n            /** Stream that emits when the active item should change */\n            this.action = new core[\"o\" /* EventEmitter */]();\n            /** Stream that emits when item is clicked */\n            this.itemClick = new core[\"o\" /* EventEmitter */]();\n            /** Stream that emits when an error occurs */\n            this.error = new core[\"o\" /* EventEmitter */]();\n            // Activate sliding worker\n            this.sliderState$ = this._slidingWorker$.pipe(Object(map[\"a\" /* map */])((state) => ({\n                style: this.getSliderStyles(state),\n                active: state.active\n            })));\n        }\n        /** Item zoom */\n        get zoom() {\n            return { transform: `perspective(50px) translate3d(0, 0, ${-this.config.zoomOut}px)` };\n        }\n        ngOnChanges() {\n            // Refresh the slider\n            this.updateSlider({ value: 0, active: false });\n        }\n        ngOnInit() {\n            if (this.config.gestures && typeof Hammer !== 'undefined') {\n                const direction = this.config.slidingDirection === SlidingDirection.Horizontal\n                    ? Hammer.DIRECTION_HORIZONTAL\n                    : Hammer.DIRECTION_VERTICAL;\n                // Activate gestures\n                this._hammer = new Hammer(this._el.nativeElement);\n                this._hammer.get('pan').set({ direction });\n                this._zone.runOutsideAngular(() => {\n                    // Move the slider\n                    this._hammer.on('pan', (e) => {\n                        switch (this.config.slidingDirection) {\n                            case SlidingDirection.Horizontal:\n                                this.updateSlider({ value: e.deltaX, active: true });\n                                if (e.isFinal) {\n                                    this.updateSlider({ value: 0, active: false });\n                                    this.horizontalPan(e);\n                                }\n                                break;\n                            case SlidingDirection.Vertical:\n                                this.updateSlider({ value: e.deltaY, active: true });\n                                if (e.isFinal) {\n                                    this.updateSlider({ value: 0, active: false });\n                                    this.verticalPan(e);\n                                }\n                        }\n                    });\n                });\n            }\n            // Rearrange slider on window resize\n            if (Object(common[\"w\" /* isPlatformBrowser */])(this.platform)) {\n                this._resizeSub$ = Object(fromEvent[\"a\" /* fromEvent */])(window, 'resize').pipe(debounceTime(200), Object(tap[\"a\" /* tap */])(() => this.updateSlider(this._slidingWorker$.value))).subscribe();\n            }\n            setTimeout(() => this.updateSlider({ value: 0, active: false }));\n        }\n        ngOnDestroy() {\n            if (this._hammer) {\n                this._hammer.destroy();\n            }\n            if (this._resizeSub$) {\n                this._resizeSub$.unsubscribe();\n            }\n            this._slidingWorker$.complete();\n        }\n        /**\n         * Convert sliding state to styles\n         */\n        getSliderStyles(state) {\n            switch (this.config.slidingDirection) {\n                case SlidingDirection.Horizontal:\n                    return {\n                        transform: `translate3d(${-(this.state.currIndex * this._el.nativeElement.offsetWidth) + state.value}px, 0, 0)`,\n                        width: `calc(100% * ${this.state.items.length})`,\n                        height: '100%'\n                    };\n                case SlidingDirection.Vertical:\n                    return {\n                        transform: `translate3d(0, ${-(this.state.currIndex * this._el.nativeElement.offsetHeight) + state.value}px, 0)`,\n                        width: '100%',\n                        height: `calc(100% * ${this.state.items.length})`,\n                    };\n            }\n        }\n        verticalPan(e) {\n            if (!(e.direction & Hammer.DIRECTION_UP && e.offsetDirection & Hammer.DIRECTION_VERTICAL)) {\n                return;\n            }\n            if (e.velocityY > 0.3) {\n                this.prev();\n            }\n            else if (e.velocityY < -0.3) {\n                this.next();\n            }\n            else {\n                if (e.deltaY / 2 <= -this._el.nativeElement.offsetHeight * this.state.items.length / this.config.panSensitivity) {\n                    this.next();\n                }\n                else if (e.deltaY / 2 >= this._el.nativeElement.offsetHeight * this.state.items.length / this.config.panSensitivity) {\n                    this.prev();\n                }\n                else {\n                    this.action.emit(this.state.currIndex);\n                }\n            }\n        }\n        horizontalPan(e) {\n            if (!(e.direction & Hammer.DIRECTION_HORIZONTAL && e.offsetDirection & Hammer.DIRECTION_HORIZONTAL)) {\n                return;\n            }\n            if (e.velocityX > 0.3) {\n                this.prev();\n            }\n            else if (e.velocityX < -0.3) {\n                this.next();\n            }\n            else {\n                if (e.deltaX / 2 <= -this._el.nativeElement.offsetWidth * this.state.items.length / this.config.panSensitivity) {\n                    this.next();\n                }\n                else if (e.deltaX / 2 >= this._el.nativeElement.offsetWidth * this.state.items.length / this.config.panSensitivity) {\n                    this.prev();\n                }\n                else {\n                    this.action.emit(this.state.currIndex);\n                }\n            }\n        }\n        next() {\n            this.action.emit('next');\n        }\n        prev() {\n            this.action.emit('prev');\n        }\n        updateSlider(state) {\n            const newState = Object.assign(Object.assign({}, this._slidingWorker$.value), state);\n            this._slidingWorker$.next(newState);\n        }\n    }\n    GallerySliderComponent.ɵfac = function GallerySliderComponent_Factory(t) { return new (t || GallerySliderComponent)(core[\"Pb\" /* ɵɵdirectiveInject */](core[\"m\" /* ElementRef */]), core[\"Pb\" /* ɵɵdirectiveInject */](core[\"B\" /* NgZone */]), core[\"Pb\" /* ɵɵdirectiveInject */](core[\"D\" /* PLATFORM_ID */])); };\n    GallerySliderComponent.ɵcmp = core[\"Jb\" /* ɵɵdefineComponent */]({ type: GallerySliderComponent, selectors: [[\"gallery-slider\"]], inputs: { state: \"state\", config: \"config\" }, outputs: { action: \"action\", itemClick: \"itemClick\", error: \"error\" }, features: [core[\"Bb\" /* ɵɵNgOnChangesFeature */]], ngContentSelectors: _c0, decls: 3, vars: 3, consts: [[\"class\", \"g-items-container\", 3, \"ngStyle\", 4, \"ngIf\"], [1, \"g-items-container\", 3, \"ngStyle\"], [1, \"g-slider\", 3, \"ngStyle\"], [3, \"type\", \"config\", \"data\", \"currIndex\", \"index\", \"tapClick\", \"error\", 4, \"ngFor\", \"ngForOf\"], [3, \"type\", \"config\", \"data\", \"currIndex\", \"index\", \"tapClick\", \"error\"]], template: function GallerySliderComponent_Template(rf, ctx) {\n            if (rf & 1) {\n                core[\"kc\" /* ɵɵprojectionDef */]();\n                core[\"Ec\" /* ɵɵtemplate */](0, GallerySliderComponent_div_0_Template, 3, 5, \"div\", 0);\n                core[\"gc\" /* ɵɵpipe */](1, \"async\");\n                core[\"jc\" /* ɵɵprojection */](2);\n            }\n            if (rf & 2) {\n                core[\"lc\" /* ɵɵproperty */](\"ngIf\", core[\"hc\" /* ɵɵpipeBind1 */](1, 1, ctx.sliderState$));\n            }\n        }, directives: function () { return [common[\"m\" /* NgIf */], common[\"n\" /* NgStyle */], common[\"l\" /* NgForOf */], ng_gallery_GalleryItemComponent, ng_gallery_TapClick]; }, pipes: function () { return [common[\"b\" /* AsyncPipe */]]; }, encapsulation: 2, changeDetection: 0 });\n    return GallerySliderComponent;\n})();\nlet ng_gallery_GalleryCounterComponent = /*@__PURE__*/ (() => {\n    class GalleryCounterComponent {\n    }\n    GalleryCounterComponent.ɵfac = function GalleryCounterComponent_Factory(t) { return new (t || GalleryCounterComponent)(); };\n    GalleryCounterComponent.ɵcmp = core[\"Jb\" /* ɵɵdefineComponent */]({ type: GalleryCounterComponent, selectors: [[\"gallery-counter\"]], inputs: { state: \"state\" }, decls: 2, vars: 1, consts: [[1, \"g-counter\"]], template: function GalleryCounterComponent_Template(rf, ctx) {\n            if (rf & 1) {\n                core[\"Vb\" /* ɵɵelementStart */](0, \"div\", 0);\n                core[\"Gc\" /* ɵɵtext */](1);\n                core[\"Ub\" /* ɵɵelementEnd */]();\n            }\n            if (rf & 2) {\n                core[\"Db\" /* ɵɵadvance */](1);\n                core[\"Hc\" /* ɵɵtextInterpolate */](ctx.state.currIndex + 1 + \"/\" + ctx.state.items.length);\n            }\n        }, encapsulation: 2, changeDetection: 0 });\n    return GalleryCounterComponent;\n})();\nlet ng_gallery_GalleryItemComponent = /*@__PURE__*/ (() => {\n    class GalleryItemComponent {\n        constructor() {\n            this.Types = GalleryItemType;\n            /** Stream that emits when an error occurs */\n            this.error = new core[\"o\" /* EventEmitter */]();\n        }\n        get isActive() {\n            return this.index === this.currIndex;\n        }\n        get isAutoPlay() {\n            if (this.isActive) {\n                if (this.type === GalleryItemType.Video || this.type === GalleryItemType.Youtube) {\n                    return this.data.autoplay;\n                }\n            }\n        }\n        get youtubeSrc() {\n            let autoplay = 0;\n            if (this.isActive && this.type === GalleryItemType.Youtube && this.data.autoplay) {\n                autoplay = 1;\n            }\n            const url = new URL(this.data.src);\n            url.search = new URLSearchParams(Object.assign(Object.assign({ wmode: 'transparent' }, this.data.params), { autoplay })).toString();\n            return url.href;\n        }\n        get load() {\n            switch (this.config.loadingStrategy) {\n                case LoadingStrategy.Preload:\n                    return true;\n                case LoadingStrategy.Lazy:\n                    return this.currIndex === this.index;\n                default:\n                    return this.currIndex === this.index || this.currIndex === this.index - 1 || this.currIndex === this.index + 1;\n            }\n        }\n    }\n    GalleryItemComponent.ɵfac = function GalleryItemComponent_Factory(t) { return new (t || GalleryItemComponent)(); };\n    GalleryItemComponent.ɵcmp = core[\"Jb\" /* ɵɵdefineComponent */]({ type: GalleryItemComponent, selectors: [[\"gallery-item\"]], hostVars: 2, hostBindings: function GalleryItemComponent_HostBindings(rf, ctx) {\n            if (rf & 2) {\n                core[\"Hb\" /* ɵɵclassProp */](\"g-active-item\", ctx.isActive);\n            }\n        }, inputs: { config: \"config\", index: \"index\", currIndex: \"currIndex\", type: \"type\", data: \"data\" }, outputs: { error: \"error\" }, decls: 1, vars: 1, consts: [[3, \"ngSwitch\", 4, \"ngIf\"], [3, \"ngSwitch\"], [4, \"ngSwitchCase\"], [3, \"src\", \"poster\", \"controls\", \"play\", \"pause\", \"error\", 4, \"ngSwitchCase\"], [3, \"src\", \"autoplay\", \"pause\", 4, \"ngSwitchCase\"], [3, \"src\", 4, \"ngSwitchCase\"], [4, \"ngSwitchDefault\"], [3, \"src\", \"loadingIcon\", \"loadingError\", \"error\"], [1, \"g-template\", \"g-item-template\"], [4, \"ngTemplateOutlet\", \"ngTemplateOutletContext\"], [3, \"src\", \"poster\", \"controls\", \"play\", \"pause\", \"error\"], [3, \"src\", \"autoplay\", \"pause\"], [3, \"src\"]], template: function GalleryItemComponent_Template(rf, ctx) {\n            if (rf & 1) {\n                core[\"Ec\" /* ɵɵtemplate */](0, GalleryItemComponent_ng_container_0_Template, 6, 5, \"ng-container\", 0);\n            }\n            if (rf & 2) {\n                core[\"lc\" /* ɵɵproperty */](\"ngIf\", ctx.load);\n            }\n        }, directives: [common[\"m\" /* NgIf */], common[\"o\" /* NgSwitch */], common[\"p\" /* NgSwitchCase */], common[\"q\" /* NgSwitchDefault */], ng_gallery_GalleryImageComponent, common[\"r\" /* NgTemplateOutlet */], ng_gallery_GalleryVideoComponent, ng_gallery_GalleryIframeComponent], encapsulation: 2, changeDetection: 0 });\n    return GalleryItemComponent;\n})();\nlet ng_gallery_GalleryThumbComponent = /*@__PURE__*/ (() => {\n    class GalleryThumbComponent {\n        constructor() {\n            this.error = new core[\"o\" /* EventEmitter */]();\n        }\n        get isActive() {\n            return this.index === this.currIndex;\n        }\n    }\n    GalleryThumbComponent.ɵfac = function GalleryThumbComponent_Factory(t) { return new (t || GalleryThumbComponent)(); };\n    GalleryThumbComponent.ɵcmp = core[\"Jb\" /* ɵɵdefineComponent */]({ type: GalleryThumbComponent, selectors: [[\"gallery-thumb\"]], hostVars: 2, hostBindings: function GalleryThumbComponent_HostBindings(rf, ctx) {\n            if (rf & 2) {\n                core[\"Hb\" /* ɵɵclassProp */](\"g-active-thumb\", ctx.isActive);\n            }\n        }, inputs: { config: \"config\", index: \"index\", currIndex: \"currIndex\", type: \"type\", data: \"data\" }, outputs: { error: \"error\" }, decls: 2, vars: 5, consts: [[\"mode\", \"indeterminate\", 3, \"src\", \"isThumbnail\", \"loadingIcon\", \"loadingError\", \"error\"], [\"class\", \"g-template g-thumb-template\", 4, \"ngIf\"], [1, \"g-template\", \"g-thumb-template\"], [4, \"ngTemplateOutlet\", \"ngTemplateOutletContext\"]], template: function GalleryThumbComponent_Template(rf, ctx) {\n            if (rf & 1) {\n                core[\"Vb\" /* ɵɵelementStart */](0, \"gallery-image\", 0);\n                core[\"dc\" /* ɵɵlistener */](\"error\", function GalleryThumbComponent_Template_gallery_image_error_0_listener($event) { return ctx.error.emit($event); });\n                core[\"Ub\" /* ɵɵelementEnd */]();\n                core[\"Ec\" /* ɵɵtemplate */](1, GalleryThumbComponent_div_1_Template, 2, 6, \"div\", 1);\n            }\n            if (rf & 2) {\n                core[\"lc\" /* ɵɵproperty */](\"src\", ctx.data.thumb)(\"isThumbnail\", true)(\"loadingIcon\", ctx.config.thumbLoadingIcon)(\"loadingError\", ctx.config.thumbLoadingError);\n                core[\"Db\" /* ɵɵadvance */](1);\n                core[\"lc\" /* ɵɵproperty */](\"ngIf\", ctx.config.thumbTemplate);\n            }\n        }, directives: [ng_gallery_GalleryImageComponent, common[\"m\" /* NgIf */], common[\"r\" /* NgTemplateOutlet */]], encapsulation: 2, changeDetection: 0 });\n    return GalleryThumbComponent;\n})();\nlet ng_gallery_LazyImage = /*@__PURE__*/ (() => {\n    class LazyImage {\n        constructor(document) {\n            this.document = document;\n            this._imageLoader$ = new Subject[\"a\" /* Subject */]();\n            this._loaderSub$ = Subscription[\"a\" /* Subscription */].EMPTY;\n            this.loaded = new core[\"o\" /* EventEmitter */]();\n            this.error = new core[\"o\" /* EventEmitter */]();\n            this._loaderSub$ = this._imageLoader$.pipe(Object(switchMap[\"a\" /* switchMap */])((imageSrc) => this.nativeLoader(imageSrc))).subscribe();\n        }\n        ngOnChanges(changes) {\n            if (changes['src'] && changes['src'].previousValue !== changes['src'].currentValue) {\n                this.loadImage(this.src);\n            }\n        }\n        ngOnDestroy() {\n            this._loaderSub$.unsubscribe();\n            this._imageLoader$.complete();\n        }\n        loadImage(imagePath) {\n            this._imageLoader$.next(imagePath);\n        }\n        /**\n         * Native image loader, does not emit progress\n         * @param url\n         */\n        nativeLoader(url) {\n            const img = this.document.createElement('img');\n            // Stop previously loading\n            img.src = url;\n            // Image load success\n            const loadSuccess = Object(fromEvent[\"a\" /* fromEvent */])(img, 'load').pipe(Object(tap[\"a\" /* tap */])(() => this.loaded.emit(url)));\n            // Image load failed\n            const loadError = Object(fromEvent[\"a\" /* fromEvent */])(img, 'error').pipe(Object(tap[\"a\" /* tap */])(() => this.error.emit(new Error(`[lazyImage]: The image ${url} did not load`))));\n            return zip(loadSuccess, loadError);\n        }\n    }\n    LazyImage.ɵfac = function LazyImage_Factory(t) { return new (t || LazyImage)(core[\"Pb\" /* ɵɵdirectiveInject */](common[\"e\" /* DOCUMENT */])); };\n    LazyImage.ɵdir = core[\"Kb\" /* ɵɵdefineDirective */]({ type: LazyImage, selectors: [[\"\", \"lazyImage\", \"\"]], inputs: { src: [\"lazyImage\", \"src\"] }, outputs: { loaded: \"loaded\", error: \"error\" }, features: [core[\"Bb\" /* ɵɵNgOnChangesFeature */]] });\n    return LazyImage;\n})();\nlet ng_gallery_TapClick = /*@__PURE__*/ (() => {\n    class TapClick {\n        constructor(_el) {\n            this._el = _el;\n            this.clickListener = Subscription[\"a\" /* Subscription */].EMPTY;\n            this.tapClick = new core[\"o\" /* EventEmitter */]();\n        }\n        ngOnInit() {\n            this.activateClickEvent();\n        }\n        activateClickEvent() {\n            if (typeof Hammer !== 'undefined') {\n                // Use Hammer.js tap event\n                this._hammer = new Hammer(this._el.nativeElement);\n                this._hammer.on('tap', () => {\n                    if (!this.tapClickDisabled) {\n                        this.tapClick.emit(null);\n                    }\n                });\n            }\n            else {\n                // Use normal click event\n                this.clickListener = Object(fromEvent[\"a\" /* fromEvent */])(this._el.nativeElement, 'click').pipe(Object(filter[\"a\" /* filter */])(() => !this.tapClickDisabled), Object(tap[\"a\" /* tap */])(() => this.tapClick.emit(null))).subscribe();\n            }\n        }\n        ngOnDestroy() {\n            if (this._hammer) {\n                this._hammer.destroy();\n            }\n            this.clickListener.unsubscribe();\n        }\n    }\n    TapClick.ɵfac = function TapClick_Factory(t) { return new (t || TapClick)(core[\"Pb\" /* ɵɵdirectiveInject */](core[\"m\" /* ElementRef */])); };\n    TapClick.ɵdir = core[\"Kb\" /* ɵɵdefineDirective */]({ type: TapClick, selectors: [[\"\", \"tapClick\", \"\"]], inputs: { tapClickDisabled: \"tapClickDisabled\" }, outputs: { tapClick: \"tapClick\" } });\n    return TapClick;\n})();\nlet ng_gallery_GalleryModule = /*@__PURE__*/ (() => {\n    class GalleryModule {\n        static withConfig(config) {\n            return {\n                ngModule: GalleryModule,\n                providers: [\n                    {\n                        provide: GALLERY_CONFIG,\n                        useValue: config\n                    }\n                ]\n            };\n        }\n    }\n    GalleryModule.ɵmod = core[\"Nb\" /* ɵɵdefineNgModule */]({ type: GalleryModule });\n    GalleryModule.ɵinj = core[\"Mb\" /* ɵɵdefineInjector */]({ factory: function GalleryModule_Factory(t) { return new (t || GalleryModule)(); }, imports: [[\n                common[\"c\" /* CommonModule */]\n            ]] });\n    return GalleryModule;\n})();\n(function () { (typeof ngJitMode === \"undefined\" || ngJitMode) && core[\"Ac\" /* ɵɵsetNgModuleScope */](ng_gallery_GalleryModule, { declarations: function () { return [ng_gallery_GalleryComponent, ng_gallery_GalleryNavComponent, ng_gallery_GalleryDotsComponent, ng_gallery_GalleryCoreComponent, ng_gallery_GallerySliderComponent, ng_gallery_GalleryCounterComponent, ng_gallery_GalleryThumbsComponent, ng_gallery_GalleryThumbComponent, ng_gallery_GalleryItemComponent, ng_gallery_GalleryImageComponent, ng_gallery_GalleryVideoComponent, ng_gallery_GalleryIframeComponent, ng_gallery_LazyImage, ng_gallery_TapClick]; }, imports: function () { return [common[\"c\" /* CommonModule */]]; }, exports: function () { return [ng_gallery_GalleryComponent, ng_gallery_LazyImage, ng_gallery_TapClick]; } }); })();\n/**\n * Generated bundle index. Do not edit.\n */\n\n//# sourceMappingURL=ng-gallery.js.map\n\n// EXTERNAL MODULE: ./src/app/services/place-service.ts\nvar place_service = __webpack_require__(\"qOnq\");\n\n// EXTERNAL MODULE: ./src/app/services/geolocation.service.ts + 1 modules\nvar geolocation_service = __webpack_require__(\"H+Hf\");\n\n// EXTERNAL MODULE: ./src/app/services/local-storage.ts\nvar local_storage = __webpack_require__(\"eAEk\");\n\n// EXTERNAL MODULE: ./src/app/services/app-config.service.ts\nvar app_config_service = __webpack_require__(\"JvtB\");\n\n// CONCATENATED MODULE: ./node_modules/@angular/cdk/__ivy_ngcc__/fesm2015/keycodes.js\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nconst MAC_ENTER = 3;\nconst BACKSPACE = 8;\nconst TAB = 9;\nconst NUM_CENTER = 12;\nconst ENTER = 13;\nconst SHIFT = 16;\nconst CONTROL = 17;\nconst ALT = 18;\nconst PAUSE = 19;\nconst CAPS_LOCK = 20;\nconst ESCAPE = 27;\nconst SPACE = 32;\nconst PAGE_UP = 33;\nconst PAGE_DOWN = 34;\nconst END = 35;\nconst HOME = 36;\nconst LEFT_ARROW = 37;\nconst UP_ARROW = 38;\nconst RIGHT_ARROW = 39;\nconst DOWN_ARROW = 40;\nconst PLUS_SIGN = 43;\nconst PRINT_SCREEN = 44;\nconst INSERT = 45;\nconst DELETE = 46;\nconst ZERO = 48;\nconst ONE = 49;\nconst TWO = 50;\nconst THREE = 51;\nconst FOUR = 52;\nconst FIVE = 53;\nconst SIX = 54;\nconst SEVEN = 55;\nconst EIGHT = 56;\nconst NINE = 57;\nconst FF_SEMICOLON = 59; // Firefox (Gecko) fires this for semicolon instead of 186\nconst FF_EQUALS = 61; // Firefox (Gecko) fires this for equals instead of 187\nconst QUESTION_MARK = 63;\nconst AT_SIGN = 64;\nconst A = 65;\nconst B = 66;\nconst C = 67;\nconst D = 68;\nconst E = 69;\nconst F = 70;\nconst G = 71;\nconst H = 72;\nconst I = 73;\nconst J = 74;\nconst K = 75;\nconst L = 76;\nconst M = 77;\nconst N = 78;\nconst O = 79;\nconst P = 80;\nconst Q = 81;\nconst R = 82;\nconst S = 83;\nconst T = 84;\nconst U = 85;\nconst V = 86;\nconst W = 87;\nconst X = 88;\nconst Y = 89;\nconst Z = 90;\nconst META = 91; // WIN_KEY_LEFT\nconst MAC_WK_CMD_LEFT = 91;\nconst MAC_WK_CMD_RIGHT = 93;\nconst CONTEXT_MENU = 93;\nconst NUMPAD_ZERO = 96;\nconst NUMPAD_ONE = 97;\nconst NUMPAD_TWO = 98;\nconst NUMPAD_THREE = 99;\nconst NUMPAD_FOUR = 100;\nconst NUMPAD_FIVE = 101;\nconst NUMPAD_SIX = 102;\nconst NUMPAD_SEVEN = 103;\nconst NUMPAD_EIGHT = 104;\nconst NUMPAD_NINE = 105;\nconst NUMPAD_MULTIPLY = 106;\nconst NUMPAD_PLUS = 107;\nconst NUMPAD_MINUS = 109;\nconst NUMPAD_PERIOD = 110;\nconst NUMPAD_DIVIDE = 111;\nconst F1 = 112;\nconst F2 = 113;\nconst F3 = 114;\nconst F4 = 115;\nconst F5 = 116;\nconst F6 = 117;\nconst F7 = 118;\nconst F8 = 119;\nconst F9 = 120;\nconst F10 = 121;\nconst F11 = 122;\nconst F12 = 123;\nconst NUM_LOCK = 144;\nconst SCROLL_LOCK = 145;\nconst FIRST_MEDIA = 166;\nconst FF_MINUS = 173;\nconst MUTE = 173; // Firefox (Gecko) fires 181 for MUTE\nconst VOLUME_DOWN = 174; // Firefox (Gecko) fires 182 for VOLUME_DOWN\nconst VOLUME_UP = 175; // Firefox (Gecko) fires 183 for VOLUME_UP\nconst FF_MUTE = 181;\nconst FF_VOLUME_DOWN = 182;\nconst LAST_MEDIA = 183;\nconst FF_VOLUME_UP = 183;\nconst SEMICOLON = 186; // Firefox (Gecko) fires 59 for SEMICOLON\nconst EQUALS = 187; // Firefox (Gecko) fires 61 for EQUALS\nconst COMMA = 188;\nconst DASH = 189; // Firefox (Gecko) fires 173 for DASH/MINUS\nconst SLASH = 191;\nconst APOSTROPHE = 192;\nconst TILDE = 192;\nconst OPEN_SQUARE_BRACKET = 219;\nconst BACKSLASH = 220;\nconst CLOSE_SQUARE_BRACKET = 221;\nconst SINGLE_QUOTE = 222;\nconst MAC_META = 224;\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Checks whether a modifier key is pressed.\n * @param event Event to be checked.\n */\nfunction hasModifierKey(event, ...modifiers) {\n    if (modifiers.length) {\n        return modifiers.some(modifier => event[modifier]);\n    }\n    return event.altKey || event.shiftKey || event.ctrlKey || event.metaKey;\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Generated bundle index. Do not edit.\n */\n\n//# sourceMappingURL=keycodes.js.map\n\n// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/operators/take.js\nvar take = __webpack_require__(\"IzEk\");\n\n// CONCATENATED MODULE: ./node_modules/@angular/cdk/fesm2015/coercion.js\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/** Coerces a data-bound value (typically a string) to a boolean. */\nfunction coerceBooleanProperty(value) {\n    return value != null && `${value}` !== 'false';\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nfunction coerceNumberProperty(value, fallbackValue = 0) {\n    return _isNumberValue(value) ? Number(value) : fallbackValue;\n}\n/**\n * Whether the provided value is considered a number.\n * @docs-private\n */\nfunction _isNumberValue(value) {\n    // parseFloat(value) handles most of the cases we're interested in (it treats null, empty string,\n    // and other non-number values as NaN, where Number just uses 0) but it considers the string\n    // '123hello' to be a valid number. Therefore we also check if Number(value) is NaN.\n    return !isNaN(parseFloat(value)) && !isNaN(Number(value));\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nfunction coerceArray(value) {\n    return Array.isArray(value) ? value : [value];\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/** Coerces a value to a CSS pixel value. */\nfunction coerceCssPixelValue(value) {\n    if (value == null) {\n        return '';\n    }\n    return typeof value === 'string' ? value : `${value}px`;\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Coerces an ElementRef or an Element into an element.\n * Useful for APIs that can accept either a ref or the native element itself.\n */\nfunction coerceElement(elementOrRef) {\n    return elementOrRef instanceof core[\"m\" /* ElementRef */] ? elementOrRef.nativeElement : elementOrRef;\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n//# sourceMappingURL=coercion.js.map\n\n// EXTERNAL MODULE: ./node_modules/@angular/cdk/__ivy_ngcc__/fesm2015/platform.js\nvar fesm2015_platform = __webpack_require__(\"nLfN\");\n\n// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/Observable.js + 3 modules\nvar Observable = __webpack_require__(\"HDdC\");\n\n// CONCATENATED MODULE: ./node_modules/@angular/cdk/__ivy_ngcc__/fesm2015/observers.js\n\n\n\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Factory that creates a new MutationObserver and allows us to stub it out in unit tests.\n * @docs-private\n */\n\nlet observers_MutationObserverFactory = /*@__PURE__*/ (() => {\n    class MutationObserverFactory {\n        create(callback) {\n            return typeof MutationObserver === 'undefined' ? null : new MutationObserver(callback);\n        }\n    }\n    MutationObserverFactory.ɵfac = function MutationObserverFactory_Factory(t) { return new (t || MutationObserverFactory)(); };\n    MutationObserverFactory.ɵprov = /*@__PURE__*/ Object(core[\"Lb\" /* ɵɵdefineInjectable */])({ factory: function MutationObserverFactory_Factory() { return new MutationObserverFactory(); }, token: MutationObserverFactory, providedIn: \"root\" });\n    return MutationObserverFactory;\n})();\nlet observers_ContentObserver = /*@__PURE__*/ (() => {\n    class ContentObserver {\n        constructor(_mutationObserverFactory) {\n            this._mutationObserverFactory = _mutationObserverFactory;\n            /** Keeps track of the existing MutationObservers so they can be reused. */\n            this._observedElements = new Map();\n        }\n        ngOnDestroy() {\n            this._observedElements.forEach((_, element) => this._cleanupObserver(element));\n        }\n        observe(elementOrRef) {\n            const element = coerceElement(elementOrRef);\n            return new Observable[\"a\" /* Observable */]((observer) => {\n                const stream = this._observeElement(element);\n                const subscription = stream.subscribe(observer);\n                return () => {\n                    subscription.unsubscribe();\n                    this._unobserveElement(element);\n                };\n            });\n        }\n        /**\n         * Observes the given element by using the existing MutationObserver if available, or creating a\n         * new one if not.\n         */\n        _observeElement(element) {\n            if (!this._observedElements.has(element)) {\n                const stream = new Subject[\"a\" /* Subject */]();\n                const observer = this._mutationObserverFactory.create(mutations => stream.next(mutations));\n                if (observer) {\n                    observer.observe(element, {\n                        characterData: true,\n                        childList: true,\n                        subtree: true\n                    });\n                }\n                this._observedElements.set(element, { observer, stream, count: 1 });\n            }\n            else {\n                this._observedElements.get(element).count++;\n            }\n            return this._observedElements.get(element).stream;\n        }\n        /**\n         * Un-observes the given element and cleans up the underlying MutationObserver if nobody else is\n         * observing this element.\n         */\n        _unobserveElement(element) {\n            if (this._observedElements.has(element)) {\n                this._observedElements.get(element).count--;\n                if (!this._observedElements.get(element).count) {\n                    this._cleanupObserver(element);\n                }\n            }\n        }\n        /** Clean up the underlying MutationObserver for the specified element. */\n        _cleanupObserver(element) {\n            if (this._observedElements.has(element)) {\n                const { observer, stream } = this._observedElements.get(element);\n                if (observer) {\n                    observer.disconnect();\n                }\n                stream.complete();\n                this._observedElements.delete(element);\n            }\n        }\n    }\n    ContentObserver.ɵfac = function ContentObserver_Factory(t) { return new (t || ContentObserver)(core[\"Zb\" /* ɵɵinject */](observers_MutationObserverFactory)); };\n    ContentObserver.ɵprov = /*@__PURE__*/ Object(core[\"Lb\" /* ɵɵdefineInjectable */])({ factory: function ContentObserver_Factory() { return new ContentObserver(Object(core[\"Zb\" /* ɵɵinject */])(observers_MutationObserverFactory)); }, token: ContentObserver, providedIn: \"root\" });\n    return ContentObserver;\n})();\nlet observers_CdkObserveContent = /*@__PURE__*/ (() => {\n    class CdkObserveContent {\n        constructor(_contentObserver, _elementRef, _ngZone) {\n            this._contentObserver = _contentObserver;\n            this._elementRef = _elementRef;\n            this._ngZone = _ngZone;\n            /** Event emitted for each change in the element's content. */\n            this.event = new core[\"o\" /* EventEmitter */]();\n            this._disabled = false;\n            this._currentSubscription = null;\n        }\n        /**\n         * Whether observing content is disabled. This option can be used\n         * to disconnect the underlying MutationObserver until it is needed.\n         */\n        get disabled() { return this._disabled; }\n        set disabled(value) {\n            this._disabled = coerceBooleanProperty(value);\n            this._disabled ? this._unsubscribe() : this._subscribe();\n        }\n        /** Debounce interval for emitting the changes. */\n        get debounce() { return this._debounce; }\n        set debounce(value) {\n            this._debounce = coerceNumberProperty(value);\n            this._subscribe();\n        }\n        ngAfterContentInit() {\n            if (!this._currentSubscription && !this.disabled) {\n                this._subscribe();\n            }\n        }\n        ngOnDestroy() {\n            this._unsubscribe();\n        }\n        _subscribe() {\n            this._unsubscribe();\n            const stream = this._contentObserver.observe(this._elementRef);\n            // TODO(mmalerba): We shouldn't be emitting on this @Output() outside the zone.\n            // Consider brining it back inside the zone next time we're making breaking changes.\n            // Bringing it back inside can cause things like infinite change detection loops and changed\n            // after checked errors if people's code isn't handling it properly.\n            this._ngZone.runOutsideAngular(() => {\n                this._currentSubscription =\n                    (this.debounce ? stream.pipe(debounceTime(this.debounce)) : stream).subscribe(this.event);\n            });\n        }\n        _unsubscribe() {\n            if (this._currentSubscription) {\n                this._currentSubscription.unsubscribe();\n            }\n        }\n    }\n    CdkObserveContent.ɵfac = function CdkObserveContent_Factory(t) { return new (t || CdkObserveContent)(core[\"Pb\" /* ɵɵdirectiveInject */](observers_ContentObserver), core[\"Pb\" /* ɵɵdirectiveInject */](core[\"m\" /* ElementRef */]), core[\"Pb\" /* ɵɵdirectiveInject */](core[\"B\" /* NgZone */])); };\n    CdkObserveContent.ɵdir = /*@__PURE__*/ core[\"Kb\" /* ɵɵdefineDirective */]({ type: CdkObserveContent, selectors: [[\"\", \"cdkObserveContent\", \"\"]], inputs: { disabled: [\"cdkObserveContentDisabled\", \"disabled\"], debounce: \"debounce\" }, outputs: { event: \"cdkObserveContent\" }, exportAs: [\"cdkObserveContent\"] });\n    return CdkObserveContent;\n})();\nlet observers_ObserversModule = /*@__PURE__*/ (() => {\n    class ObserversModule {\n    }\n    ObserversModule.ɵmod = /*@__PURE__*/ core[\"Nb\" /* ɵɵdefineNgModule */]({ type: ObserversModule });\n    ObserversModule.ɵinj = /*@__PURE__*/ core[\"Mb\" /* ɵɵdefineInjector */]({ factory: function ObserversModule_Factory(t) { return new (t || ObserversModule)(); }, providers: [observers_MutationObserverFactory] });\n    return ObserversModule;\n})();\n/*@__PURE__*/ (function () { (typeof ngJitMode === \"undefined\" || ngJitMode) && core[\"Ac\" /* ɵɵsetNgModuleScope */](observers_ObserversModule, { declarations: [observers_CdkObserveContent], exports: [observers_CdkObserveContent] }); })();\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Generated bundle index. Do not edit.\n */\n\n//# sourceMappingURL=observers.js.map\n\n// CONCATENATED MODULE: ./node_modules/@angular/cdk/__ivy_ngcc__/fesm2015/a11y.js\n\n\n\n\n\n\n\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/** IDs are delimited by an empty space, as per the spec. */\n\n\n\nconst ID_DELIMITER = ' ';\n/**\n * Adds the given ID to the specified ARIA attribute on an element.\n * Used for attributes such as aria-labelledby, aria-owns, etc.\n */\nfunction addAriaReferencedId(el, attr, id) {\n    const ids = getAriaReferenceIds(el, attr);\n    if (ids.some(existingId => existingId.trim() == id.trim())) {\n        return;\n    }\n    ids.push(id.trim());\n    el.setAttribute(attr, ids.join(ID_DELIMITER));\n}\n/**\n * Removes the given ID from the specified ARIA attribute on an element.\n * Used for attributes such as aria-labelledby, aria-owns, etc.\n */\nfunction removeAriaReferencedId(el, attr, id) {\n    const ids = getAriaReferenceIds(el, attr);\n    const filteredIds = ids.filter(val => val != id.trim());\n    if (filteredIds.length) {\n        el.setAttribute(attr, filteredIds.join(ID_DELIMITER));\n    }\n    else {\n        el.removeAttribute(attr);\n    }\n}\n/**\n * Gets the list of IDs referenced by the given ARIA attribute on an element.\n * Used for attributes such as aria-labelledby, aria-owns, etc.\n */\nfunction getAriaReferenceIds(el, attr) {\n    // Get string array of all individual ids (whitespace delimited) in the attribute value\n    return (el.getAttribute(attr) || '').match(/\\S+/g) || [];\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/** ID used for the body container where all messages are appended. */\nconst MESSAGES_CONTAINER_ID = 'cdk-describedby-message-container';\n/** ID prefix used for each created message element. */\nconst CDK_DESCRIBEDBY_ID_PREFIX = 'cdk-describedby-message';\n/** Attribute given to each host element that is described by a message element. */\nconst CDK_DESCRIBEDBY_HOST_ATTRIBUTE = 'cdk-describedby-host';\n/** Global incremental identifier for each registered message element. */\nlet nextId = 0;\n/** Global map of all registered message elements that have been placed into the document. */\nconst messageRegistry = /*@__PURE__*/ new Map();\n/** Container for all registered messages. */\nlet messagesContainer = null;\nlet a11y_AriaDescriber = /*@__PURE__*/ (() => {\n    class AriaDescriber {\n        constructor(_document) {\n            this._document = _document;\n        }\n        /**\n         * Adds to the host element an aria-describedby reference to a hidden element that contains\n         * the message. If the same message has already been registered, then it will reuse the created\n         * message element.\n         */\n        describe(hostElement, message) {\n            if (!this._canBeDescribed(hostElement, message)) {\n                return;\n            }\n            if (typeof message !== 'string') {\n                // We need to ensure that the element has an ID.\n                this._setMessageId(message);\n                messageRegistry.set(message, { messageElement: message, referenceCount: 0 });\n            }\n            else if (!messageRegistry.has(message)) {\n                this._createMessageElement(message);\n            }\n            if (!this._isElementDescribedByMessage(hostElement, message)) {\n                this._addMessageReference(hostElement, message);\n            }\n        }\n        /** Removes the host element's aria-describedby reference to the message element. */\n        removeDescription(hostElement, message) {\n            if (!this._isElementNode(hostElement)) {\n                return;\n            }\n            if (this._isElementDescribedByMessage(hostElement, message)) {\n                this._removeMessageReference(hostElement, message);\n            }\n            // If the message is a string, it means that it's one that we created for the\n            // consumer so we can remove it safely, otherwise we should leave it in place.\n            if (typeof message === 'string') {\n                const registeredMessage = messageRegistry.get(message);\n                if (registeredMessage && registeredMessage.referenceCount === 0) {\n                    this._deleteMessageElement(message);\n                }\n            }\n            if (messagesContainer && messagesContainer.childNodes.length === 0) {\n                this._deleteMessagesContainer();\n            }\n        }\n        /** Unregisters all created message elements and removes the message container. */\n        ngOnDestroy() {\n            const describedElements = this._document.querySelectorAll(`[${CDK_DESCRIBEDBY_HOST_ATTRIBUTE}]`);\n            for (let i = 0; i < describedElements.length; i++) {\n                this._removeCdkDescribedByReferenceIds(describedElements[i]);\n                describedElements[i].removeAttribute(CDK_DESCRIBEDBY_HOST_ATTRIBUTE);\n            }\n            if (messagesContainer) {\n                this._deleteMessagesContainer();\n            }\n            messageRegistry.clear();\n        }\n        /**\n         * Creates a new element in the visually hidden message container element with the message\n         * as its content and adds it to the message registry.\n         */\n        _createMessageElement(message) {\n            const messageElement = this._document.createElement('div');\n            this._setMessageId(messageElement);\n            messageElement.textContent = message;\n            this._createMessagesContainer();\n            messagesContainer.appendChild(messageElement);\n            messageRegistry.set(message, { messageElement, referenceCount: 0 });\n        }\n        /** Assigns a unique ID to an element, if it doesn't have one already. */\n        _setMessageId(element) {\n            if (!element.id) {\n                element.id = `${CDK_DESCRIBEDBY_ID_PREFIX}-${nextId++}`;\n            }\n        }\n        /** Deletes the message element from the global messages container. */\n        _deleteMessageElement(message) {\n            const registeredMessage = messageRegistry.get(message);\n            const messageElement = registeredMessage && registeredMessage.messageElement;\n            if (messagesContainer && messageElement) {\n                messagesContainer.removeChild(messageElement);\n            }\n            messageRegistry.delete(message);\n        }\n        /** Creates the global container for all aria-describedby messages. */\n        _createMessagesContainer() {\n            if (!messagesContainer) {\n                const preExistingContainer = this._document.getElementById(MESSAGES_CONTAINER_ID);\n                // When going from the server to the client, we may end up in a situation where there's\n                // already a container on the page, but we don't have a reference to it. Clear the\n                // old container so we don't get duplicates. Doing this, instead of emptying the previous\n                // container, should be slightly faster.\n                if (preExistingContainer) {\n                    preExistingContainer.parentNode.removeChild(preExistingContainer);\n                }\n                messagesContainer = this._document.createElement('div');\n                messagesContainer.id = MESSAGES_CONTAINER_ID;\n                messagesContainer.setAttribute('aria-hidden', 'true');\n                messagesContainer.style.display = 'none';\n                this._document.body.appendChild(messagesContainer);\n            }\n        }\n        /** Deletes the global messages container. */\n        _deleteMessagesContainer() {\n            if (messagesContainer && messagesContainer.parentNode) {\n                messagesContainer.parentNode.removeChild(messagesContainer);\n                messagesContainer = null;\n            }\n        }\n        /** Removes all cdk-describedby messages that are hosted through the element. */\n        _removeCdkDescribedByReferenceIds(element) {\n            // Remove all aria-describedby reference IDs that are prefixed by CDK_DESCRIBEDBY_ID_PREFIX\n            const originalReferenceIds = getAriaReferenceIds(element, 'aria-describedby')\n                .filter(id => id.indexOf(CDK_DESCRIBEDBY_ID_PREFIX) != 0);\n            element.setAttribute('aria-describedby', originalReferenceIds.join(' '));\n        }\n        /**\n         * Adds a message reference to the element using aria-describedby and increments the registered\n         * message's reference count.\n         */\n        _addMessageReference(element, message) {\n            const registeredMessage = messageRegistry.get(message);\n            // Add the aria-describedby reference and set the\n            // describedby_host attribute to mark the element.\n            addAriaReferencedId(element, 'aria-describedby', registeredMessage.messageElement.id);\n            element.setAttribute(CDK_DESCRIBEDBY_HOST_ATTRIBUTE, '');\n            registeredMessage.referenceCount++;\n        }\n        /**\n         * Removes a message reference from the element using aria-describedby\n         * and decrements the registered message's reference count.\n         */\n        _removeMessageReference(element, message) {\n            const registeredMessage = messageRegistry.get(message);\n            registeredMessage.referenceCount--;\n            removeAriaReferencedId(element, 'aria-describedby', registeredMessage.messageElement.id);\n            element.removeAttribute(CDK_DESCRIBEDBY_HOST_ATTRIBUTE);\n        }\n        /** Returns true if the element has been described by the provided message ID. */\n        _isElementDescribedByMessage(element, message) {\n            const referenceIds = getAriaReferenceIds(element, 'aria-describedby');\n            const registeredMessage = messageRegistry.get(message);\n            const messageId = registeredMessage && registeredMessage.messageElement.id;\n            return !!messageId && referenceIds.indexOf(messageId) != -1;\n        }\n        /** Determines whether a message can be described on a particular element. */\n        _canBeDescribed(element, message) {\n            if (!this._isElementNode(element)) {\n                return false;\n            }\n            if (message && typeof message === 'object') {\n                // We'd have to make some assumptions about the description element's text, if the consumer\n                // passed in an element. Assume that if an element is passed in, the consumer has verified\n                // that it can be used as a description.\n                return true;\n            }\n            const trimmedMessage = message == null ? '' : `${message}`.trim();\n            const ariaLabel = element.getAttribute('aria-label');\n            // We shouldn't set descriptions if they're exactly the same as the `aria-label` of the\n            // element, because screen readers will end up reading out the same text twice in a row.\n            return trimmedMessage ? (!ariaLabel || ariaLabel.trim() !== trimmedMessage) : false;\n        }\n        /** Checks whether a node is an Element node. */\n        _isElementNode(element) {\n            return element.nodeType === this._document.ELEMENT_NODE;\n        }\n    }\n    AriaDescriber.ɵfac = function AriaDescriber_Factory(t) { return new (t || AriaDescriber)(core[\"Zb\" /* ɵɵinject */](common[\"e\" /* DOCUMENT */])); };\n    AriaDescriber.ɵprov = /*@__PURE__*/ Object(core[\"Lb\" /* ɵɵdefineInjectable */])({ factory: function AriaDescriber_Factory() { return new AriaDescriber(Object(core[\"Zb\" /* ɵɵinject */])(common[\"e\" /* DOCUMENT */])); }, token: AriaDescriber, providedIn: \"root\" });\n    return AriaDescriber;\n})();\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * This class manages keyboard events for selectable lists. If you pass it a query list\n * of items, it will set the active item correctly when arrow events occur.\n */\nclass a11y_ListKeyManager {\n    constructor(_items) {\n        this._items = _items;\n        this._activeItemIndex = -1;\n        this._activeItem = null;\n        this._wrap = false;\n        this._letterKeyStream = new Subject[\"a\" /* Subject */]();\n        this._typeaheadSubscription = Subscription[\"a\" /* Subscription */].EMPTY;\n        this._vertical = true;\n        this._allowedModifierKeys = [];\n        /**\n         * Predicate function that can be used to check whether an item should be skipped\n         * by the key manager. By default, disabled items are skipped.\n         */\n        this._skipPredicateFn = (item) => item.disabled;\n        // Buffer for the letters that the user has pressed when the typeahead option is turned on.\n        this._pressedLetters = [];\n        /**\n         * Stream that emits any time the TAB key is pressed, so components can react\n         * when focus is shifted off of the list.\n         */\n        this.tabOut = new Subject[\"a\" /* Subject */]();\n        /** Stream that emits whenever the active item of the list manager changes. */\n        this.change = new Subject[\"a\" /* Subject */]();\n        // We allow for the items to be an array because, in some cases, the consumer may\n        // not have access to a QueryList of the items they want to manage (e.g. when the\n        // items aren't being collected via `ViewChildren` or `ContentChildren`).\n        if (_items instanceof core[\"F\" /* QueryList */]) {\n            _items.changes.subscribe((newItems) => {\n                if (this._activeItem) {\n                    const itemArray = newItems.toArray();\n                    const newIndex = itemArray.indexOf(this._activeItem);\n                    if (newIndex > -1 && newIndex !== this._activeItemIndex) {\n                        this._activeItemIndex = newIndex;\n                    }\n                }\n            });\n        }\n    }\n    /**\n     * Sets the predicate function that determines which items should be skipped by the\n     * list key manager.\n     * @param predicate Function that determines whether the given item should be skipped.\n     */\n    skipPredicate(predicate) {\n        this._skipPredicateFn = predicate;\n        return this;\n    }\n    /**\n     * Configures wrapping mode, which determines whether the active item will wrap to\n     * the other end of list when there are no more items in the given direction.\n     * @param shouldWrap Whether the list should wrap when reaching the end.\n     */\n    withWrap(shouldWrap = true) {\n        this._wrap = shouldWrap;\n        return this;\n    }\n    /**\n     * Configures whether the key manager should be able to move the selection vertically.\n     * @param enabled Whether vertical selection should be enabled.\n     */\n    withVerticalOrientation(enabled = true) {\n        this._vertical = enabled;\n        return this;\n    }\n    /**\n     * Configures the key manager to move the selection horizontally.\n     * Passing in `null` will disable horizontal movement.\n     * @param direction Direction in which the selection can be moved.\n     */\n    withHorizontalOrientation(direction) {\n        this._horizontal = direction;\n        return this;\n    }\n    /**\n     * Modifier keys which are allowed to be held down and whose default actions will be prevented\n     * as the user is pressing the arrow keys. Defaults to not allowing any modifier keys.\n     */\n    withAllowedModifierKeys(keys) {\n        this._allowedModifierKeys = keys;\n        return this;\n    }\n    /**\n     * Turns on typeahead mode which allows users to set the active item by typing.\n     * @param debounceInterval Time to wait after the last keystroke before setting the active item.\n     */\n    withTypeAhead(debounceInterval = 200) {\n        if (this._items.length && this._items.some(item => typeof item.getLabel !== 'function')) {\n            throw Error('ListKeyManager items in typeahead mode must implement the `getLabel` method.');\n        }\n        this._typeaheadSubscription.unsubscribe();\n        // Debounce the presses of non-navigational keys, collect the ones that correspond to letters\n        // and convert those letters back into a string. Afterwards find the first item that starts\n        // with that string and select it.\n        this._typeaheadSubscription = this._letterKeyStream.pipe(Object(tap[\"a\" /* tap */])(letter => this._pressedLetters.push(letter)), debounceTime(debounceInterval), Object(filter[\"a\" /* filter */])(() => this._pressedLetters.length > 0), Object(map[\"a\" /* map */])(() => this._pressedLetters.join(''))).subscribe(inputString => {\n            const items = this._getItemsArray();\n            // Start at 1 because we want to start searching at the item immediately\n            // following the current active item.\n            for (let i = 1; i < items.length + 1; i++) {\n                const index = (this._activeItemIndex + i) % items.length;\n                const item = items[index];\n                if (!this._skipPredicateFn(item) &&\n                    item.getLabel().toUpperCase().trim().indexOf(inputString) === 0) {\n                    this.setActiveItem(index);\n                    break;\n                }\n            }\n            this._pressedLetters = [];\n        });\n        return this;\n    }\n    setActiveItem(item) {\n        const previousActiveItem = this._activeItem;\n        this.updateActiveItem(item);\n        if (this._activeItem !== previousActiveItem) {\n            this.change.next(this._activeItemIndex);\n        }\n    }\n    /**\n     * Sets the active item depending on the key event passed in.\n     * @param event Keyboard event to be used for determining which element should be active.\n     */\n    onKeydown(event) {\n        const keyCode = event.keyCode;\n        const modifiers = ['altKey', 'ctrlKey', 'metaKey', 'shiftKey'];\n        const isModifierAllowed = modifiers.every(modifier => {\n            return !event[modifier] || this._allowedModifierKeys.indexOf(modifier) > -1;\n        });\n        switch (keyCode) {\n            case TAB:\n                this.tabOut.next();\n                return;\n            case DOWN_ARROW:\n                if (this._vertical && isModifierAllowed) {\n                    this.setNextItemActive();\n                    break;\n                }\n                else {\n                    return;\n                }\n            case UP_ARROW:\n                if (this._vertical && isModifierAllowed) {\n                    this.setPreviousItemActive();\n                    break;\n                }\n                else {\n                    return;\n                }\n            case RIGHT_ARROW:\n                if (this._horizontal && isModifierAllowed) {\n                    this._horizontal === 'rtl' ? this.setPreviousItemActive() : this.setNextItemActive();\n                    break;\n                }\n                else {\n                    return;\n                }\n            case LEFT_ARROW:\n                if (this._horizontal && isModifierAllowed) {\n                    this._horizontal === 'rtl' ? this.setNextItemActive() : this.setPreviousItemActive();\n                    break;\n                }\n                else {\n                    return;\n                }\n            default:\n                if (isModifierAllowed || hasModifierKey(event, 'shiftKey')) {\n                    // Attempt to use the `event.key` which also maps it to the user's keyboard language,\n                    // otherwise fall back to resolving alphanumeric characters via the keyCode.\n                    if (event.key && event.key.length === 1) {\n                        this._letterKeyStream.next(event.key.toLocaleUpperCase());\n                    }\n                    else if ((keyCode >= A && keyCode <= Z) || (keyCode >= ZERO && keyCode <= NINE)) {\n                        this._letterKeyStream.next(String.fromCharCode(keyCode));\n                    }\n                }\n                // Note that we return here, in order to avoid preventing\n                // the default action of non-navigational keys.\n                return;\n        }\n        this._pressedLetters = [];\n        event.preventDefault();\n    }\n    /** Index of the currently active item. */\n    get activeItemIndex() {\n        return this._activeItemIndex;\n    }\n    /** The active item. */\n    get activeItem() {\n        return this._activeItem;\n    }\n    /** Gets whether the user is currently typing into the manager using the typeahead feature. */\n    isTyping() {\n        return this._pressedLetters.length > 0;\n    }\n    /** Sets the active item to the first enabled item in the list. */\n    setFirstItemActive() {\n        this._setActiveItemByIndex(0, 1);\n    }\n    /** Sets the active item to the last enabled item in the list. */\n    setLastItemActive() {\n        this._setActiveItemByIndex(this._items.length - 1, -1);\n    }\n    /** Sets the active item to the next enabled item in the list. */\n    setNextItemActive() {\n        this._activeItemIndex < 0 ? this.setFirstItemActive() : this._setActiveItemByDelta(1);\n    }\n    /** Sets the active item to a previous enabled item in the list. */\n    setPreviousItemActive() {\n        this._activeItemIndex < 0 && this._wrap ? this.setLastItemActive()\n            : this._setActiveItemByDelta(-1);\n    }\n    updateActiveItem(item) {\n        const itemArray = this._getItemsArray();\n        const index = typeof item === 'number' ? item : itemArray.indexOf(item);\n        const activeItem = itemArray[index];\n        // Explicitly check for `null` and `undefined` because other falsy values are valid.\n        this._activeItem = activeItem == null ? null : activeItem;\n        this._activeItemIndex = index;\n    }\n    /**\n     * This method sets the active item, given a list of items and the delta between the\n     * currently active item and the new active item. It will calculate differently\n     * depending on whether wrap mode is turned on.\n     */\n    _setActiveItemByDelta(delta) {\n        this._wrap ? this._setActiveInWrapMode(delta) : this._setActiveInDefaultMode(delta);\n    }\n    /**\n     * Sets the active item properly given \"wrap\" mode. In other words, it will continue to move\n     * down the list until it finds an item that is not disabled, and it will wrap if it\n     * encounters either end of the list.\n     */\n    _setActiveInWrapMode(delta) {\n        const items = this._getItemsArray();\n        for (let i = 1; i <= items.length; i++) {\n            const index = (this._activeItemIndex + (delta * i) + items.length) % items.length;\n            const item = items[index];\n            if (!this._skipPredicateFn(item)) {\n                this.setActiveItem(index);\n                return;\n            }\n        }\n    }\n    /**\n     * Sets the active item properly given the default mode. In other words, it will\n     * continue to move down the list until it finds an item that is not disabled. If\n     * it encounters either end of the list, it will stop and not wrap.\n     */\n    _setActiveInDefaultMode(delta) {\n        this._setActiveItemByIndex(this._activeItemIndex + delta, delta);\n    }\n    /**\n     * Sets the active item to the first enabled item starting at the index specified. If the\n     * item is disabled, it will move in the fallbackDelta direction until it either\n     * finds an enabled item or encounters the end of the list.\n     */\n    _setActiveItemByIndex(index, fallbackDelta) {\n        const items = this._getItemsArray();\n        if (!items[index]) {\n            return;\n        }\n        while (this._skipPredicateFn(items[index])) {\n            index += fallbackDelta;\n            if (!items[index]) {\n                return;\n            }\n        }\n        this.setActiveItem(index);\n    }\n    /** Returns the items as an array. */\n    _getItemsArray() {\n        return this._items instanceof core[\"F\" /* QueryList */] ? this._items.toArray() : this._items;\n    }\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nclass ActiveDescendantKeyManager extends a11y_ListKeyManager {\n    setActiveItem(index) {\n        if (this.activeItem) {\n            this.activeItem.setInactiveStyles();\n        }\n        super.setActiveItem(index);\n        if (this.activeItem) {\n            this.activeItem.setActiveStyles();\n        }\n    }\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nclass FocusKeyManager extends a11y_ListKeyManager {\n    constructor() {\n        super(...arguments);\n        this._origin = 'program';\n    }\n    /**\n     * Sets the focus origin that will be passed in to the items for any subsequent `focus` calls.\n     * @param origin Focus origin to be used when focusing items.\n     */\n    setFocusOrigin(origin) {\n        this._origin = origin;\n        return this;\n    }\n    setActiveItem(item) {\n        super.setActiveItem(item);\n        if (this.activeItem) {\n            this.activeItem.focus(this._origin);\n        }\n    }\n}\nlet a11y_InteractivityChecker = /*@__PURE__*/ (() => {\n    class InteractivityChecker {\n        constructor(_platform) {\n            this._platform = _platform;\n        }\n        /**\n         * Gets whether an element is disabled.\n         *\n         * @param element Element to be checked.\n         * @returns Whether the element is disabled.\n         */\n        isDisabled(element) {\n            // This does not capture some cases, such as a non-form control with a disabled attribute or\n            // a form control inside of a disabled form, but should capture the most common cases.\n            return element.hasAttribute('disabled');\n        }\n        /**\n         * Gets whether an element is visible for the purposes of interactivity.\n         *\n         * This will capture states like `display: none` and `visibility: hidden`, but not things like\n         * being clipped by an `overflow: hidden` parent or being outside the viewport.\n         *\n         * @returns Whether the element is visible.\n         */\n        isVisible(element) {\n            return hasGeometry(element) && getComputedStyle(element).visibility === 'visible';\n        }\n        /**\n         * Gets whether an element can be reached via Tab key.\n         * Assumes that the element has already been checked with isFocusable.\n         *\n         * @param element Element to be checked.\n         * @returns Whether the element is tabbable.\n         */\n        isTabbable(element) {\n            // Nothing is tabbable on the server 😎\n            if (!this._platform.isBrowser) {\n                return false;\n            }\n            const frameElement = getFrameElement(getWindow(element));\n            if (frameElement) {\n                const frameType = frameElement && frameElement.nodeName.toLowerCase();\n                // Frame elements inherit their tabindex onto all child elements.\n                if (getTabIndexValue(frameElement) === -1) {\n                    return false;\n                }\n                // Webkit and Blink consider anything inside of an <object> element as non-tabbable.\n                if ((this._platform.BLINK || this._platform.WEBKIT) && frameType === 'object') {\n                    return false;\n                }\n                // Webkit and Blink disable tabbing to an element inside of an invisible frame.\n                if ((this._platform.BLINK || this._platform.WEBKIT) && !this.isVisible(frameElement)) {\n                    return false;\n                }\n            }\n            let nodeName = element.nodeName.toLowerCase();\n            let tabIndexValue = getTabIndexValue(element);\n            if (element.hasAttribute('contenteditable')) {\n                return tabIndexValue !== -1;\n            }\n            if (nodeName === 'iframe') {\n                // The frames may be tabbable depending on content, but it's not possibly to reliably\n                // investigate the content of the frames.\n                return false;\n            }\n            if (nodeName === 'audio') {\n                if (!element.hasAttribute('controls')) {\n                    // By default an <audio> element without the controls enabled is not tabbable.\n                    return false;\n                }\n                else if (this._platform.BLINK) {\n                    // In Blink <audio controls> elements are always tabbable.\n                    return true;\n                }\n            }\n            if (nodeName === 'video') {\n                if (!element.hasAttribute('controls') && this._platform.TRIDENT) {\n                    // In Trident a <video> element without the controls enabled is not tabbable.\n                    return false;\n                }\n                else if (this._platform.BLINK || this._platform.FIREFOX) {\n                    // In Chrome and Firefox <video controls> elements are always tabbable.\n                    return true;\n                }\n            }\n            if (nodeName === 'object' && (this._platform.BLINK || this._platform.WEBKIT)) {\n                // In all Blink and WebKit based browsers <object> elements are never tabbable.\n                return false;\n            }\n            // In iOS the browser only considers some specific elements as tabbable.\n            if (this._platform.WEBKIT && this._platform.IOS && !isPotentiallyTabbableIOS(element)) {\n                return false;\n            }\n            return element.tabIndex >= 0;\n        }\n        /**\n         * Gets whether an element can be focused by the user.\n         *\n         * @param element Element to be checked.\n         * @returns Whether the element is focusable.\n         */\n        isFocusable(element) {\n            // Perform checks in order of left to most expensive.\n            // Again, naive approach that does not capture many edge cases and browser quirks.\n            return isPotentiallyFocusable(element) && !this.isDisabled(element) && this.isVisible(element);\n        }\n    }\n    InteractivityChecker.ɵfac = function InteractivityChecker_Factory(t) { return new (t || InteractivityChecker)(core[\"Zb\" /* ɵɵinject */](fesm2015_platform[\"a\" /* Platform */])); };\n    InteractivityChecker.ɵprov = /*@__PURE__*/ Object(core[\"Lb\" /* ɵɵdefineInjectable */])({ factory: function InteractivityChecker_Factory() { return new InteractivityChecker(Object(core[\"Zb\" /* ɵɵinject */])(fesm2015_platform[\"a\" /* Platform */])); }, token: InteractivityChecker, providedIn: \"root\" });\n    return InteractivityChecker;\n})();\n/**\n * Returns the frame element from a window object. Since browsers like MS Edge throw errors if\n * the frameElement property is being accessed from a different host address, this property\n * should be accessed carefully.\n */\nfunction getFrameElement(window) {\n    try {\n        return window.frameElement;\n    }\n    catch (_a) {\n        return null;\n    }\n}\n/** Checks whether the specified element has any geometry / rectangles. */\nfunction hasGeometry(element) {\n    // Use logic from jQuery to check for an invisible element.\n    // See https://github.com/jquery/jquery/blob/master/src/css/hiddenVisibleSelectors.js#L12\n    return !!(element.offsetWidth || element.offsetHeight ||\n        (typeof element.getClientRects === 'function' && element.getClientRects().length));\n}\n/** Gets whether an element's  */\nfunction isNativeFormElement(element) {\n    let nodeName = element.nodeName.toLowerCase();\n    return nodeName === 'input' ||\n        nodeName === 'select' ||\n        nodeName === 'button' ||\n        nodeName === 'textarea';\n}\n/** Gets whether an element is an `<input type=\"hidden\">`. */\nfunction isHiddenInput(element) {\n    return isInputElement(element) && element.type == 'hidden';\n}\n/** Gets whether an element is an anchor that has an href attribute. */\nfunction isAnchorWithHref(element) {\n    return isAnchorElement(element) && element.hasAttribute('href');\n}\n/** Gets whether an element is an input element. */\nfunction isInputElement(element) {\n    return element.nodeName.toLowerCase() == 'input';\n}\n/** Gets whether an element is an anchor element. */\nfunction isAnchorElement(element) {\n    return element.nodeName.toLowerCase() == 'a';\n}\n/** Gets whether an element has a valid tabindex. */\nfunction hasValidTabIndex(element) {\n    if (!element.hasAttribute('tabindex') || element.tabIndex === undefined) {\n        return false;\n    }\n    let tabIndex = element.getAttribute('tabindex');\n    // IE11 parses tabindex=\"\" as the value \"-32768\"\n    if (tabIndex == '-32768') {\n        return false;\n    }\n    return !!(tabIndex && !isNaN(parseInt(tabIndex, 10)));\n}\n/**\n * Returns the parsed tabindex from the element attributes instead of returning the\n * evaluated tabindex from the browsers defaults.\n */\nfunction getTabIndexValue(element) {\n    if (!hasValidTabIndex(element)) {\n        return null;\n    }\n    // See browser issue in Gecko https://bugzilla.mozilla.org/show_bug.cgi?id=1128054\n    const tabIndex = parseInt(element.getAttribute('tabindex') || '', 10);\n    return isNaN(tabIndex) ? -1 : tabIndex;\n}\n/** Checks whether the specified element is potentially tabbable on iOS */\nfunction isPotentiallyTabbableIOS(element) {\n    let nodeName = element.nodeName.toLowerCase();\n    let inputType = nodeName === 'input' && element.type;\n    return inputType === 'text'\n        || inputType === 'password'\n        || nodeName === 'select'\n        || nodeName === 'textarea';\n}\n/**\n * Gets whether an element is potentially focusable without taking current visible/disabled state\n * into account.\n */\nfunction isPotentiallyFocusable(element) {\n    // Inputs are potentially focusable *unless* they're type=\"hidden\".\n    if (isHiddenInput(element)) {\n        return false;\n    }\n    return isNativeFormElement(element) ||\n        isAnchorWithHref(element) ||\n        element.hasAttribute('contenteditable') ||\n        hasValidTabIndex(element);\n}\n/** Gets the parent window of a DOM node with regards of being inside of an iframe. */\nfunction getWindow(node) {\n    // ownerDocument is null if `node` itself *is* a document.\n    return node.ownerDocument && node.ownerDocument.defaultView || window;\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Class that allows for trapping focus within a DOM element.\n *\n * This class currently uses a relatively simple approach to focus trapping.\n * It assumes that the tab order is the same as DOM order, which is not necessarily true.\n * Things like `tabIndex > 0`, flex `order`, and shadow roots can cause the two to misalign.\n *\n * @deprecated Use `ConfigurableFocusTrap` instead.\n * @breaking-change for 11.0.0 Remove this class.\n */\nclass a11y_FocusTrap {\n    constructor(_element, _checker, _ngZone, _document, deferAnchors = false) {\n        this._element = _element;\n        this._checker = _checker;\n        this._ngZone = _ngZone;\n        this._document = _document;\n        this._hasAttached = false;\n        // Event listeners for the anchors. Need to be regular functions so that we can unbind them later.\n        this.startAnchorListener = () => this.focusLastTabbableElement();\n        this.endAnchorListener = () => this.focusFirstTabbableElement();\n        this._enabled = true;\n        if (!deferAnchors) {\n            this.attachAnchors();\n        }\n    }\n    /** Whether the focus trap is active. */\n    get enabled() { return this._enabled; }\n    set enabled(value) {\n        this._enabled = value;\n        if (this._startAnchor && this._endAnchor) {\n            this._toggleAnchorTabIndex(value, this._startAnchor);\n            this._toggleAnchorTabIndex(value, this._endAnchor);\n        }\n    }\n    /** Destroys the focus trap by cleaning up the anchors. */\n    destroy() {\n        const startAnchor = this._startAnchor;\n        const endAnchor = this._endAnchor;\n        if (startAnchor) {\n            startAnchor.removeEventListener('focus', this.startAnchorListener);\n            if (startAnchor.parentNode) {\n                startAnchor.parentNode.removeChild(startAnchor);\n            }\n        }\n        if (endAnchor) {\n            endAnchor.removeEventListener('focus', this.endAnchorListener);\n            if (endAnchor.parentNode) {\n                endAnchor.parentNode.removeChild(endAnchor);\n            }\n        }\n        this._startAnchor = this._endAnchor = null;\n        this._hasAttached = false;\n    }\n    /**\n     * Inserts the anchors into the DOM. This is usually done automatically\n     * in the constructor, but can be deferred for cases like directives with `*ngIf`.\n     * @returns Whether the focus trap managed to attach successfuly. This may not be the case\n     * if the target element isn't currently in the DOM.\n     */\n    attachAnchors() {\n        // If we're not on the browser, there can be no focus to trap.\n        if (this._hasAttached) {\n            return true;\n        }\n        this._ngZone.runOutsideAngular(() => {\n            if (!this._startAnchor) {\n                this._startAnchor = this._createAnchor();\n                this._startAnchor.addEventListener('focus', this.startAnchorListener);\n            }\n            if (!this._endAnchor) {\n                this._endAnchor = this._createAnchor();\n                this._endAnchor.addEventListener('focus', this.endAnchorListener);\n            }\n        });\n        if (this._element.parentNode) {\n            this._element.parentNode.insertBefore(this._startAnchor, this._element);\n            this._element.parentNode.insertBefore(this._endAnchor, this._element.nextSibling);\n            this._hasAttached = true;\n        }\n        return this._hasAttached;\n    }\n    /**\n     * Waits for the zone to stabilize, then either focuses the first element that the\n     * user specified, or the first tabbable element.\n     * @returns Returns a promise that resolves with a boolean, depending\n     * on whether focus was moved successfuly.\n     */\n    focusInitialElementWhenReady() {\n        return new Promise(resolve => {\n            this._executeOnStable(() => resolve(this.focusInitialElement()));\n        });\n    }\n    /**\n     * Waits for the zone to stabilize, then focuses\n     * the first tabbable element within the focus trap region.\n     * @returns Returns a promise that resolves with a boolean, depending\n     * on whether focus was moved successfuly.\n     */\n    focusFirstTabbableElementWhenReady() {\n        return new Promise(resolve => {\n            this._executeOnStable(() => resolve(this.focusFirstTabbableElement()));\n        });\n    }\n    /**\n     * Waits for the zone to stabilize, then focuses\n     * the last tabbable element within the focus trap region.\n     * @returns Returns a promise that resolves with a boolean, depending\n     * on whether focus was moved successfuly.\n     */\n    focusLastTabbableElementWhenReady() {\n        return new Promise(resolve => {\n            this._executeOnStable(() => resolve(this.focusLastTabbableElement()));\n        });\n    }\n    /**\n     * Get the specified boundary element of the trapped region.\n     * @param bound The boundary to get (start or end of trapped region).\n     * @returns The boundary element.\n     */\n    _getRegionBoundary(bound) {\n        // Contains the deprecated version of selector, for temporary backwards comparability.\n        let markers = this._element.querySelectorAll(`[cdk-focus-region-${bound}], ` +\n            `[cdkFocusRegion${bound}], ` +\n            `[cdk-focus-${bound}]`);\n        for (let i = 0; i < markers.length; i++) {\n            // @breaking-change 8.0.0\n            if (markers[i].hasAttribute(`cdk-focus-${bound}`)) {\n                console.warn(`Found use of deprecated attribute 'cdk-focus-${bound}', ` +\n                    `use 'cdkFocusRegion${bound}' instead. The deprecated ` +\n                    `attribute will be removed in 8.0.0.`, markers[i]);\n            }\n            else if (markers[i].hasAttribute(`cdk-focus-region-${bound}`)) {\n                console.warn(`Found use of deprecated attribute 'cdk-focus-region-${bound}', ` +\n                    `use 'cdkFocusRegion${bound}' instead. The deprecated attribute ` +\n                    `will be removed in 8.0.0.`, markers[i]);\n            }\n        }\n        if (bound == 'start') {\n            return markers.length ? markers[0] : this._getFirstTabbableElement(this._element);\n        }\n        return markers.length ?\n            markers[markers.length - 1] : this._getLastTabbableElement(this._element);\n    }\n    /**\n     * Focuses the element that should be focused when the focus trap is initialized.\n     * @returns Whether focus was moved successfuly.\n     */\n    focusInitialElement() {\n        // Contains the deprecated version of selector, for temporary backwards comparability.\n        const redirectToElement = this._element.querySelector(`[cdk-focus-initial], ` +\n            `[cdkFocusInitial]`);\n        if (redirectToElement) {\n            // @breaking-change 8.0.0\n            if (redirectToElement.hasAttribute(`cdk-focus-initial`)) {\n                console.warn(`Found use of deprecated attribute 'cdk-focus-initial', ` +\n                    `use 'cdkFocusInitial' instead. The deprecated attribute ` +\n                    `will be removed in 8.0.0`, redirectToElement);\n            }\n            // Warn the consumer if the element they've pointed to\n            // isn't focusable, when not in production mode.\n            if (Object(core[\"Y\" /* isDevMode */])() && !this._checker.isFocusable(redirectToElement)) {\n                console.warn(`Element matching '[cdkFocusInitial]' is not focusable.`, redirectToElement);\n            }\n            redirectToElement.focus();\n            return true;\n        }\n        return this.focusFirstTabbableElement();\n    }\n    /**\n     * Focuses the first tabbable element within the focus trap region.\n     * @returns Whether focus was moved successfuly.\n     */\n    focusFirstTabbableElement() {\n        const redirectToElement = this._getRegionBoundary('start');\n        if (redirectToElement) {\n            redirectToElement.focus();\n        }\n        return !!redirectToElement;\n    }\n    /**\n     * Focuses the last tabbable element within the focus trap region.\n     * @returns Whether focus was moved successfuly.\n     */\n    focusLastTabbableElement() {\n        const redirectToElement = this._getRegionBoundary('end');\n        if (redirectToElement) {\n            redirectToElement.focus();\n        }\n        return !!redirectToElement;\n    }\n    /**\n     * Checks whether the focus trap has successfuly been attached.\n     */\n    hasAttached() {\n        return this._hasAttached;\n    }\n    /** Get the first tabbable element from a DOM subtree (inclusive). */\n    _getFirstTabbableElement(root) {\n        if (this._checker.isFocusable(root) && this._checker.isTabbable(root)) {\n            return root;\n        }\n        // Iterate in DOM order. Note that IE doesn't have `children` for SVG so we fall\n        // back to `childNodes` which includes text nodes, comments etc.\n        let children = root.children || root.childNodes;\n        for (let i = 0; i < children.length; i++) {\n            let tabbableChild = children[i].nodeType === this._document.ELEMENT_NODE ?\n                this._getFirstTabbableElement(children[i]) :\n                null;\n            if (tabbableChild) {\n                return tabbableChild;\n            }\n        }\n        return null;\n    }\n    /** Get the last tabbable element from a DOM subtree (inclusive). */\n    _getLastTabbableElement(root) {\n        if (this._checker.isFocusable(root) && this._checker.isTabbable(root)) {\n            return root;\n        }\n        // Iterate in reverse DOM order.\n        let children = root.children || root.childNodes;\n        for (let i = children.length - 1; i >= 0; i--) {\n            let tabbableChild = children[i].nodeType === this._document.ELEMENT_NODE ?\n                this._getLastTabbableElement(children[i]) :\n                null;\n            if (tabbableChild) {\n                return tabbableChild;\n            }\n        }\n        return null;\n    }\n    /** Creates an anchor element. */\n    _createAnchor() {\n        const anchor = this._document.createElement('div');\n        this._toggleAnchorTabIndex(this._enabled, anchor);\n        anchor.classList.add('cdk-visually-hidden');\n        anchor.classList.add('cdk-focus-trap-anchor');\n        anchor.setAttribute('aria-hidden', 'true');\n        return anchor;\n    }\n    /**\n     * Toggles the `tabindex` of an anchor, based on the enabled state of the focus trap.\n     * @param isEnabled Whether the focus trap is enabled.\n     * @param anchor Anchor on which to toggle the tabindex.\n     */\n    _toggleAnchorTabIndex(isEnabled, anchor) {\n        // Remove the tabindex completely, rather than setting it to -1, because if the\n        // element has a tabindex, the user might still hit it when navigating with the arrow keys.\n        isEnabled ? anchor.setAttribute('tabindex', '0') : anchor.removeAttribute('tabindex');\n    }\n    /**\n     * Toggles the`tabindex` of both anchors to either trap Tab focus or allow it to escape.\n     * @param enabled: Whether the anchors should trap Tab.\n     */\n    toggleAnchors(enabled) {\n        if (this._startAnchor && this._endAnchor) {\n            this._toggleAnchorTabIndex(enabled, this._startAnchor);\n            this._toggleAnchorTabIndex(enabled, this._endAnchor);\n        }\n    }\n    /** Executes a function when the zone is stable. */\n    _executeOnStable(fn) {\n        if (this._ngZone.isStable) {\n            fn();\n        }\n        else {\n            this._ngZone.onStable.asObservable().pipe(Object(take[\"a\" /* take */])(1)).subscribe(fn);\n        }\n    }\n}\nlet a11y_FocusTrapFactory = /*@__PURE__*/ (() => {\n    class FocusTrapFactory {\n        constructor(_checker, _ngZone, _document) {\n            this._checker = _checker;\n            this._ngZone = _ngZone;\n            this._document = _document;\n        }\n        /**\n         * Creates a focus-trapped region around the given element.\n         * @param element The element around which focus will be trapped.\n         * @param deferCaptureElements Defers the creation of focus-capturing elements to be done\n         *     manually by the user.\n         * @returns The created focus trap instance.\n         */\n        create(element, deferCaptureElements = false) {\n            return new a11y_FocusTrap(element, this._checker, this._ngZone, this._document, deferCaptureElements);\n        }\n    }\n    FocusTrapFactory.ɵfac = function FocusTrapFactory_Factory(t) { return new (t || FocusTrapFactory)(core[\"Zb\" /* ɵɵinject */](a11y_InteractivityChecker), core[\"Zb\" /* ɵɵinject */](core[\"B\" /* NgZone */]), core[\"Zb\" /* ɵɵinject */](common[\"e\" /* DOCUMENT */])); };\n    FocusTrapFactory.ɵprov = /*@__PURE__*/ Object(core[\"Lb\" /* ɵɵdefineInjectable */])({ factory: function FocusTrapFactory_Factory() { return new FocusTrapFactory(Object(core[\"Zb\" /* ɵɵinject */])(a11y_InteractivityChecker), Object(core[\"Zb\" /* ɵɵinject */])(core[\"B\" /* NgZone */]), Object(core[\"Zb\" /* ɵɵinject */])(common[\"e\" /* DOCUMENT */])); }, token: FocusTrapFactory, providedIn: \"root\" });\n    return FocusTrapFactory;\n})();\nlet a11y_CdkTrapFocus = /*@__PURE__*/ (() => {\n    class CdkTrapFocus {\n        constructor(_elementRef, _focusTrapFactory, _document) {\n            this._elementRef = _elementRef;\n            this._focusTrapFactory = _focusTrapFactory;\n            /** Previously focused element to restore focus to upon destroy when using autoCapture. */\n            this._previouslyFocusedElement = null;\n            this._document = _document;\n            this.focusTrap = this._focusTrapFactory.create(this._elementRef.nativeElement, true);\n        }\n        /** Whether the focus trap is active. */\n        get enabled() { return this.focusTrap.enabled; }\n        set enabled(value) { this.focusTrap.enabled = coerceBooleanProperty(value); }\n        /**\n         * Whether the directive should automatially move focus into the trapped region upon\n         * initialization and return focus to the previous activeElement upon destruction.\n         */\n        get autoCapture() { return this._autoCapture; }\n        set autoCapture(value) { this._autoCapture = coerceBooleanProperty(value); }\n        ngOnDestroy() {\n            this.focusTrap.destroy();\n            // If we stored a previously focused element when using autoCapture, return focus to that\n            // element now that the trapped region is being destroyed.\n            if (this._previouslyFocusedElement) {\n                this._previouslyFocusedElement.focus();\n                this._previouslyFocusedElement = null;\n            }\n        }\n        ngAfterContentInit() {\n            this.focusTrap.attachAnchors();\n            if (this.autoCapture) {\n                this._captureFocus();\n            }\n        }\n        ngDoCheck() {\n            if (!this.focusTrap.hasAttached()) {\n                this.focusTrap.attachAnchors();\n            }\n        }\n        ngOnChanges(changes) {\n            const autoCaptureChange = changes['autoCapture'];\n            if (autoCaptureChange && !autoCaptureChange.firstChange && this.autoCapture &&\n                this.focusTrap.hasAttached()) {\n                this._captureFocus();\n            }\n        }\n        _captureFocus() {\n            this._previouslyFocusedElement = this._document.activeElement;\n            this.focusTrap.focusInitialElementWhenReady();\n        }\n    }\n    CdkTrapFocus.ɵfac = function CdkTrapFocus_Factory(t) { return new (t || CdkTrapFocus)(core[\"Pb\" /* ɵɵdirectiveInject */](core[\"m\" /* ElementRef */]), core[\"Pb\" /* ɵɵdirectiveInject */](a11y_FocusTrapFactory), core[\"Pb\" /* ɵɵdirectiveInject */](common[\"e\" /* DOCUMENT */])); };\n    CdkTrapFocus.ɵdir = /*@__PURE__*/ core[\"Kb\" /* ɵɵdefineDirective */]({ type: CdkTrapFocus, selectors: [[\"\", \"cdkTrapFocus\", \"\"]], inputs: { enabled: [\"cdkTrapFocus\", \"enabled\"], autoCapture: [\"cdkTrapFocusAutoCapture\", \"autoCapture\"] }, exportAs: [\"cdkTrapFocus\"], features: [core[\"Bb\" /* ɵɵNgOnChangesFeature */]] });\n    return CdkTrapFocus;\n})();\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Class that allows for trapping focus within a DOM element.\n *\n * This class uses a strategy pattern that determines how it traps focus.\n * See FocusTrapInertStrategy.\n */\nclass ConfigurableFocusTrap extends a11y_FocusTrap {\n    constructor(_element, _checker, _ngZone, _document, _focusTrapManager, _inertStrategy, config) {\n        super(_element, _checker, _ngZone, _document, config.defer);\n        this._focusTrapManager = _focusTrapManager;\n        this._inertStrategy = _inertStrategy;\n        this._focusTrapManager.register(this);\n    }\n    /** Whether the FocusTrap is enabled. */\n    get enabled() { return this._enabled; }\n    set enabled(value) {\n        this._enabled = value;\n        if (this._enabled) {\n            this._focusTrapManager.register(this);\n        }\n        else {\n            this._focusTrapManager.deregister(this);\n        }\n    }\n    /** Notifies the FocusTrapManager that this FocusTrap will be destroyed. */\n    destroy() {\n        this._focusTrapManager.deregister(this);\n        super.destroy();\n    }\n    /** @docs-private Implemented as part of ManagedFocusTrap. */\n    _enable() {\n        this._inertStrategy.preventFocus(this);\n        this.toggleAnchors(true);\n    }\n    /** @docs-private Implemented as part of ManagedFocusTrap. */\n    _disable() {\n        this._inertStrategy.allowFocus(this);\n        this.toggleAnchors(false);\n    }\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/** IE 11 compatible closest implementation that is able to start from non-Element Nodes. */\nfunction closest(element, selector) {\n    if (!(element instanceof Node)) {\n        return null;\n    }\n    let curr = element;\n    while (curr != null && !(curr instanceof Element)) {\n        curr = curr.parentNode;\n    }\n    return curr && (hasNativeClosest ?\n        curr.closest(selector) : polyfillClosest(curr, selector));\n}\n/** Polyfill for browsers without Element.closest. */\nfunction polyfillClosest(element, selector) {\n    let curr = element;\n    while (curr != null && !(curr instanceof Element && matches(curr, selector))) {\n        curr = curr.parentNode;\n    }\n    return (curr || null);\n}\nconst hasNativeClosest = typeof Element != 'undefined' && !!Element.prototype.closest;\n/** IE 11 compatible matches implementation. */\nfunction matches(element, selector) {\n    return element.matches ?\n        element.matches(selector) :\n        element['msMatchesSelector'](selector);\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Lightweight FocusTrapInertStrategy that adds a document focus event\n * listener to redirect focus back inside the FocusTrap.\n */\nclass EventListenerFocusTrapInertStrategy {\n    constructor() {\n        /** Focus event handler. */\n        this._listener = null;\n    }\n    /** Adds a document event listener that keeps focus inside the FocusTrap. */\n    preventFocus(focusTrap) {\n        // Ensure there's only one listener per document\n        if (this._listener) {\n            focusTrap._document.removeEventListener('focus', this._listener, true);\n        }\n        this._listener = (e) => this._trapFocus(focusTrap, e);\n        focusTrap._ngZone.runOutsideAngular(() => {\n            focusTrap._document.addEventListener('focus', this._listener, true);\n        });\n    }\n    /** Removes the event listener added in preventFocus. */\n    allowFocus(focusTrap) {\n        if (!this._listener) {\n            return;\n        }\n        focusTrap._document.removeEventListener('focus', this._listener, true);\n        this._listener = null;\n    }\n    /**\n     * Refocuses the first element in the FocusTrap if the focus event target was outside\n     * the FocusTrap.\n     *\n     * This is an event listener callback. The event listener is added in runOutsideAngular,\n     * so all this code runs outside Angular as well.\n     */\n    _trapFocus(focusTrap, event) {\n        const target = event.target;\n        const focusTrapRoot = focusTrap._element;\n        // Don't refocus if target was in an overlay, because the overlay might be associated\n        // with an element inside the FocusTrap, ex. mat-select.\n        if (!focusTrapRoot.contains(target) && closest(target, 'div.cdk-overlay-pane') === null) {\n            // Some legacy FocusTrap usages have logic that focuses some element on the page\n            // just before FocusTrap is destroyed. For backwards compatibility, wait\n            // to be sure FocusTrap is still enabled before refocusing.\n            setTimeout(() => {\n                // Check whether focus wasn't put back into the focus trap while the timeout was pending.\n                if (focusTrap.enabled && !focusTrapRoot.contains(focusTrap._document.activeElement)) {\n                    focusTrap.focusFirstTabbableElement();\n                }\n            });\n        }\n    }\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Configuration for creating a ConfigurableFocusTrap.\n */\nclass ConfigurableFocusTrapConfig {\n    constructor() {\n        /**\n         * Whether to defer the creation of FocusTrap elements to be\n         * done manually by the user. Default is to create them\n         * automatically.\n         */\n        this.defer = false;\n    }\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/** The injection token used to specify the inert strategy. */\nconst FOCUS_TRAP_INERT_STRATEGY = /*@__PURE__*/ new core[\"s\" /* InjectionToken */]('FOCUS_TRAP_INERT_STRATEGY');\nlet a11y_FocusTrapManager = /*@__PURE__*/ (() => {\n    class FocusTrapManager {\n        constructor() {\n            // A stack of the FocusTraps on the page. Only the FocusTrap at the\n            // top of the stack is active.\n            this._focusTrapStack = [];\n        }\n        /**\n         * Disables the FocusTrap at the top of the stack, and then pushes\n         * the new FocusTrap onto the stack.\n         */\n        register(focusTrap) {\n            // Dedupe focusTraps that register multiple times.\n            this._focusTrapStack = this._focusTrapStack.filter((ft) => ft !== focusTrap);\n            let stack = this._focusTrapStack;\n            if (stack.length) {\n                stack[stack.length - 1]._disable();\n            }\n            stack.push(focusTrap);\n            focusTrap._enable();\n        }\n        /**\n         * Removes the FocusTrap from the stack, and activates the\n         * FocusTrap that is the new top of the stack.\n         */\n        deregister(focusTrap) {\n            focusTrap._disable();\n            const stack = this._focusTrapStack;\n            const i = stack.indexOf(focusTrap);\n            if (i !== -1) {\n                stack.splice(i, 1);\n                if (stack.length) {\n                    stack[stack.length - 1]._enable();\n                }\n            }\n        }\n    }\n    FocusTrapManager.ɵfac = function FocusTrapManager_Factory(t) { return new (t || FocusTrapManager)(); };\n    FocusTrapManager.ɵprov = /*@__PURE__*/ Object(core[\"Lb\" /* ɵɵdefineInjectable */])({ factory: function FocusTrapManager_Factory() { return new FocusTrapManager(); }, token: FocusTrapManager, providedIn: \"root\" });\n    return FocusTrapManager;\n})();\nlet a11y_ConfigurableFocusTrapFactory = /*@__PURE__*/ (() => {\n    class ConfigurableFocusTrapFactory {\n        constructor(_checker, _ngZone, _focusTrapManager, _document, _inertStrategy) {\n            this._checker = _checker;\n            this._ngZone = _ngZone;\n            this._focusTrapManager = _focusTrapManager;\n            this._document = _document;\n            // TODO split up the strategies into different modules, similar to DateAdapter.\n            this._inertStrategy = _inertStrategy || new EventListenerFocusTrapInertStrategy();\n        }\n        create(element, config = new ConfigurableFocusTrapConfig()) {\n            let configObject;\n            if (typeof config === 'boolean') {\n                configObject = new ConfigurableFocusTrapConfig();\n                configObject.defer = config;\n            }\n            else {\n                configObject = config;\n            }\n            return new ConfigurableFocusTrap(element, this._checker, this._ngZone, this._document, this._focusTrapManager, this._inertStrategy, configObject);\n        }\n    }\n    ConfigurableFocusTrapFactory.ɵfac = function ConfigurableFocusTrapFactory_Factory(t) { return new (t || ConfigurableFocusTrapFactory)(core[\"Zb\" /* ɵɵinject */](a11y_InteractivityChecker), core[\"Zb\" /* ɵɵinject */](core[\"B\" /* NgZone */]), core[\"Zb\" /* ɵɵinject */](a11y_FocusTrapManager), core[\"Zb\" /* ɵɵinject */](common[\"e\" /* DOCUMENT */]), core[\"Zb\" /* ɵɵinject */](FOCUS_TRAP_INERT_STRATEGY, 8)); };\n    ConfigurableFocusTrapFactory.ɵprov = /*@__PURE__*/ Object(core[\"Lb\" /* ɵɵdefineInjectable */])({ factory: function ConfigurableFocusTrapFactory_Factory() { return new ConfigurableFocusTrapFactory(Object(core[\"Zb\" /* ɵɵinject */])(a11y_InteractivityChecker), Object(core[\"Zb\" /* ɵɵinject */])(core[\"B\" /* NgZone */]), Object(core[\"Zb\" /* ɵɵinject */])(a11y_FocusTrapManager), Object(core[\"Zb\" /* ɵɵinject */])(common[\"e\" /* DOCUMENT */]), Object(core[\"Zb\" /* ɵɵinject */])(FOCUS_TRAP_INERT_STRATEGY, 8)); }, token: ConfigurableFocusTrapFactory, providedIn: \"root\" });\n    return ConfigurableFocusTrapFactory;\n})();\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nconst LIVE_ANNOUNCER_ELEMENT_TOKEN = /*@__PURE__*/ new core[\"s\" /* InjectionToken */]('liveAnnouncerElement', {\n    providedIn: 'root',\n    factory: LIVE_ANNOUNCER_ELEMENT_TOKEN_FACTORY,\n});\n/** @docs-private */\nfunction LIVE_ANNOUNCER_ELEMENT_TOKEN_FACTORY() {\n    return null;\n}\n/** Injection token that can be used to configure the default options for the LiveAnnouncer. */\nconst LIVE_ANNOUNCER_DEFAULT_OPTIONS = /*@__PURE__*/ new core[\"s\" /* InjectionToken */]('LIVE_ANNOUNCER_DEFAULT_OPTIONS');\nlet a11y_LiveAnnouncer = /*@__PURE__*/ (() => {\n    class LiveAnnouncer {\n        constructor(elementToken, _ngZone, _document, _defaultOptions) {\n            this._ngZone = _ngZone;\n            this._defaultOptions = _defaultOptions;\n            // We inject the live element and document as `any` because the constructor signature cannot\n            // reference browser globals (HTMLElement, Document) on non-browser environments, since having\n            // a class decorator causes TypeScript to preserve the constructor signature types.\n            this._document = _document;\n            this._liveElement = elementToken || this._createLiveElement();\n        }\n        announce(message, ...args) {\n            const defaultOptions = this._defaultOptions;\n            let politeness;\n            let duration;\n            if (args.length === 1 && typeof args[0] === 'number') {\n                duration = args[0];\n            }\n            else {\n                [politeness, duration] = args;\n            }\n            this.clear();\n            clearTimeout(this._previousTimeout);\n            if (!politeness) {\n                politeness =\n                    (defaultOptions && defaultOptions.politeness) ? defaultOptions.politeness : 'polite';\n            }\n            if (duration == null && defaultOptions) {\n                duration = defaultOptions.duration;\n            }\n            // TODO: ensure changing the politeness works on all environments we support.\n            this._liveElement.setAttribute('aria-live', politeness);\n            // This 100ms timeout is necessary for some browser + screen-reader combinations:\n            // - Both JAWS and NVDA over IE11 will not announce anything without a non-zero timeout.\n            // - With Chrome and IE11 with NVDA or JAWS, a repeated (identical) message won't be read a\n            //   second time without clearing and then using a non-zero delay.\n            // (using JAWS 17 at time of this writing).\n            return this._ngZone.runOutsideAngular(() => {\n                return new Promise(resolve => {\n                    clearTimeout(this._previousTimeout);\n                    this._previousTimeout = setTimeout(() => {\n                        this._liveElement.textContent = message;\n                        resolve();\n                        if (typeof duration === 'number') {\n                            this._previousTimeout = setTimeout(() => this.clear(), duration);\n                        }\n                    }, 100);\n                });\n            });\n        }\n        /**\n         * Clears the current text from the announcer element. Can be used to prevent\n         * screen readers from reading the text out again while the user is going\n         * through the page landmarks.\n         */\n        clear() {\n            if (this._liveElement) {\n                this._liveElement.textContent = '';\n            }\n        }\n        ngOnDestroy() {\n            clearTimeout(this._previousTimeout);\n            if (this._liveElement && this._liveElement.parentNode) {\n                this._liveElement.parentNode.removeChild(this._liveElement);\n                this._liveElement = null;\n            }\n        }\n        _createLiveElement() {\n            const elementClass = 'cdk-live-announcer-element';\n            const previousElements = this._document.getElementsByClassName(elementClass);\n            const liveEl = this._document.createElement('div');\n            // Remove any old containers. This can happen when coming in from a server-side-rendered page.\n            for (let i = 0; i < previousElements.length; i++) {\n                previousElements[i].parentNode.removeChild(previousElements[i]);\n            }\n            liveEl.classList.add(elementClass);\n            liveEl.classList.add('cdk-visually-hidden');\n            liveEl.setAttribute('aria-atomic', 'true');\n            liveEl.setAttribute('aria-live', 'polite');\n            this._document.body.appendChild(liveEl);\n            return liveEl;\n        }\n    }\n    LiveAnnouncer.ɵfac = function LiveAnnouncer_Factory(t) { return new (t || LiveAnnouncer)(core[\"Zb\" /* ɵɵinject */](LIVE_ANNOUNCER_ELEMENT_TOKEN, 8), core[\"Zb\" /* ɵɵinject */](core[\"B\" /* NgZone */]), core[\"Zb\" /* ɵɵinject */](common[\"e\" /* DOCUMENT */]), core[\"Zb\" /* ɵɵinject */](LIVE_ANNOUNCER_DEFAULT_OPTIONS, 8)); };\n    LiveAnnouncer.ɵprov = /*@__PURE__*/ Object(core[\"Lb\" /* ɵɵdefineInjectable */])({ factory: function LiveAnnouncer_Factory() { return new LiveAnnouncer(Object(core[\"Zb\" /* ɵɵinject */])(LIVE_ANNOUNCER_ELEMENT_TOKEN, 8), Object(core[\"Zb\" /* ɵɵinject */])(core[\"B\" /* NgZone */]), Object(core[\"Zb\" /* ɵɵinject */])(common[\"e\" /* DOCUMENT */]), Object(core[\"Zb\" /* ɵɵinject */])(LIVE_ANNOUNCER_DEFAULT_OPTIONS, 8)); }, token: LiveAnnouncer, providedIn: \"root\" });\n    return LiveAnnouncer;\n})();\nlet a11y_CdkAriaLive = /*@__PURE__*/ (() => {\n    class CdkAriaLive {\n        constructor(_elementRef, _liveAnnouncer, _contentObserver, _ngZone) {\n            this._elementRef = _elementRef;\n            this._liveAnnouncer = _liveAnnouncer;\n            this._contentObserver = _contentObserver;\n            this._ngZone = _ngZone;\n            this._politeness = 'off';\n        }\n        /** The aria-live politeness level to use when announcing messages. */\n        get politeness() { return this._politeness; }\n        set politeness(value) {\n            this._politeness = value === 'polite' || value === 'assertive' ? value : 'off';\n            if (this._politeness === 'off') {\n                if (this._subscription) {\n                    this._subscription.unsubscribe();\n                    this._subscription = null;\n                }\n            }\n            else if (!this._subscription) {\n                this._subscription = this._ngZone.runOutsideAngular(() => {\n                    return this._contentObserver\n                        .observe(this._elementRef)\n                        .subscribe(() => {\n                        // Note that we use textContent here, rather than innerText, in order to avoid a reflow.\n                        const elementText = this._elementRef.nativeElement.textContent;\n                        // The `MutationObserver` fires also for attribute\n                        // changes which we don't want to announce.\n                        if (elementText !== this._previousAnnouncedText) {\n                            this._liveAnnouncer.announce(elementText, this._politeness);\n                            this._previousAnnouncedText = elementText;\n                        }\n                    });\n                });\n            }\n        }\n        ngOnDestroy() {\n            if (this._subscription) {\n                this._subscription.unsubscribe();\n            }\n        }\n    }\n    CdkAriaLive.ɵfac = function CdkAriaLive_Factory(t) { return new (t || CdkAriaLive)(core[\"Pb\" /* ɵɵdirectiveInject */](core[\"m\" /* ElementRef */]), core[\"Pb\" /* ɵɵdirectiveInject */](a11y_LiveAnnouncer), core[\"Pb\" /* ɵɵdirectiveInject */](observers_ContentObserver), core[\"Pb\" /* ɵɵdirectiveInject */](core[\"B\" /* NgZone */])); };\n    CdkAriaLive.ɵdir = /*@__PURE__*/ core[\"Kb\" /* ɵɵdefineDirective */]({ type: CdkAriaLive, selectors: [[\"\", \"cdkAriaLive\", \"\"]], inputs: { politeness: [\"cdkAriaLive\", \"politeness\"] }, exportAs: [\"cdkAriaLive\"] });\n    return CdkAriaLive;\n})();\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Screenreaders will often fire fake mousedown events when a focusable element\n * is activated using the keyboard. We can typically distinguish between these faked\n * mousedown events and real mousedown events using the \"buttons\" property. While\n * real mousedowns will indicate the mouse button that was pressed (e.g. \"1\" for\n * the left mouse button), faked mousedowns will usually set the property value to 0.\n */\nfunction isFakeMousedownFromScreenReader(event) {\n    return event.buttons === 0;\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n// This is the value used by AngularJS Material. Through trial and error (on iPhone 6S) they found\n// that a value of around 650ms seems appropriate.\nconst TOUCH_BUFFER_MS = 650;\n/** InjectionToken for FocusMonitorOptions. */\nconst FOCUS_MONITOR_DEFAULT_OPTIONS = /*@__PURE__*/ new core[\"s\" /* InjectionToken */]('cdk-focus-monitor-default-options');\n/**\n * Event listener options that enable capturing and also\n * mark the listener as passive if the browser supports it.\n */\nconst captureEventListenerOptions = /*@__PURE__*/ Object(fesm2015_platform[\"e\" /* normalizePassiveListenerOptions */])({\n    passive: true,\n    capture: true\n});\nlet a11y_FocusMonitor = /*@__PURE__*/ (() => {\n    class FocusMonitor {\n        constructor(_ngZone, _platform, \n        /** @breaking-change 11.0.0 make document required */\n        document, options) {\n            this._ngZone = _ngZone;\n            this._platform = _platform;\n            /** The focus origin that the next focus event is a result of. */\n            this._origin = null;\n            /** Whether the window has just been focused. */\n            this._windowFocused = false;\n            /** Map of elements being monitored to their info. */\n            this._elementInfo = new Map();\n            /** The number of elements currently being monitored. */\n            this._monitoredElementCount = 0;\n            /**\n             * Keeps track of the root nodes to which we've currently bound a focus/blur handler,\n             * as well as the number of monitored elements that they contain. We have to treat focus/blur\n             * handlers differently from the rest of the events, because the browser won't emit events\n             * to the document when focus moves inside of a shadow root.\n             */\n            this._rootNodeFocusListenerCount = new Map();\n            /**\n             * Event listener for `keydown` events on the document.\n             * Needs to be an arrow function in order to preserve the context when it gets bound.\n             */\n            this._documentKeydownListener = () => {\n                // On keydown record the origin and clear any touch event that may be in progress.\n                this._lastTouchTarget = null;\n                this._setOriginForCurrentEventQueue('keyboard');\n            };\n            /**\n             * Event listener for `mousedown` events on the document.\n             * Needs to be an arrow function in order to preserve the context when it gets bound.\n             */\n            this._documentMousedownListener = (event) => {\n                // On mousedown record the origin only if there is not touch\n                // target, since a mousedown can happen as a result of a touch event.\n                if (!this._lastTouchTarget) {\n                    // In some cases screen readers fire fake `mousedown` events instead of `keydown`.\n                    // Resolve the focus source to `keyboard` if we detect one of them.\n                    const source = isFakeMousedownFromScreenReader(event) ? 'keyboard' : 'mouse';\n                    this._setOriginForCurrentEventQueue(source);\n                }\n            };\n            /**\n             * Event listener for `touchstart` events on the document.\n             * Needs to be an arrow function in order to preserve the context when it gets bound.\n             */\n            this._documentTouchstartListener = (event) => {\n                // When the touchstart event fires the focus event is not yet in the event queue. This means\n                // we can't rely on the trick used above (setting timeout of 1ms). Instead we wait 650ms to\n                // see if a focus happens.\n                if (this._touchTimeoutId != null) {\n                    clearTimeout(this._touchTimeoutId);\n                }\n                this._lastTouchTarget = getTarget(event);\n                this._touchTimeoutId = setTimeout(() => this._lastTouchTarget = null, TOUCH_BUFFER_MS);\n            };\n            /**\n             * Event listener for `focus` events on the window.\n             * Needs to be an arrow function in order to preserve the context when it gets bound.\n             */\n            this._windowFocusListener = () => {\n                // Make a note of when the window regains focus, so we can\n                // restore the origin info for the focused element.\n                this._windowFocused = true;\n                this._windowFocusTimeoutId = setTimeout(() => this._windowFocused = false);\n            };\n            /**\n             * Event listener for `focus` and 'blur' events on the document.\n             * Needs to be an arrow function in order to preserve the context when it gets bound.\n             */\n            this._rootNodeFocusAndBlurListener = (event) => {\n                const target = getTarget(event);\n                const handler = event.type === 'focus' ? this._onFocus : this._onBlur;\n                // We need to walk up the ancestor chain in order to support `checkChildren`.\n                for (let element = target; element; element = element.parentElement) {\n                    handler.call(this, event, element);\n                }\n            };\n            this._document = document;\n            this._detectionMode = (options === null || options === void 0 ? void 0 : options.detectionMode) || 0 /* IMMEDIATE */;\n        }\n        monitor(element, checkChildren = false) {\n            // Do nothing if we're not on the browser platform.\n            if (!this._platform.isBrowser) {\n                return Object(of[\"a\" /* of */])(null);\n            }\n            const nativeElement = coerceElement(element);\n            // If the element is inside the shadow DOM, we need to bind our focus/blur listeners to\n            // the shadow root, rather than the `document`, because the browser won't emit focus events\n            // to the `document`, if focus is moving within the same shadow root.\n            const rootNode = Object(fesm2015_platform[\"c\" /* _getShadowRoot */])(nativeElement) || this._getDocument();\n            const cachedInfo = this._elementInfo.get(nativeElement);\n            // Check if we're already monitoring this element.\n            if (cachedInfo) {\n                if (checkChildren) {\n                    // TODO(COMP-318): this can be problematic, because it'll turn all non-checkChildren\n                    // observers into ones that behave as if `checkChildren` was turned on. We need a more\n                    // robust solution.\n                    cachedInfo.checkChildren = true;\n                }\n                return cachedInfo.subject.asObservable();\n            }\n            // Create monitored element info.\n            const info = {\n                checkChildren: checkChildren,\n                subject: new Subject[\"a\" /* Subject */](),\n                rootNode\n            };\n            this._elementInfo.set(nativeElement, info);\n            this._registerGlobalListeners(info);\n            return info.subject.asObservable();\n        }\n        stopMonitoring(element) {\n            const nativeElement = coerceElement(element);\n            const elementInfo = this._elementInfo.get(nativeElement);\n            if (elementInfo) {\n                elementInfo.subject.complete();\n                this._setClasses(nativeElement);\n                this._elementInfo.delete(nativeElement);\n                this._removeGlobalListeners(elementInfo);\n            }\n        }\n        focusVia(element, origin, options) {\n            const nativeElement = coerceElement(element);\n            this._setOriginForCurrentEventQueue(origin);\n            // `focus` isn't available on the server\n            if (typeof nativeElement.focus === 'function') {\n                // Cast the element to `any`, because the TS typings don't have the `options` parameter yet.\n                nativeElement.focus(options);\n            }\n        }\n        ngOnDestroy() {\n            this._elementInfo.forEach((_info, element) => this.stopMonitoring(element));\n        }\n        /** Access injected document if available or fallback to global document reference */\n        _getDocument() {\n            return this._document || document;\n        }\n        /** Use defaultView of injected document if available or fallback to global window reference */\n        _getWindow() {\n            const doc = this._getDocument();\n            return doc.defaultView || window;\n        }\n        _toggleClass(element, className, shouldSet) {\n            if (shouldSet) {\n                element.classList.add(className);\n            }\n            else {\n                element.classList.remove(className);\n            }\n        }\n        _getFocusOrigin(event) {\n            // If we couldn't detect a cause for the focus event, it's due to one of three reasons:\n            // 1) The window has just regained focus, in which case we want to restore the focused state of\n            //    the element from before the window blurred.\n            // 2) It was caused by a touch event, in which case we mark the origin as 'touch'.\n            // 3) The element was programmatically focused, in which case we should mark the origin as\n            //    'program'.\n            if (this._origin) {\n                return this._origin;\n            }\n            if (this._windowFocused && this._lastFocusOrigin) {\n                return this._lastFocusOrigin;\n            }\n            else if (this._wasCausedByTouch(event)) {\n                return 'touch';\n            }\n            else {\n                return 'program';\n            }\n        }\n        /**\n         * Sets the focus classes on the element based on the given focus origin.\n         * @param element The element to update the classes on.\n         * @param origin The focus origin.\n         */\n        _setClasses(element, origin) {\n            this._toggleClass(element, 'cdk-focused', !!origin);\n            this._toggleClass(element, 'cdk-touch-focused', origin === 'touch');\n            this._toggleClass(element, 'cdk-keyboard-focused', origin === 'keyboard');\n            this._toggleClass(element, 'cdk-mouse-focused', origin === 'mouse');\n            this._toggleClass(element, 'cdk-program-focused', origin === 'program');\n        }\n        /**\n         * Sets the origin and schedules an async function to clear it at the end of the event queue.\n         * If the detection mode is 'eventual', the origin is never cleared.\n         * @param origin The origin to set.\n         */\n        _setOriginForCurrentEventQueue(origin) {\n            this._ngZone.runOutsideAngular(() => {\n                this._origin = origin;\n                if (this._detectionMode === 0 /* IMMEDIATE */) {\n                    // Sometimes the focus origin won't be valid in Firefox because Firefox seems to focus *one*\n                    // tick after the interaction event fired. To ensure the focus origin is always correct,\n                    // the focus origin will be determined at the beginning of the next tick.\n                    this._originTimeoutId = setTimeout(() => this._origin = null, 1);\n                }\n            });\n        }\n        /**\n         * Checks whether the given focus event was caused by a touchstart event.\n         * @param event The focus event to check.\n         * @returns Whether the event was caused by a touch.\n         */\n        _wasCausedByTouch(event) {\n            // Note(mmalerba): This implementation is not quite perfect, there is a small edge case.\n            // Consider the following dom structure:\n            //\n            // <div #parent tabindex=\"0\" cdkFocusClasses>\n            //   <div #child (click)=\"#parent.focus()\"></div>\n            // </div>\n            //\n            // If the user touches the #child element and the #parent is programmatically focused as a\n            // result, this code will still consider it to have been caused by the touch event and will\n            // apply the cdk-touch-focused class rather than the cdk-program-focused class. This is a\n            // relatively small edge-case that can be worked around by using\n            // focusVia(parentEl, 'program') to focus the parent element.\n            //\n            // If we decide that we absolutely must handle this case correctly, we can do so by listening\n            // for the first focus event after the touchstart, and then the first blur event after that\n            // focus event. When that blur event fires we know that whatever follows is not a result of the\n            // touchstart.\n            const focusTarget = getTarget(event);\n            return this._lastTouchTarget instanceof Node && focusTarget instanceof Node &&\n                (focusTarget === this._lastTouchTarget || focusTarget.contains(this._lastTouchTarget));\n        }\n        /**\n         * Handles focus events on a registered element.\n         * @param event The focus event.\n         * @param element The monitored element.\n         */\n        _onFocus(event, element) {\n            // NOTE(mmalerba): We currently set the classes based on the focus origin of the most recent\n            // focus event affecting the monitored element. If we want to use the origin of the first event\n            // instead we should check for the cdk-focused class here and return if the element already has\n            // it. (This only matters for elements that have includesChildren = true).\n            // If we are not counting child-element-focus as focused, make sure that the event target is the\n            // monitored element itself.\n            const elementInfo = this._elementInfo.get(element);\n            if (!elementInfo || (!elementInfo.checkChildren && element !== getTarget(event))) {\n                return;\n            }\n            const origin = this._getFocusOrigin(event);\n            this._setClasses(element, origin);\n            this._emitOrigin(elementInfo.subject, origin);\n            this._lastFocusOrigin = origin;\n        }\n        /**\n         * Handles blur events on a registered element.\n         * @param event The blur event.\n         * @param element The monitored element.\n         */\n        _onBlur(event, element) {\n            // If we are counting child-element-focus as focused, make sure that we aren't just blurring in\n            // order to focus another child of the monitored element.\n            const elementInfo = this._elementInfo.get(element);\n            if (!elementInfo || (elementInfo.checkChildren && event.relatedTarget instanceof Node &&\n                element.contains(event.relatedTarget))) {\n                return;\n            }\n            this._setClasses(element);\n            this._emitOrigin(elementInfo.subject, null);\n        }\n        _emitOrigin(subject, origin) {\n            this._ngZone.run(() => subject.next(origin));\n        }\n        _registerGlobalListeners(elementInfo) {\n            if (!this._platform.isBrowser) {\n                return;\n            }\n            const rootNode = elementInfo.rootNode;\n            const rootNodeFocusListeners = this._rootNodeFocusListenerCount.get(rootNode) || 0;\n            if (!rootNodeFocusListeners) {\n                this._ngZone.runOutsideAngular(() => {\n                    rootNode.addEventListener('focus', this._rootNodeFocusAndBlurListener, captureEventListenerOptions);\n                    rootNode.addEventListener('blur', this._rootNodeFocusAndBlurListener, captureEventListenerOptions);\n                });\n            }\n            this._rootNodeFocusListenerCount.set(rootNode, rootNodeFocusListeners + 1);\n            // Register global listeners when first element is monitored.\n            if (++this._monitoredElementCount === 1) {\n                // Note: we listen to events in the capture phase so we\n                // can detect them even if the user stops propagation.\n                this._ngZone.runOutsideAngular(() => {\n                    const document = this._getDocument();\n                    const window = this._getWindow();\n                    document.addEventListener('keydown', this._documentKeydownListener, captureEventListenerOptions);\n                    document.addEventListener('mousedown', this._documentMousedownListener, captureEventListenerOptions);\n                    document.addEventListener('touchstart', this._documentTouchstartListener, captureEventListenerOptions);\n                    window.addEventListener('focus', this._windowFocusListener);\n                });\n            }\n        }\n        _removeGlobalListeners(elementInfo) {\n            const rootNode = elementInfo.rootNode;\n            if (this._rootNodeFocusListenerCount.has(rootNode)) {\n                const rootNodeFocusListeners = this._rootNodeFocusListenerCount.get(rootNode);\n                if (rootNodeFocusListeners > 1) {\n                    this._rootNodeFocusListenerCount.set(rootNode, rootNodeFocusListeners - 1);\n                }\n                else {\n                    rootNode.removeEventListener('focus', this._rootNodeFocusAndBlurListener, captureEventListenerOptions);\n                    rootNode.removeEventListener('blur', this._rootNodeFocusAndBlurListener, captureEventListenerOptions);\n                    this._rootNodeFocusListenerCount.delete(rootNode);\n                }\n            }\n            // Unregister global listeners when last element is unmonitored.\n            if (!--this._monitoredElementCount) {\n                const document = this._getDocument();\n                const window = this._getWindow();\n                document.removeEventListener('keydown', this._documentKeydownListener, captureEventListenerOptions);\n                document.removeEventListener('mousedown', this._documentMousedownListener, captureEventListenerOptions);\n                document.removeEventListener('touchstart', this._documentTouchstartListener, captureEventListenerOptions);\n                window.removeEventListener('focus', this._windowFocusListener);\n                // Clear timeouts for all potentially pending timeouts to prevent the leaks.\n                clearTimeout(this._windowFocusTimeoutId);\n                clearTimeout(this._touchTimeoutId);\n                clearTimeout(this._originTimeoutId);\n            }\n        }\n    }\n    FocusMonitor.ɵfac = function FocusMonitor_Factory(t) { return new (t || FocusMonitor)(core[\"Zb\" /* ɵɵinject */](core[\"B\" /* NgZone */]), core[\"Zb\" /* ɵɵinject */](fesm2015_platform[\"a\" /* Platform */]), core[\"Zb\" /* ɵɵinject */](common[\"e\" /* DOCUMENT */], 8), core[\"Zb\" /* ɵɵinject */](FOCUS_MONITOR_DEFAULT_OPTIONS, 8)); };\n    FocusMonitor.ɵprov = /*@__PURE__*/ Object(core[\"Lb\" /* ɵɵdefineInjectable */])({ factory: function FocusMonitor_Factory() { return new FocusMonitor(Object(core[\"Zb\" /* ɵɵinject */])(core[\"B\" /* NgZone */]), Object(core[\"Zb\" /* ɵɵinject */])(fesm2015_platform[\"a\" /* Platform */]), Object(core[\"Zb\" /* ɵɵinject */])(common[\"e\" /* DOCUMENT */], 8), Object(core[\"Zb\" /* ɵɵinject */])(FOCUS_MONITOR_DEFAULT_OPTIONS, 8)); }, token: FocusMonitor, providedIn: \"root\" });\n    return FocusMonitor;\n})();\n/** Gets the target of an event, accounting for Shadow DOM. */\nfunction getTarget(event) {\n    // If an event is bound outside the Shadow DOM, the `event.target` will\n    // point to the shadow root so we have to use `composedPath` instead.\n    return (event.composedPath ? event.composedPath()[0] : event.target);\n}\nlet a11y_CdkMonitorFocus = /*@__PURE__*/ (() => {\n    class CdkMonitorFocus {\n        constructor(_elementRef, _focusMonitor) {\n            this._elementRef = _elementRef;\n            this._focusMonitor = _focusMonitor;\n            this.cdkFocusChange = new core[\"o\" /* EventEmitter */]();\n        }\n        ngAfterViewInit() {\n            this._monitorSubscription = this._focusMonitor.monitor(this._elementRef, this._elementRef.nativeElement.hasAttribute('cdkMonitorSubtreeFocus'))\n                .subscribe(origin => this.cdkFocusChange.emit(origin));\n        }\n        ngOnDestroy() {\n            this._focusMonitor.stopMonitoring(this._elementRef);\n            if (this._monitorSubscription) {\n                this._monitorSubscription.unsubscribe();\n            }\n        }\n    }\n    CdkMonitorFocus.ɵfac = function CdkMonitorFocus_Factory(t) { return new (t || CdkMonitorFocus)(core[\"Pb\" /* ɵɵdirectiveInject */](core[\"m\" /* ElementRef */]), core[\"Pb\" /* ɵɵdirectiveInject */](a11y_FocusMonitor)); };\n    CdkMonitorFocus.ɵdir = /*@__PURE__*/ core[\"Kb\" /* ɵɵdefineDirective */]({ type: CdkMonitorFocus, selectors: [[\"\", \"cdkMonitorElementFocus\", \"\"], [\"\", \"cdkMonitorSubtreeFocus\", \"\"]], outputs: { cdkFocusChange: \"cdkFocusChange\" } });\n    return CdkMonitorFocus;\n})();\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/** CSS class applied to the document body when in black-on-white high-contrast mode. */\nconst BLACK_ON_WHITE_CSS_CLASS = 'cdk-high-contrast-black-on-white';\n/** CSS class applied to the document body when in white-on-black high-contrast mode. */\nconst WHITE_ON_BLACK_CSS_CLASS = 'cdk-high-contrast-white-on-black';\n/** CSS class applied to the document body when in high-contrast mode. */\nconst HIGH_CONTRAST_MODE_ACTIVE_CSS_CLASS = 'cdk-high-contrast-active';\nlet a11y_HighContrastModeDetector = /*@__PURE__*/ (() => {\n    class HighContrastModeDetector {\n        constructor(_platform, document) {\n            this._platform = _platform;\n            this._document = document;\n        }\n        /** Gets the current high-contrast-mode for the page. */\n        getHighContrastMode() {\n            if (!this._platform.isBrowser) {\n                return 0 /* NONE */;\n            }\n            // Create a test element with an arbitrary background-color that is neither black nor\n            // white; high-contrast mode will coerce the color to either black or white. Also ensure that\n            // appending the test element to the DOM does not affect layout by absolutely positioning it\n            const testElement = this._document.createElement('div');\n            testElement.style.backgroundColor = 'rgb(1,2,3)';\n            testElement.style.position = 'absolute';\n            this._document.body.appendChild(testElement);\n            // Get the computed style for the background color, collapsing spaces to normalize between\n            // browsers. Once we get this color, we no longer need the test element. Access the `window`\n            // via the document so we can fake it in tests. Note that we have extra null checks, because\n            // this logic will likely run during app bootstrap and throwing can break the entire app.\n            const documentWindow = this._document.defaultView || window;\n            const computedStyle = (documentWindow && documentWindow.getComputedStyle) ?\n                documentWindow.getComputedStyle(testElement) : null;\n            const computedColor = (computedStyle && computedStyle.backgroundColor || '').replace(/ /g, '');\n            this._document.body.removeChild(testElement);\n            switch (computedColor) {\n                case 'rgb(0,0,0)': return 2 /* WHITE_ON_BLACK */;\n                case 'rgb(255,255,255)': return 1 /* BLACK_ON_WHITE */;\n            }\n            return 0 /* NONE */;\n        }\n        /** Applies CSS classes indicating high-contrast mode to document body (browser-only). */\n        _applyBodyHighContrastModeCssClasses() {\n            if (this._platform.isBrowser && this._document.body) {\n                const bodyClasses = this._document.body.classList;\n                // IE11 doesn't support `classList` operations with multiple arguments\n                bodyClasses.remove(HIGH_CONTRAST_MODE_ACTIVE_CSS_CLASS);\n                bodyClasses.remove(BLACK_ON_WHITE_CSS_CLASS);\n                bodyClasses.remove(WHITE_ON_BLACK_CSS_CLASS);\n                const mode = this.getHighContrastMode();\n                if (mode === 1 /* BLACK_ON_WHITE */) {\n                    bodyClasses.add(HIGH_CONTRAST_MODE_ACTIVE_CSS_CLASS);\n                    bodyClasses.add(BLACK_ON_WHITE_CSS_CLASS);\n                }\n                else if (mode === 2 /* WHITE_ON_BLACK */) {\n                    bodyClasses.add(HIGH_CONTRAST_MODE_ACTIVE_CSS_CLASS);\n                    bodyClasses.add(WHITE_ON_BLACK_CSS_CLASS);\n                }\n            }\n        }\n    }\n    HighContrastModeDetector.ɵfac = function HighContrastModeDetector_Factory(t) { return new (t || HighContrastModeDetector)(core[\"Zb\" /* ɵɵinject */](fesm2015_platform[\"a\" /* Platform */]), core[\"Zb\" /* ɵɵinject */](common[\"e\" /* DOCUMENT */])); };\n    HighContrastModeDetector.ɵprov = /*@__PURE__*/ Object(core[\"Lb\" /* ɵɵdefineInjectable */])({ factory: function HighContrastModeDetector_Factory() { return new HighContrastModeDetector(Object(core[\"Zb\" /* ɵɵinject */])(fesm2015_platform[\"a\" /* Platform */]), Object(core[\"Zb\" /* ɵɵinject */])(common[\"e\" /* DOCUMENT */])); }, token: HighContrastModeDetector, providedIn: \"root\" });\n    return HighContrastModeDetector;\n})();\nlet a11y_A11yModule = /*@__PURE__*/ (() => {\n    class A11yModule {\n        constructor(highContrastModeDetector) {\n            highContrastModeDetector._applyBodyHighContrastModeCssClasses();\n        }\n    }\n    A11yModule.ɵmod = /*@__PURE__*/ core[\"Nb\" /* ɵɵdefineNgModule */]({ type: A11yModule });\n    A11yModule.ɵinj = /*@__PURE__*/ core[\"Mb\" /* ɵɵdefineInjector */]({ factory: function A11yModule_Factory(t) { return new (t || A11yModule)(core[\"Zb\" /* ɵɵinject */](a11y_HighContrastModeDetector)); }, imports: [[fesm2015_platform[\"b\" /* PlatformModule */], observers_ObserversModule]] });\n    return A11yModule;\n})();\n/*@__PURE__*/ (function () { (typeof ngJitMode === \"undefined\" || ngJitMode) && core[\"Ac\" /* ɵɵsetNgModuleScope */](a11y_A11yModule, { declarations: function () { return [a11y_CdkAriaLive, a11y_CdkTrapFocus, a11y_CdkMonitorFocus]; }, imports: function () { return [fesm2015_platform[\"b\" /* PlatformModule */], observers_ObserversModule]; }, exports: function () { return [a11y_CdkAriaLive, a11y_CdkTrapFocus, a11y_CdkMonitorFocus]; } }); })();\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Generated bundle index. Do not edit.\n */\n\n//# sourceMappingURL=a11y.js.map\n\n// CONCATENATED MODULE: ./node_modules/@angular/cdk/__ivy_ngcc__/fesm2015/portal.js\n\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Throws an exception when attempting to attach a null portal to a host.\n * @docs-private\n */\n\nfunction throwNullPortalError() {\n    throw Error('Must provide a portal to attach');\n}\n/**\n * Throws an exception when attempting to attach a portal to a host that is already attached.\n * @docs-private\n */\nfunction throwPortalAlreadyAttachedError() {\n    throw Error('Host already has a portal attached');\n}\n/**\n * Throws an exception when attempting to attach a portal to an already-disposed host.\n * @docs-private\n */\nfunction throwPortalOutletAlreadyDisposedError() {\n    throw Error('This PortalOutlet has already been disposed');\n}\n/**\n * Throws an exception when attempting to attach an unknown portal type.\n * @docs-private\n */\nfunction throwUnknownPortalTypeError() {\n    throw Error('Attempting to attach an unknown Portal type. BasePortalOutlet accepts either ' +\n        'a ComponentPortal or a TemplatePortal.');\n}\n/**\n * Throws an exception when attempting to attach a portal to a null host.\n * @docs-private\n */\nfunction throwNullPortalOutletError() {\n    throw Error('Attempting to attach a portal to a null PortalOutlet');\n}\n/**\n * Throws an exception when attempting to detach a portal that is not attached.\n * @docs-private\n */\nfunction throwNoPortalAttachedError() {\n    throw Error('Attempting to detach a portal that is not attached to a host');\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * A `Portal` is something that you want to render somewhere else.\n * It can be attach to / detached from a `PortalOutlet`.\n */\nclass Portal {\n    /** Attach this portal to a host. */\n    attach(host) {\n        if (host == null) {\n            throwNullPortalOutletError();\n        }\n        if (host.hasAttached()) {\n            throwPortalAlreadyAttachedError();\n        }\n        this._attachedHost = host;\n        return host.attach(this);\n    }\n    /** Detach this portal from its host */\n    detach() {\n        let host = this._attachedHost;\n        if (host == null) {\n            throwNoPortalAttachedError();\n        }\n        else {\n            this._attachedHost = null;\n            host.detach();\n        }\n    }\n    /** Whether this portal is attached to a host. */\n    get isAttached() {\n        return this._attachedHost != null;\n    }\n    /**\n     * Sets the PortalOutlet reference without performing `attach()`. This is used directly by\n     * the PortalOutlet when it is performing an `attach()` or `detach()`.\n     */\n    setAttachedHost(host) {\n        this._attachedHost = host;\n    }\n}\n/**\n * A `ComponentPortal` is a portal that instantiates some Component upon attachment.\n */\nclass ComponentPortal extends Portal {\n    constructor(component, viewContainerRef, injector, componentFactoryResolver) {\n        super();\n        this.component = component;\n        this.viewContainerRef = viewContainerRef;\n        this.injector = injector;\n        this.componentFactoryResolver = componentFactoryResolver;\n    }\n}\n/**\n * A `TemplatePortal` is a portal that represents some embedded template (TemplateRef).\n */\nclass TemplatePortal extends Portal {\n    constructor(template, viewContainerRef, context) {\n        super();\n        this.templateRef = template;\n        this.viewContainerRef = viewContainerRef;\n        this.context = context;\n    }\n    get origin() {\n        return this.templateRef.elementRef;\n    }\n    /**\n     * Attach the portal to the provided `PortalOutlet`.\n     * When a context is provided it will override the `context` property of the `TemplatePortal`\n     * instance.\n     */\n    attach(host, context = this.context) {\n        this.context = context;\n        return super.attach(host);\n    }\n    detach() {\n        this.context = undefined;\n        return super.detach();\n    }\n}\n/**\n * A `DomPortal` is a portal whose DOM element will be taken from its current position\n * in the DOM and moved into a portal outlet, when it is attached. On detach, the content\n * will be restored to its original position.\n */\nclass portal_DomPortal extends Portal {\n    constructor(element) {\n        super();\n        this.element = element instanceof core[\"m\" /* ElementRef */] ? element.nativeElement : element;\n    }\n}\n/**\n * Partial implementation of PortalOutlet that handles attaching\n * ComponentPortal and TemplatePortal.\n */\nclass BasePortalOutlet {\n    constructor() {\n        /** Whether this host has already been permanently disposed. */\n        this._isDisposed = false;\n        // @breaking-change 10.0.0 `attachDomPortal` to become a required abstract method.\n        this.attachDomPortal = null;\n    }\n    /** Whether this host has an attached portal. */\n    hasAttached() {\n        return !!this._attachedPortal;\n    }\n    /** Attaches a portal. */\n    attach(portal) {\n        if (!portal) {\n            throwNullPortalError();\n        }\n        if (this.hasAttached()) {\n            throwPortalAlreadyAttachedError();\n        }\n        if (this._isDisposed) {\n            throwPortalOutletAlreadyDisposedError();\n        }\n        if (portal instanceof ComponentPortal) {\n            this._attachedPortal = portal;\n            return this.attachComponentPortal(portal);\n        }\n        else if (portal instanceof TemplatePortal) {\n            this._attachedPortal = portal;\n            return this.attachTemplatePortal(portal);\n            // @breaking-change 10.0.0 remove null check for `this.attachDomPortal`.\n        }\n        else if (this.attachDomPortal && portal instanceof portal_DomPortal) {\n            this._attachedPortal = portal;\n            return this.attachDomPortal(portal);\n        }\n        throwUnknownPortalTypeError();\n    }\n    /** Detaches a previously attached portal. */\n    detach() {\n        if (this._attachedPortal) {\n            this._attachedPortal.setAttachedHost(null);\n            this._attachedPortal = null;\n        }\n        this._invokeDisposeFn();\n    }\n    /** Permanently dispose of this portal host. */\n    dispose() {\n        if (this.hasAttached()) {\n            this.detach();\n        }\n        this._invokeDisposeFn();\n        this._isDisposed = true;\n    }\n    /** @docs-private */\n    setDisposeFn(fn) {\n        this._disposeFn = fn;\n    }\n    _invokeDisposeFn() {\n        if (this._disposeFn) {\n            this._disposeFn();\n            this._disposeFn = null;\n        }\n    }\n}\n/**\n * @deprecated Use `BasePortalOutlet` instead.\n * @breaking-change 9.0.0\n */\nclass BasePortalHost extends BasePortalOutlet {\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * A PortalOutlet for attaching portals to an arbitrary DOM element outside of the Angular\n * application context.\n */\nclass DomPortalOutlet extends BasePortalOutlet {\n    constructor(\n    /** Element into which the content is projected. */\n    outletElement, _componentFactoryResolver, _appRef, _defaultInjector, \n    /**\n     * @deprecated `_document` Parameter to be made required.\n     * @breaking-change 10.0.0\n     */\n    _document) {\n        super();\n        this.outletElement = outletElement;\n        this._componentFactoryResolver = _componentFactoryResolver;\n        this._appRef = _appRef;\n        this._defaultInjector = _defaultInjector;\n        /**\n         * Attaches a DOM portal by transferring its content into the outlet.\n         * @param portal Portal to be attached.\n         * @deprecated To be turned into a method.\n         * @breaking-change 10.0.0\n         */\n        this.attachDomPortal = (portal) => {\n            // @breaking-change 10.0.0 Remove check and error once the\n            // `_document` constructor parameter is required.\n            if (!this._document) {\n                throw Error('Cannot attach DOM portal without _document constructor parameter');\n            }\n            const element = portal.element;\n            if (!element.parentNode) {\n                throw Error('DOM portal content must be attached to a parent node.');\n            }\n            // Anchor used to save the element's previous position so\n            // that we can restore it when the portal is detached.\n            const anchorNode = this._document.createComment('dom-portal');\n            element.parentNode.insertBefore(anchorNode, element);\n            this.outletElement.appendChild(element);\n            super.setDisposeFn(() => {\n                // We can't use `replaceWith` here because IE doesn't support it.\n                if (anchorNode.parentNode) {\n                    anchorNode.parentNode.replaceChild(element, anchorNode);\n                }\n            });\n        };\n        this._document = _document;\n    }\n    /**\n     * Attach the given ComponentPortal to DOM element using the ComponentFactoryResolver.\n     * @param portal Portal to be attached\n     * @returns Reference to the created component.\n     */\n    attachComponentPortal(portal) {\n        const resolver = portal.componentFactoryResolver || this._componentFactoryResolver;\n        const componentFactory = resolver.resolveComponentFactory(portal.component);\n        let componentRef;\n        // If the portal specifies a ViewContainerRef, we will use that as the attachment point\n        // for the component (in terms of Angular's component tree, not rendering).\n        // When the ViewContainerRef is missing, we use the factory to create the component directly\n        // and then manually attach the view to the application.\n        if (portal.viewContainerRef) {\n            componentRef = portal.viewContainerRef.createComponent(componentFactory, portal.viewContainerRef.length, portal.injector || portal.viewContainerRef.injector);\n            this.setDisposeFn(() => componentRef.destroy());\n        }\n        else {\n            componentRef = componentFactory.create(portal.injector || this._defaultInjector);\n            this._appRef.attachView(componentRef.hostView);\n            this.setDisposeFn(() => {\n                this._appRef.detachView(componentRef.hostView);\n                componentRef.destroy();\n            });\n        }\n        // At this point the component has been instantiated, so we move it to the location in the DOM\n        // where we want it to be rendered.\n        this.outletElement.appendChild(this._getComponentRootNode(componentRef));\n        return componentRef;\n    }\n    /**\n     * Attaches a template portal to the DOM as an embedded view.\n     * @param portal Portal to be attached.\n     * @returns Reference to the created embedded view.\n     */\n    attachTemplatePortal(portal) {\n        let viewContainer = portal.viewContainerRef;\n        let viewRef = viewContainer.createEmbeddedView(portal.templateRef, portal.context);\n        viewRef.detectChanges();\n        // The method `createEmbeddedView` will add the view as a child of the viewContainer.\n        // But for the DomPortalOutlet the view can be added everywhere in the DOM\n        // (e.g Overlay Container) To move the view to the specified host element. We just\n        // re-append the existing root nodes.\n        viewRef.rootNodes.forEach(rootNode => this.outletElement.appendChild(rootNode));\n        this.setDisposeFn((() => {\n            let index = viewContainer.indexOf(viewRef);\n            if (index !== -1) {\n                viewContainer.remove(index);\n            }\n        }));\n        // TODO(jelbourn): Return locals from view.\n        return viewRef;\n    }\n    /**\n     * Clears out a portal from the DOM.\n     */\n    dispose() {\n        super.dispose();\n        if (this.outletElement.parentNode != null) {\n            this.outletElement.parentNode.removeChild(this.outletElement);\n        }\n    }\n    /** Gets the root HTMLElement for an instantiated component. */\n    _getComponentRootNode(componentRef) {\n        return componentRef.hostView.rootNodes[0];\n    }\n}\n/**\n * @deprecated Use `DomPortalOutlet` instead.\n * @breaking-change 9.0.0\n */\nclass DomPortalHost extends DomPortalOutlet {\n}\nlet portal_CdkPortal = /*@__PURE__*/ (() => {\n    class CdkPortal extends TemplatePortal {\n        constructor(templateRef, viewContainerRef) {\n            super(templateRef, viewContainerRef);\n        }\n    }\n    CdkPortal.ɵfac = function CdkPortal_Factory(t) { return new (t || CdkPortal)(core[\"Pb\" /* ɵɵdirectiveInject */](core[\"N\" /* TemplateRef */]), core[\"Pb\" /* ɵɵdirectiveInject */](core[\"R\" /* ViewContainerRef */])); };\n    CdkPortal.ɵdir = /*@__PURE__*/ core[\"Kb\" /* ɵɵdefineDirective */]({ type: CdkPortal, selectors: [[\"\", \"cdkPortal\", \"\"]], exportAs: [\"cdkPortal\"], features: [core[\"Ab\" /* ɵɵInheritDefinitionFeature */]] });\n    return CdkPortal;\n})();\nlet portal_TemplatePortalDirective = /*@__PURE__*/ (() => {\n    class TemplatePortalDirective extends portal_CdkPortal {\n    }\n    TemplatePortalDirective.ɵfac = function TemplatePortalDirective_Factory(t) { return ɵTemplatePortalDirective_BaseFactory(t || TemplatePortalDirective); };\n    TemplatePortalDirective.ɵdir = /*@__PURE__*/ core[\"Kb\" /* ɵɵdefineDirective */]({ type: TemplatePortalDirective, selectors: [[\"\", \"cdk-portal\", \"\"], [\"\", \"portal\", \"\"]], exportAs: [\"cdkPortal\"], features: [/*@__PURE__*/ core[\"Cb\" /* ɵɵProvidersFeature */]([{\n                    provide: portal_CdkPortal,\n                    useExisting: TemplatePortalDirective\n                }]), core[\"Ab\" /* ɵɵInheritDefinitionFeature */]] });\n    return TemplatePortalDirective;\n})();\nconst ɵTemplatePortalDirective_BaseFactory = /*@__PURE__*/ /*@__PURE__*/ core[\"Xb\" /* ɵɵgetInheritedFactory */](portal_TemplatePortalDirective);\nlet portal_CdkPortalOutlet = /*@__PURE__*/ (() => {\n    class CdkPortalOutlet extends BasePortalOutlet {\n        constructor(_componentFactoryResolver, _viewContainerRef, \n        /**\n         * @deprecated `_document` parameter to be made required.\n         * @breaking-change 9.0.0\n         */\n        _document) {\n            super();\n            this._componentFactoryResolver = _componentFactoryResolver;\n            this._viewContainerRef = _viewContainerRef;\n            /** Whether the portal component is initialized. */\n            this._isInitialized = false;\n            /** Emits when a portal is attached to the outlet. */\n            this.attached = new core[\"o\" /* EventEmitter */]();\n            /**\n             * Attaches the given DomPortal to this PortalHost by moving all of the portal content into it.\n             * @param portal Portal to be attached.\n             * @deprecated To be turned into a method.\n             * @breaking-change 10.0.0\n             */\n            this.attachDomPortal = (portal) => {\n                // @breaking-change 9.0.0 Remove check and error once the\n                // `_document` constructor parameter is required.\n                if (!this._document) {\n                    throw Error('Cannot attach DOM portal without _document constructor parameter');\n                }\n                const element = portal.element;\n                if (!element.parentNode) {\n                    throw Error('DOM portal content must be attached to a parent node.');\n                }\n                // Anchor used to save the element's previous position so\n                // that we can restore it when the portal is detached.\n                const anchorNode = this._document.createComment('dom-portal');\n                portal.setAttachedHost(this);\n                element.parentNode.insertBefore(anchorNode, element);\n                this._getRootNode().appendChild(element);\n                super.setDisposeFn(() => {\n                    if (anchorNode.parentNode) {\n                        anchorNode.parentNode.replaceChild(element, anchorNode);\n                    }\n                });\n            };\n            this._document = _document;\n        }\n        /** Portal associated with the Portal outlet. */\n        get portal() {\n            return this._attachedPortal;\n        }\n        set portal(portal) {\n            // Ignore the cases where the `portal` is set to a falsy value before the lifecycle hooks have\n            // run. This handles the cases where the user might do something like `<div cdkPortalOutlet>`\n            // and attach a portal programmatically in the parent component. When Angular does the first CD\n            // round, it will fire the setter with empty string, causing the user's content to be cleared.\n            if (this.hasAttached() && !portal && !this._isInitialized) {\n                return;\n            }\n            if (this.hasAttached()) {\n                super.detach();\n            }\n            if (portal) {\n                super.attach(portal);\n            }\n            this._attachedPortal = portal;\n        }\n        /** Component or view reference that is attached to the portal. */\n        get attachedRef() {\n            return this._attachedRef;\n        }\n        ngOnInit() {\n            this._isInitialized = true;\n        }\n        ngOnDestroy() {\n            super.dispose();\n            this._attachedPortal = null;\n            this._attachedRef = null;\n        }\n        /**\n         * Attach the given ComponentPortal to this PortalOutlet using the ComponentFactoryResolver.\n         *\n         * @param portal Portal to be attached to the portal outlet.\n         * @returns Reference to the created component.\n         */\n        attachComponentPortal(portal) {\n            portal.setAttachedHost(this);\n            // If the portal specifies an origin, use that as the logical location of the component\n            // in the application tree. Otherwise use the location of this PortalOutlet.\n            const viewContainerRef = portal.viewContainerRef != null ?\n                portal.viewContainerRef :\n                this._viewContainerRef;\n            const resolver = portal.componentFactoryResolver || this._componentFactoryResolver;\n            const componentFactory = resolver.resolveComponentFactory(portal.component);\n            const ref = viewContainerRef.createComponent(componentFactory, viewContainerRef.length, portal.injector || viewContainerRef.injector);\n            // If we're using a view container that's different from the injected one (e.g. when the portal\n            // specifies its own) we need to move the component into the outlet, otherwise it'll be rendered\n            // inside of the alternate view container.\n            if (viewContainerRef !== this._viewContainerRef) {\n                this._getRootNode().appendChild(ref.hostView.rootNodes[0]);\n            }\n            super.setDisposeFn(() => ref.destroy());\n            this._attachedPortal = portal;\n            this._attachedRef = ref;\n            this.attached.emit(ref);\n            return ref;\n        }\n        /**\n         * Attach the given TemplatePortal to this PortalHost as an embedded View.\n         * @param portal Portal to be attached.\n         * @returns Reference to the created embedded view.\n         */\n        attachTemplatePortal(portal) {\n            portal.setAttachedHost(this);\n            const viewRef = this._viewContainerRef.createEmbeddedView(portal.templateRef, portal.context);\n            super.setDisposeFn(() => this._viewContainerRef.clear());\n            this._attachedPortal = portal;\n            this._attachedRef = viewRef;\n            this.attached.emit(viewRef);\n            return viewRef;\n        }\n        /** Gets the root node of the portal outlet. */\n        _getRootNode() {\n            const nativeElement = this._viewContainerRef.element.nativeElement;\n            // The directive could be set on a template which will result in a comment\n            // node being the root. Use the comment's parent node if that is the case.\n            return (nativeElement.nodeType === nativeElement.ELEMENT_NODE ?\n                nativeElement : nativeElement.parentNode);\n        }\n    }\n    CdkPortalOutlet.ɵfac = function CdkPortalOutlet_Factory(t) { return new (t || CdkPortalOutlet)(core[\"Pb\" /* ɵɵdirectiveInject */](core[\"k\" /* ComponentFactoryResolver */]), core[\"Pb\" /* ɵɵdirectiveInject */](core[\"R\" /* ViewContainerRef */]), core[\"Pb\" /* ɵɵdirectiveInject */](common[\"e\" /* DOCUMENT */])); };\n    CdkPortalOutlet.ɵdir = /*@__PURE__*/ core[\"Kb\" /* ɵɵdefineDirective */]({ type: CdkPortalOutlet, selectors: [[\"\", \"cdkPortalOutlet\", \"\"]], inputs: { portal: [\"cdkPortalOutlet\", \"portal\"] }, outputs: { attached: \"attached\" }, exportAs: [\"cdkPortalOutlet\"], features: [core[\"Ab\" /* ɵɵInheritDefinitionFeature */]] });\n    return CdkPortalOutlet;\n})();\nlet portal_PortalHostDirective = /*@__PURE__*/ (() => {\n    class PortalHostDirective extends portal_CdkPortalOutlet {\n    }\n    PortalHostDirective.ɵfac = function PortalHostDirective_Factory(t) { return ɵPortalHostDirective_BaseFactory(t || PortalHostDirective); };\n    PortalHostDirective.ɵdir = /*@__PURE__*/ core[\"Kb\" /* ɵɵdefineDirective */]({ type: PortalHostDirective, selectors: [[\"\", \"cdkPortalHost\", \"\"], [\"\", \"portalHost\", \"\"]], inputs: { portal: [\"cdkPortalHost\", \"portal\"] }, exportAs: [\"cdkPortalHost\"], features: [/*@__PURE__*/ core[\"Cb\" /* ɵɵProvidersFeature */]([{\n                    provide: portal_CdkPortalOutlet,\n                    useExisting: PortalHostDirective\n                }]), core[\"Ab\" /* ɵɵInheritDefinitionFeature */]] });\n    return PortalHostDirective;\n})();\nconst ɵPortalHostDirective_BaseFactory = /*@__PURE__*/ /*@__PURE__*/ core[\"Xb\" /* ɵɵgetInheritedFactory */](portal_PortalHostDirective);\nlet portal_PortalModule = /*@__PURE__*/ (() => {\n    class PortalModule {\n    }\n    PortalModule.ɵmod = /*@__PURE__*/ core[\"Nb\" /* ɵɵdefineNgModule */]({ type: PortalModule });\n    PortalModule.ɵinj = /*@__PURE__*/ core[\"Mb\" /* ɵɵdefineInjector */]({ factory: function PortalModule_Factory(t) { return new (t || PortalModule)(); } });\n    return PortalModule;\n})();\n/*@__PURE__*/ (function () { (typeof ngJitMode === \"undefined\" || ngJitMode) && core[\"Ac\" /* ɵɵsetNgModuleScope */](portal_PortalModule, { declarations: [portal_CdkPortal, portal_CdkPortalOutlet, portal_TemplatePortalDirective, portal_PortalHostDirective], exports: [portal_CdkPortal, portal_CdkPortalOutlet, portal_TemplatePortalDirective, portal_PortalHostDirective] }); })();\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Custom injector to be used when providing custom\n * injection tokens to components inside a portal.\n * @docs-private\n */\nclass PortalInjector {\n    constructor(_parentInjector, _customTokens) {\n        this._parentInjector = _parentInjector;\n        this._customTokens = _customTokens;\n    }\n    get(token, notFoundValue) {\n        const value = this._customTokens.get(token);\n        if (typeof value !== 'undefined') {\n            return value;\n        }\n        return this._parentInjector.get(token, notFoundValue);\n    }\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Generated bundle index. Do not edit.\n */\n\n//# sourceMappingURL=portal.js.map\n\n// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/scheduler/AsyncAction.js + 1 modules\nvar AsyncAction = __webpack_require__(\"3N8a\");\n\n// CONCATENATED MODULE: ./node_modules/rxjs/_esm2015/internal/scheduler/AnimationFrameAction.js\n\nclass AnimationFrameAction_AnimationFrameAction extends AsyncAction[\"a\" /* AsyncAction */] {\n    constructor(scheduler, work) {\n        super(scheduler, work);\n        this.scheduler = scheduler;\n        this.work = work;\n    }\n    requestAsyncId(scheduler, id, delay = 0) {\n        if (delay !== null && delay > 0) {\n            return super.requestAsyncId(scheduler, id, delay);\n        }\n        scheduler.actions.push(this);\n        return scheduler.scheduled || (scheduler.scheduled = requestAnimationFrame(() => scheduler.flush(null)));\n    }\n    recycleAsyncId(scheduler, id, delay = 0) {\n        if ((delay !== null && delay > 0) || (delay === null && this.delay > 0)) {\n            return super.recycleAsyncId(scheduler, id, delay);\n        }\n        if (scheduler.actions.length === 0) {\n            cancelAnimationFrame(id);\n            scheduler.scheduled = undefined;\n        }\n        return undefined;\n    }\n}\n//# sourceMappingURL=AnimationFrameAction.js.map\n\n// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/scheduler/AsyncScheduler.js + 1 modules\nvar AsyncScheduler = __webpack_require__(\"IjjT\");\n\n// CONCATENATED MODULE: ./node_modules/rxjs/_esm2015/internal/scheduler/AnimationFrameScheduler.js\n\nclass AnimationFrameScheduler_AnimationFrameScheduler extends AsyncScheduler[\"a\" /* AsyncScheduler */] {\n    flush(action) {\n        this.active = true;\n        this.scheduled = undefined;\n        const { actions } = this;\n        let error;\n        let index = -1;\n        let count = actions.length;\n        action = action || actions.shift();\n        do {\n            if (error = action.execute(action.state, action.delay)) {\n                break;\n            }\n        } while (++index < count && (action = actions.shift()));\n        this.active = false;\n        if (error) {\n            while (++index < count && (action = actions.shift())) {\n                action.unsubscribe();\n            }\n            throw error;\n        }\n    }\n}\n//# sourceMappingURL=AnimationFrameScheduler.js.map\n\n// CONCATENATED MODULE: ./node_modules/rxjs/_esm2015/internal/scheduler/animationFrame.js\n\n\nconst animationFrame = /*@__PURE__*/ new AnimationFrameScheduler_AnimationFrameScheduler(AnimationFrameAction_AnimationFrameAction);\n//# sourceMappingURL=animationFrame.js.map\n\n// CONCATENATED MODULE: ./node_modules/rxjs/_esm2015/internal/util/Immediate.js\nlet nextHandle = 1;\nconst RESOLVED = /*@__PURE__*/ (() => Promise.resolve())();\nconst activeHandles = {};\nfunction findAndClearHandle(handle) {\n    if (handle in activeHandles) {\n        delete activeHandles[handle];\n        return true;\n    }\n    return false;\n}\nconst Immediate = {\n    setImmediate(cb) {\n        const handle = nextHandle++;\n        activeHandles[handle] = true;\n        RESOLVED.then(() => findAndClearHandle(handle) && cb());\n        return handle;\n    },\n    clearImmediate(handle) {\n        findAndClearHandle(handle);\n    },\n};\nconst TestTools = {\n    pending() {\n        return Object.keys(activeHandles).length;\n    }\n};\n//# sourceMappingURL=Immediate.js.map\n\n// CONCATENATED MODULE: ./node_modules/rxjs/_esm2015/internal/scheduler/AsapAction.js\n\n\nclass AsapAction_AsapAction extends AsyncAction[\"a\" /* AsyncAction */] {\n    constructor(scheduler, work) {\n        super(scheduler, work);\n        this.scheduler = scheduler;\n        this.work = work;\n    }\n    requestAsyncId(scheduler, id, delay = 0) {\n        if (delay !== null && delay > 0) {\n            return super.requestAsyncId(scheduler, id, delay);\n        }\n        scheduler.actions.push(this);\n        return scheduler.scheduled || (scheduler.scheduled = Immediate.setImmediate(scheduler.flush.bind(scheduler, null)));\n    }\n    recycleAsyncId(scheduler, id, delay = 0) {\n        if ((delay !== null && delay > 0) || (delay === null && this.delay > 0)) {\n            return super.recycleAsyncId(scheduler, id, delay);\n        }\n        if (scheduler.actions.length === 0) {\n            Immediate.clearImmediate(id);\n            scheduler.scheduled = undefined;\n        }\n        return undefined;\n    }\n}\n//# sourceMappingURL=AsapAction.js.map\n\n// CONCATENATED MODULE: ./node_modules/rxjs/_esm2015/internal/scheduler/AsapScheduler.js\n\nclass AsapScheduler_AsapScheduler extends AsyncScheduler[\"a\" /* AsyncScheduler */] {\n    flush(action) {\n        this.active = true;\n        this.scheduled = undefined;\n        const { actions } = this;\n        let error;\n        let index = -1;\n        let count = actions.length;\n        action = action || actions.shift();\n        do {\n            if (error = action.execute(action.state, action.delay)) {\n                break;\n            }\n        } while (++index < count && (action = actions.shift()));\n        this.active = false;\n        if (error) {\n            while (++index < count && (action = actions.shift())) {\n                action.unsubscribe();\n            }\n            throw error;\n        }\n    }\n}\n//# sourceMappingURL=AsapScheduler.js.map\n\n// CONCATENATED MODULE: ./node_modules/rxjs/_esm2015/internal/scheduler/asap.js\n\n\nconst asap = /*@__PURE__*/ new AsapScheduler_AsapScheduler(AsapAction_AsapAction);\n//# sourceMappingURL=asap.js.map\n\n// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/util/isObservable.js\nvar isObservable = __webpack_require__(\"7+OI\");\n\n// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/operators/distinctUntilChanged.js\nvar distinctUntilChanged = __webpack_require__(\"/uUt\");\n\n// CONCATENATED MODULE: ./node_modules/rxjs/_esm2015/internal/operators/audit.js\n\n\nfunction audit(durationSelector) {\n    return function auditOperatorFunction(source) {\n        return source.lift(new AuditOperator(durationSelector));\n    };\n}\nclass AuditOperator {\n    constructor(durationSelector) {\n        this.durationSelector = durationSelector;\n    }\n    call(subscriber, source) {\n        return source.subscribe(new audit_AuditSubscriber(subscriber, this.durationSelector));\n    }\n}\nclass audit_AuditSubscriber extends OuterSubscriber[\"a\" /* OuterSubscriber */] {\n    constructor(destination, durationSelector) {\n        super(destination);\n        this.durationSelector = durationSelector;\n        this.hasValue = false;\n    }\n    _next(value) {\n        this.value = value;\n        this.hasValue = true;\n        if (!this.throttled) {\n            let duration;\n            try {\n                const { durationSelector } = this;\n                duration = durationSelector(value);\n            }\n            catch (err) {\n                return this.destination.error(err);\n            }\n            const innerSubscription = Object(subscribeToResult[\"a\" /* subscribeToResult */])(this, duration);\n            if (!innerSubscription || innerSubscription.closed) {\n                this.clearThrottle();\n            }\n            else {\n                this.add(this.throttled = innerSubscription);\n            }\n        }\n    }\n    clearThrottle() {\n        const { value, hasValue, throttled } = this;\n        if (throttled) {\n            this.remove(throttled);\n            this.throttled = null;\n            throttled.unsubscribe();\n        }\n        if (hasValue) {\n            this.value = null;\n            this.hasValue = false;\n            this.destination.next(value);\n        }\n    }\n    notifyNext(outerValue, innerValue, outerIndex, innerIndex) {\n        this.clearThrottle();\n    }\n    notifyComplete() {\n        this.clearThrottle();\n    }\n}\n//# sourceMappingURL=audit.js.map\n\n// CONCATENATED MODULE: ./node_modules/rxjs/_esm2015/internal/util/isNumeric.js\n\nfunction isNumeric(val) {\n    return !Object(isArray[\"a\" /* isArray */])(val) && (val - parseFloat(val) + 1) >= 0;\n}\n//# sourceMappingURL=isNumeric.js.map\n\n// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/util/isScheduler.js\nvar isScheduler = __webpack_require__(\"z+Ro\");\n\n// CONCATENATED MODULE: ./node_modules/rxjs/_esm2015/internal/observable/timer.js\n\n\n\n\nfunction timer(dueTime = 0, periodOrScheduler, scheduler) {\n    let period = -1;\n    if (isNumeric(periodOrScheduler)) {\n        period = Number(periodOrScheduler) < 1 && 1 || Number(periodOrScheduler);\n    }\n    else if (Object(isScheduler[\"a\" /* isScheduler */])(periodOrScheduler)) {\n        scheduler = periodOrScheduler;\n    }\n    if (!Object(isScheduler[\"a\" /* isScheduler */])(scheduler)) {\n        scheduler = scheduler_async[\"a\" /* async */];\n    }\n    return new Observable[\"a\" /* Observable */](subscriber => {\n        const due = isNumeric(dueTime)\n            ? dueTime\n            : (+dueTime - scheduler.now());\n        return scheduler.schedule(dispatch, due, {\n            index: 0, period, subscriber\n        });\n    });\n}\nfunction dispatch(state) {\n    const { index, period, subscriber } = state;\n    subscriber.next(index);\n    if (subscriber.closed) {\n        return;\n    }\n    else if (period === -1) {\n        return subscriber.complete();\n    }\n    state.index = index + 1;\n    this.schedule(state, period);\n}\n//# sourceMappingURL=timer.js.map\n\n// CONCATENATED MODULE: ./node_modules/rxjs/_esm2015/internal/operators/auditTime.js\n\n\n\nfunction auditTime(duration, scheduler = scheduler_async[\"a\" /* async */]) {\n    return audit(() => timer(duration, scheduler));\n}\n//# sourceMappingURL=auditTime.js.map\n\n// CONCATENATED MODULE: ./node_modules/rxjs/_esm2015/internal/operators/takeUntil.js\n\n\nfunction takeUntil(notifier) {\n    return (source) => source.lift(new takeUntil_TakeUntilOperator(notifier));\n}\nclass takeUntil_TakeUntilOperator {\n    constructor(notifier) {\n        this.notifier = notifier;\n    }\n    call(subscriber, source) {\n        const takeUntilSubscriber = new takeUntil_TakeUntilSubscriber(subscriber);\n        const notifierSubscription = Object(subscribeToResult[\"a\" /* subscribeToResult */])(takeUntilSubscriber, this.notifier);\n        if (notifierSubscription && !takeUntilSubscriber.seenValue) {\n            takeUntilSubscriber.add(notifierSubscription);\n            return source.subscribe(takeUntilSubscriber);\n        }\n        return takeUntilSubscriber;\n    }\n}\nclass takeUntil_TakeUntilSubscriber extends OuterSubscriber[\"a\" /* OuterSubscriber */] {\n    constructor(destination) {\n        super(destination);\n        this.seenValue = false;\n    }\n    notifyNext(outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n        this.seenValue = true;\n        this.complete();\n    }\n    notifyComplete() {\n    }\n}\n//# sourceMappingURL=takeUntil.js.map\n\n// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/operators/startWith.js\nvar startWith = __webpack_require__(\"JX91\");\n\n// CONCATENATED MODULE: ./node_modules/rxjs/_esm2015/internal/operators/pairwise.js\n\nfunction pairwise() {\n    return (source) => source.lift(new PairwiseOperator());\n}\nclass PairwiseOperator {\n    call(subscriber, source) {\n        return source.subscribe(new pairwise_PairwiseSubscriber(subscriber));\n    }\n}\nclass pairwise_PairwiseSubscriber extends Subscriber[\"a\" /* Subscriber */] {\n    constructor(destination) {\n        super(destination);\n        this.hasPrev = false;\n    }\n    _next(value) {\n        let pair;\n        if (this.hasPrev) {\n            pair = [this.prev, value];\n        }\n        else {\n            this.hasPrev = true;\n        }\n        this.prev = value;\n        if (pair) {\n            this.destination.next(pair);\n        }\n    }\n}\n//# sourceMappingURL=pairwise.js.map\n\n// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/operators/shareReplay.js\nvar shareReplay = __webpack_require__(\"UXun\");\n\n// CONCATENATED MODULE: ./node_modules/@angular/cdk/__ivy_ngcc__/fesm2015/bidi.js\n\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Injection token used to inject the document into Directionality.\n * This is used so that the value can be faked in tests.\n *\n * We can't use the real document in tests because changing the real `dir` causes geometry-based\n * tests in Safari to fail.\n *\n * We also can't re-provide the DOCUMENT token from platform-brower because the unit tests\n * themselves use things like `querySelector` in test code.\n *\n * This token is defined in a separate file from Directionality as a workaround for\n * https://github.com/angular/angular/issues/22559\n *\n * @docs-private\n */\n\nconst DIR_DOCUMENT = /*@__PURE__*/ new core[\"s\" /* InjectionToken */]('cdk-dir-doc', {\n    providedIn: 'root',\n    factory: DIR_DOCUMENT_FACTORY,\n});\n/** @docs-private */\nfunction DIR_DOCUMENT_FACTORY() {\n    return Object(core[\"X\" /* inject */])(common[\"e\" /* DOCUMENT */]);\n}\nlet bidi_Directionality = /*@__PURE__*/ (() => {\n    class Directionality {\n        constructor(_document) {\n            /** The current 'ltr' or 'rtl' value. */\n            this.value = 'ltr';\n            /** Stream that emits whenever the 'ltr' / 'rtl' state changes. */\n            this.change = new core[\"o\" /* EventEmitter */]();\n            if (_document) {\n                // TODO: handle 'auto' value -\n                // We still need to account for dir=\"auto\".\n                // It looks like HTMLElemenet.dir is also \"auto\" when that's set to the attribute,\n                // but getComputedStyle return either \"ltr\" or \"rtl\". avoiding getComputedStyle for now\n                const bodyDir = _document.body ? _document.body.dir : null;\n                const htmlDir = _document.documentElement ? _document.documentElement.dir : null;\n                const value = bodyDir || htmlDir;\n                this.value = (value === 'ltr' || value === 'rtl') ? value : 'ltr';\n            }\n        }\n        ngOnDestroy() {\n            this.change.complete();\n        }\n    }\n    Directionality.ɵfac = function Directionality_Factory(t) { return new (t || Directionality)(core[\"Zb\" /* ɵɵinject */](DIR_DOCUMENT, 8)); };\n    Directionality.ɵprov = /*@__PURE__*/ Object(core[\"Lb\" /* ɵɵdefineInjectable */])({ factory: function Directionality_Factory() { return new Directionality(Object(core[\"Zb\" /* ɵɵinject */])(DIR_DOCUMENT, 8)); }, token: Directionality, providedIn: \"root\" });\n    return Directionality;\n})();\nlet bidi_Dir = /*@__PURE__*/ (() => {\n    class Dir {\n        constructor() {\n            /** Normalized direction that accounts for invalid/unsupported values. */\n            this._dir = 'ltr';\n            /** Whether the `value` has been set to its initial value. */\n            this._isInitialized = false;\n            /** Event emitted when the direction changes. */\n            this.change = new core[\"o\" /* EventEmitter */]();\n        }\n        /** @docs-private */\n        get dir() { return this._dir; }\n        set dir(value) {\n            const old = this._dir;\n            const normalizedValue = value ? value.toLowerCase() : value;\n            this._rawDir = value;\n            this._dir = (normalizedValue === 'ltr' || normalizedValue === 'rtl') ? normalizedValue : 'ltr';\n            if (old !== this._dir && this._isInitialized) {\n                this.change.emit(this._dir);\n            }\n        }\n        /** Current layout direction of the element. */\n        get value() { return this.dir; }\n        /** Initialize once default value has been set. */\n        ngAfterContentInit() {\n            this._isInitialized = true;\n        }\n        ngOnDestroy() {\n            this.change.complete();\n        }\n    }\n    Dir.ɵfac = function Dir_Factory(t) { return new (t || Dir)(); };\n    Dir.ɵdir = /*@__PURE__*/ core[\"Kb\" /* ɵɵdefineDirective */]({ type: Dir, selectors: [[\"\", \"dir\", \"\"]], hostVars: 1, hostBindings: function Dir_HostBindings(rf, ctx) {\n            if (rf & 2) {\n                core[\"Eb\" /* ɵɵattribute */](\"dir\", ctx._rawDir);\n            }\n        }, inputs: { dir: \"dir\" }, outputs: { change: \"dirChange\" }, exportAs: [\"dir\"], features: [/*@__PURE__*/ core[\"Cb\" /* ɵɵProvidersFeature */]([{ provide: bidi_Directionality, useExisting: Dir }])] });\n    return Dir;\n})();\nlet bidi_BidiModule = /*@__PURE__*/ (() => {\n    class BidiModule {\n    }\n    BidiModule.ɵmod = /*@__PURE__*/ core[\"Nb\" /* ɵɵdefineNgModule */]({ type: BidiModule });\n    BidiModule.ɵinj = /*@__PURE__*/ core[\"Mb\" /* ɵɵdefineInjector */]({ factory: function BidiModule_Factory(t) { return new (t || BidiModule)(); } });\n    return BidiModule;\n})();\n/*@__PURE__*/ (function () { (typeof ngJitMode === \"undefined\" || ngJitMode) && core[\"Ac\" /* ɵɵsetNgModuleScope */](bidi_BidiModule, { declarations: [bidi_Dir], exports: [bidi_Dir] }); })();\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Generated bundle index. Do not edit.\n */\n\n//# sourceMappingURL=bidi.js.map\n\n// CONCATENATED MODULE: ./node_modules/@angular/cdk/__ivy_ngcc__/fesm2015/collections.js\n\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nclass DataSource {\n}\n/** Checks whether an object is a data source. */\nfunction isDataSource(value) {\n    // Check if the value is a DataSource by observing if it has a connect function. Cannot\n    // be checked as an `instanceof DataSource` since people could create their own sources\n    // that match the interface, but don't extend DataSource.\n    return value && typeof value.connect === 'function';\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/** DataSource wrapper for a native array. */\nclass collections_ArrayDataSource extends DataSource {\n    constructor(_data) {\n        super();\n        this._data = _data;\n    }\n    connect() {\n        return Object(isObservable[\"a\" /* isObservable */])(this._data) ? this._data : Object(of[\"a\" /* of */])(this._data);\n    }\n    disconnect() { }\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Class to be used to power selecting one or more options from a list.\n */\nclass collections_SelectionModel {\n    constructor(_multiple = false, initiallySelectedValues, _emitChanges = true) {\n        this._multiple = _multiple;\n        this._emitChanges = _emitChanges;\n        /** Currently-selected values. */\n        this._selection = new Set();\n        /** Keeps track of the deselected options that haven't been emitted by the change event. */\n        this._deselectedToEmit = [];\n        /** Keeps track of the selected options that haven't been emitted by the change event. */\n        this._selectedToEmit = [];\n        /** Event emitted when the value has changed. */\n        this.changed = new Subject[\"a\" /* Subject */]();\n        if (initiallySelectedValues && initiallySelectedValues.length) {\n            if (_multiple) {\n                initiallySelectedValues.forEach(value => this._markSelected(value));\n            }\n            else {\n                this._markSelected(initiallySelectedValues[0]);\n            }\n            // Clear the array in order to avoid firing the change event for preselected values.\n            this._selectedToEmit.length = 0;\n        }\n    }\n    /** Selected values. */\n    get selected() {\n        if (!this._selected) {\n            this._selected = Array.from(this._selection.values());\n        }\n        return this._selected;\n    }\n    /**\n     * Selects a value or an array of values.\n     */\n    select(...values) {\n        this._verifyValueAssignment(values);\n        values.forEach(value => this._markSelected(value));\n        this._emitChangeEvent();\n    }\n    /**\n     * Deselects a value or an array of values.\n     */\n    deselect(...values) {\n        this._verifyValueAssignment(values);\n        values.forEach(value => this._unmarkSelected(value));\n        this._emitChangeEvent();\n    }\n    /**\n     * Toggles a value between selected and deselected.\n     */\n    toggle(value) {\n        this.isSelected(value) ? this.deselect(value) : this.select(value);\n    }\n    /**\n     * Clears all of the selected values.\n     */\n    clear() {\n        this._unmarkAll();\n        this._emitChangeEvent();\n    }\n    /**\n     * Determines whether a value is selected.\n     */\n    isSelected(value) {\n        return this._selection.has(value);\n    }\n    /**\n     * Determines whether the model does not have a value.\n     */\n    isEmpty() {\n        return this._selection.size === 0;\n    }\n    /**\n     * Determines whether the model has a value.\n     */\n    hasValue() {\n        return !this.isEmpty();\n    }\n    /**\n     * Sorts the selected values based on a predicate function.\n     */\n    sort(predicate) {\n        if (this._multiple && this.selected) {\n            this._selected.sort(predicate);\n        }\n    }\n    /**\n     * Gets whether multiple values can be selected.\n     */\n    isMultipleSelection() {\n        return this._multiple;\n    }\n    /** Emits a change event and clears the records of selected and deselected values. */\n    _emitChangeEvent() {\n        // Clear the selected values so they can be re-cached.\n        this._selected = null;\n        if (this._selectedToEmit.length || this._deselectedToEmit.length) {\n            this.changed.next({\n                source: this,\n                added: this._selectedToEmit,\n                removed: this._deselectedToEmit\n            });\n            this._deselectedToEmit = [];\n            this._selectedToEmit = [];\n        }\n    }\n    /** Selects a value. */\n    _markSelected(value) {\n        if (!this.isSelected(value)) {\n            if (!this._multiple) {\n                this._unmarkAll();\n            }\n            this._selection.add(value);\n            if (this._emitChanges) {\n                this._selectedToEmit.push(value);\n            }\n        }\n    }\n    /** Deselects a value. */\n    _unmarkSelected(value) {\n        if (this.isSelected(value)) {\n            this._selection.delete(value);\n            if (this._emitChanges) {\n                this._deselectedToEmit.push(value);\n            }\n        }\n    }\n    /** Clears out the selected values. */\n    _unmarkAll() {\n        if (!this.isEmpty()) {\n            this._selection.forEach(value => this._unmarkSelected(value));\n        }\n    }\n    /**\n     * Verifies the value assignment and throws an error if the specified value array is\n     * including multiple values while the selection model is not supporting multiple values.\n     */\n    _verifyValueAssignment(values) {\n        if (values.length > 1 && !this._multiple) {\n            throw getMultipleValuesInSingleSelectionError();\n        }\n    }\n}\n/**\n * Returns an error that reports that multiple values are passed into a selection model\n * with a single value.\n * @docs-private\n */\nfunction getMultipleValuesInSingleSelectionError() {\n    return Error('Cannot pass multiple values into SelectionModel with single-value mode.');\n}\nlet collections_UniqueSelectionDispatcher = /*@__PURE__*/ (() => {\n    class UniqueSelectionDispatcher {\n        constructor() {\n            this._listeners = [];\n        }\n        /**\n         * Notify other items that selection for the given name has been set.\n         * @param id ID of the item.\n         * @param name Name of the item.\n         */\n        notify(id, name) {\n            for (let listener of this._listeners) {\n                listener(id, name);\n            }\n        }\n        /**\n         * Listen for future changes to item selection.\n         * @return Function used to deregister listener\n         */\n        listen(listener) {\n            this._listeners.push(listener);\n            return () => {\n                this._listeners = this._listeners.filter((registered) => {\n                    return listener !== registered;\n                });\n            };\n        }\n        ngOnDestroy() {\n            this._listeners = [];\n        }\n    }\n    UniqueSelectionDispatcher.ɵfac = function UniqueSelectionDispatcher_Factory(t) { return new (t || UniqueSelectionDispatcher)(); };\n    UniqueSelectionDispatcher.ɵprov = /*@__PURE__*/ Object(core[\"Lb\" /* ɵɵdefineInjectable */])({ factory: function UniqueSelectionDispatcher_Factory() { return new UniqueSelectionDispatcher(); }, token: UniqueSelectionDispatcher, providedIn: \"root\" });\n    return UniqueSelectionDispatcher;\n})();\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Generated bundle index. Do not edit.\n */\n\n//# sourceMappingURL=collections.js.map\n\n// CONCATENATED MODULE: ./node_modules/@angular/cdk/__ivy_ngcc__/fesm2015/scrolling.js\n\n\n\n\n\n\n\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/** The injection token used to specify the virtual scrolling strategy. */\n\n\n\nconst scrolling_c0 = [\"contentWrapper\"];\nconst scrolling_c1 = [\"*\"];\nconst VIRTUAL_SCROLL_STRATEGY = /*@__PURE__*/ new core[\"s\" /* InjectionToken */]('VIRTUAL_SCROLL_STRATEGY');\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/** Virtual scrolling strategy for lists with items of known fixed size. */\nclass scrolling_FixedSizeVirtualScrollStrategy {\n    /**\n     * @param itemSize The size of the items in the virtually scrolling list.\n     * @param minBufferPx The minimum amount of buffer (in pixels) before needing to render more\n     * @param maxBufferPx The amount of buffer (in pixels) to render when rendering more.\n     */\n    constructor(itemSize, minBufferPx, maxBufferPx) {\n        this._scrolledIndexChange = new Subject[\"a\" /* Subject */]();\n        /** @docs-private Implemented as part of VirtualScrollStrategy. */\n        this.scrolledIndexChange = this._scrolledIndexChange.pipe(Object(distinctUntilChanged[\"a\" /* distinctUntilChanged */])());\n        /** The attached viewport. */\n        this._viewport = null;\n        this._itemSize = itemSize;\n        this._minBufferPx = minBufferPx;\n        this._maxBufferPx = maxBufferPx;\n    }\n    /**\n     * Attaches this scroll strategy to a viewport.\n     * @param viewport The viewport to attach this strategy to.\n     */\n    attach(viewport) {\n        this._viewport = viewport;\n        this._updateTotalContentSize();\n        this._updateRenderedRange();\n    }\n    /** Detaches this scroll strategy from the currently attached viewport. */\n    detach() {\n        this._scrolledIndexChange.complete();\n        this._viewport = null;\n    }\n    /**\n     * Update the item size and buffer size.\n     * @param itemSize The size of the items in the virtually scrolling list.\n     * @param minBufferPx The minimum amount of buffer (in pixels) before needing to render more\n     * @param maxBufferPx The amount of buffer (in pixels) to render when rendering more.\n     */\n    updateItemAndBufferSize(itemSize, minBufferPx, maxBufferPx) {\n        if (maxBufferPx < minBufferPx) {\n            throw Error('CDK virtual scroll: maxBufferPx must be greater than or equal to minBufferPx');\n        }\n        this._itemSize = itemSize;\n        this._minBufferPx = minBufferPx;\n        this._maxBufferPx = maxBufferPx;\n        this._updateTotalContentSize();\n        this._updateRenderedRange();\n    }\n    /** @docs-private Implemented as part of VirtualScrollStrategy. */\n    onContentScrolled() {\n        this._updateRenderedRange();\n    }\n    /** @docs-private Implemented as part of VirtualScrollStrategy. */\n    onDataLengthChanged() {\n        this._updateTotalContentSize();\n        this._updateRenderedRange();\n    }\n    /** @docs-private Implemented as part of VirtualScrollStrategy. */\n    onContentRendered() { }\n    /** @docs-private Implemented as part of VirtualScrollStrategy. */\n    onRenderedOffsetChanged() { }\n    /**\n     * Scroll to the offset for the given index.\n     * @param index The index of the element to scroll to.\n     * @param behavior The ScrollBehavior to use when scrolling.\n     */\n    scrollToIndex(index, behavior) {\n        if (this._viewport) {\n            this._viewport.scrollToOffset(index * this._itemSize, behavior);\n        }\n    }\n    /** Update the viewport's total content size. */\n    _updateTotalContentSize() {\n        if (!this._viewport) {\n            return;\n        }\n        this._viewport.setTotalContentSize(this._viewport.getDataLength() * this._itemSize);\n    }\n    /** Update the viewport's rendered range. */\n    _updateRenderedRange() {\n        if (!this._viewport) {\n            return;\n        }\n        const renderedRange = this._viewport.getRenderedRange();\n        const newRange = { start: renderedRange.start, end: renderedRange.end };\n        const viewportSize = this._viewport.getViewportSize();\n        const dataLength = this._viewport.getDataLength();\n        let scrollOffset = this._viewport.measureScrollOffset();\n        let firstVisibleIndex = scrollOffset / this._itemSize;\n        // If user scrolls to the bottom of the list and data changes to a smaller list\n        if (newRange.end > dataLength) {\n            // We have to recalculate the first visible index based on new data length and viewport size.\n            const maxVisibleItems = Math.ceil(viewportSize / this._itemSize);\n            const newVisibleIndex = Math.max(0, Math.min(firstVisibleIndex, dataLength - maxVisibleItems));\n            // If first visible index changed we must update scroll offset to handle start/end buffers\n            // Current range must also be adjusted to cover the new position (bottom of new list).\n            if (firstVisibleIndex != newVisibleIndex) {\n                firstVisibleIndex = newVisibleIndex;\n                scrollOffset = newVisibleIndex * this._itemSize;\n                newRange.start = Math.floor(firstVisibleIndex);\n            }\n            newRange.end = Math.max(0, Math.min(dataLength, newRange.start + maxVisibleItems));\n        }\n        const startBuffer = scrollOffset - newRange.start * this._itemSize;\n        if (startBuffer < this._minBufferPx && newRange.start != 0) {\n            const expandStart = Math.ceil((this._maxBufferPx - startBuffer) / this._itemSize);\n            newRange.start = Math.max(0, newRange.start - expandStart);\n            newRange.end = Math.min(dataLength, Math.ceil(firstVisibleIndex + (viewportSize + this._minBufferPx) / this._itemSize));\n        }\n        else {\n            const endBuffer = newRange.end * this._itemSize - (scrollOffset + viewportSize);\n            if (endBuffer < this._minBufferPx && newRange.end != dataLength) {\n                const expandEnd = Math.ceil((this._maxBufferPx - endBuffer) / this._itemSize);\n                if (expandEnd > 0) {\n                    newRange.end = Math.min(dataLength, newRange.end + expandEnd);\n                    newRange.start = Math.max(0, Math.floor(firstVisibleIndex - this._minBufferPx / this._itemSize));\n                }\n            }\n        }\n        this._viewport.setRenderedRange(newRange);\n        this._viewport.setRenderedContentOffset(this._itemSize * newRange.start);\n        this._scrolledIndexChange.next(Math.floor(firstVisibleIndex));\n    }\n}\n/**\n * Provider factory for `FixedSizeVirtualScrollStrategy` that simply extracts the already created\n * `FixedSizeVirtualScrollStrategy` from the given directive.\n * @param fixedSizeDir The instance of `CdkFixedSizeVirtualScroll` to extract the\n *     `FixedSizeVirtualScrollStrategy` from.\n */\nfunction _fixedSizeVirtualScrollStrategyFactory(fixedSizeDir) {\n    return fixedSizeDir._scrollStrategy;\n}\nlet scrolling_CdkFixedSizeVirtualScroll = /*@__PURE__*/ (() => {\n    class CdkFixedSizeVirtualScroll {\n        constructor() {\n            this._itemSize = 20;\n            this._minBufferPx = 100;\n            this._maxBufferPx = 200;\n            /** The scroll strategy used by this directive. */\n            this._scrollStrategy = new scrolling_FixedSizeVirtualScrollStrategy(this.itemSize, this.minBufferPx, this.maxBufferPx);\n        }\n        /** The size of the items in the list (in pixels). */\n        get itemSize() { return this._itemSize; }\n        set itemSize(value) { this._itemSize = coerceNumberProperty(value); }\n        /**\n         * The minimum amount of buffer rendered beyond the viewport (in pixels).\n         * If the amount of buffer dips below this number, more items will be rendered. Defaults to 100px.\n         */\n        get minBufferPx() { return this._minBufferPx; }\n        set minBufferPx(value) { this._minBufferPx = coerceNumberProperty(value); }\n        /**\n         * The number of pixels worth of buffer to render for when rendering new items. Defaults to 200px.\n         */\n        get maxBufferPx() { return this._maxBufferPx; }\n        set maxBufferPx(value) { this._maxBufferPx = coerceNumberProperty(value); }\n        ngOnChanges() {\n            this._scrollStrategy.updateItemAndBufferSize(this.itemSize, this.minBufferPx, this.maxBufferPx);\n        }\n    }\n    CdkFixedSizeVirtualScroll.ɵfac = function CdkFixedSizeVirtualScroll_Factory(t) { return new (t || CdkFixedSizeVirtualScroll)(); };\n    CdkFixedSizeVirtualScroll.ɵdir = /*@__PURE__*/ core[\"Kb\" /* ɵɵdefineDirective */]({ type: CdkFixedSizeVirtualScroll, selectors: [[\"cdk-virtual-scroll-viewport\", \"itemSize\", \"\"]], inputs: { itemSize: \"itemSize\", minBufferPx: \"minBufferPx\", maxBufferPx: \"maxBufferPx\" }, features: [/*@__PURE__*/ core[\"Cb\" /* ɵɵProvidersFeature */]([{\n                    provide: VIRTUAL_SCROLL_STRATEGY,\n                    useFactory: _fixedSizeVirtualScrollStrategyFactory,\n                    deps: [/*@__PURE__*/ Object(core[\"W\" /* forwardRef */])(() => CdkFixedSizeVirtualScroll)]\n                }]), core[\"Bb\" /* ɵɵNgOnChangesFeature */]] });\n    return CdkFixedSizeVirtualScroll;\n})();\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/** Time in ms to throttle the scrolling events by default. */\nconst DEFAULT_SCROLL_TIME = 20;\nlet scrolling_ScrollDispatcher = /*@__PURE__*/ (() => {\n    class ScrollDispatcher {\n        constructor(_ngZone, _platform, \n        /** @breaking-change 11.0.0 make document required */\n        document) {\n            this._ngZone = _ngZone;\n            this._platform = _platform;\n            /** Subject for notifying that a registered scrollable reference element has been scrolled. */\n            this._scrolled = new Subject[\"a\" /* Subject */]();\n            /** Keeps track of the global `scroll` and `resize` subscriptions. */\n            this._globalSubscription = null;\n            /** Keeps track of the amount of subscriptions to `scrolled`. Used for cleaning up afterwards. */\n            this._scrolledCount = 0;\n            /**\n             * Map of all the scrollable references that are registered with the service and their\n             * scroll event subscriptions.\n             */\n            this.scrollContainers = new Map();\n            this._document = document;\n        }\n        /**\n         * Registers a scrollable instance with the service and listens for its scrolled events. When the\n         * scrollable is scrolled, the service emits the event to its scrolled observable.\n         * @param scrollable Scrollable instance to be registered.\n         */\n        register(scrollable) {\n            if (!this.scrollContainers.has(scrollable)) {\n                this.scrollContainers.set(scrollable, scrollable.elementScrolled()\n                    .subscribe(() => this._scrolled.next(scrollable)));\n            }\n        }\n        /**\n         * Deregisters a Scrollable reference and unsubscribes from its scroll event observable.\n         * @param scrollable Scrollable instance to be deregistered.\n         */\n        deregister(scrollable) {\n            const scrollableReference = this.scrollContainers.get(scrollable);\n            if (scrollableReference) {\n                scrollableReference.unsubscribe();\n                this.scrollContainers.delete(scrollable);\n            }\n        }\n        /**\n         * Returns an observable that emits an event whenever any of the registered Scrollable\n         * references (or window, document, or body) fire a scrolled event. Can provide a time in ms\n         * to override the default \"throttle\" time.\n         *\n         * **Note:** in order to avoid hitting change detection for every scroll event,\n         * all of the events emitted from this stream will be run outside the Angular zone.\n         * If you need to update any data bindings as a result of a scroll event, you have\n         * to run the callback using `NgZone.run`.\n         */\n        scrolled(auditTimeInMs = DEFAULT_SCROLL_TIME) {\n            if (!this._platform.isBrowser) {\n                return Object(of[\"a\" /* of */])();\n            }\n            return new Observable[\"a\" /* Observable */]((observer) => {\n                if (!this._globalSubscription) {\n                    this._addGlobalListener();\n                }\n                // In the case of a 0ms delay, use an observable without auditTime\n                // since it does add a perceptible delay in processing overhead.\n                const subscription = auditTimeInMs > 0 ?\n                    this._scrolled.pipe(auditTime(auditTimeInMs)).subscribe(observer) :\n                    this._scrolled.subscribe(observer);\n                this._scrolledCount++;\n                return () => {\n                    subscription.unsubscribe();\n                    this._scrolledCount--;\n                    if (!this._scrolledCount) {\n                        this._removeGlobalListener();\n                    }\n                };\n            });\n        }\n        ngOnDestroy() {\n            this._removeGlobalListener();\n            this.scrollContainers.forEach((_, container) => this.deregister(container));\n            this._scrolled.complete();\n        }\n        /**\n         * Returns an observable that emits whenever any of the\n         * scrollable ancestors of an element are scrolled.\n         * @param elementRef Element whose ancestors to listen for.\n         * @param auditTimeInMs Time to throttle the scroll events.\n         */\n        ancestorScrolled(elementRef, auditTimeInMs) {\n            const ancestors = this.getAncestorScrollContainers(elementRef);\n            return this.scrolled(auditTimeInMs).pipe(Object(filter[\"a\" /* filter */])(target => {\n                return !target || ancestors.indexOf(target) > -1;\n            }));\n        }\n        /** Returns all registered Scrollables that contain the provided element. */\n        getAncestorScrollContainers(elementRef) {\n            const scrollingContainers = [];\n            this.scrollContainers.forEach((_subscription, scrollable) => {\n                if (this._scrollableContainsElement(scrollable, elementRef)) {\n                    scrollingContainers.push(scrollable);\n                }\n            });\n            return scrollingContainers;\n        }\n        /** Access injected document if available or fallback to global document reference */\n        _getDocument() {\n            return this._document || document;\n        }\n        /** Use defaultView of injected document if available or fallback to global window reference */\n        _getWindow() {\n            const doc = this._getDocument();\n            return doc.defaultView || window;\n        }\n        /** Returns true if the element is contained within the provided Scrollable. */\n        _scrollableContainsElement(scrollable, elementRef) {\n            let element = elementRef.nativeElement;\n            let scrollableElement = scrollable.getElementRef().nativeElement;\n            // Traverse through the element parents until we reach null, checking if any of the elements\n            // are the scrollable's element.\n            do {\n                if (element == scrollableElement) {\n                    return true;\n                }\n            } while (element = element.parentElement);\n            return false;\n        }\n        /** Sets up the global scroll listeners. */\n        _addGlobalListener() {\n            this._globalSubscription = this._ngZone.runOutsideAngular(() => {\n                const window = this._getWindow();\n                return Object(fromEvent[\"a\" /* fromEvent */])(window.document, 'scroll').subscribe(() => this._scrolled.next());\n            });\n        }\n        /** Cleans up the global scroll listener. */\n        _removeGlobalListener() {\n            if (this._globalSubscription) {\n                this._globalSubscription.unsubscribe();\n                this._globalSubscription = null;\n            }\n        }\n    }\n    ScrollDispatcher.ɵfac = function ScrollDispatcher_Factory(t) { return new (t || ScrollDispatcher)(core[\"Zb\" /* ɵɵinject */](core[\"B\" /* NgZone */]), core[\"Zb\" /* ɵɵinject */](fesm2015_platform[\"a\" /* Platform */]), core[\"Zb\" /* ɵɵinject */](common[\"e\" /* DOCUMENT */], 8)); };\n    ScrollDispatcher.ɵprov = /*@__PURE__*/ Object(core[\"Lb\" /* ɵɵdefineInjectable */])({ factory: function ScrollDispatcher_Factory() { return new ScrollDispatcher(Object(core[\"Zb\" /* ɵɵinject */])(core[\"B\" /* NgZone */]), Object(core[\"Zb\" /* ɵɵinject */])(fesm2015_platform[\"a\" /* Platform */]), Object(core[\"Zb\" /* ɵɵinject */])(common[\"e\" /* DOCUMENT */], 8)); }, token: ScrollDispatcher, providedIn: \"root\" });\n    return ScrollDispatcher;\n})();\nlet scrolling_CdkScrollable = /*@__PURE__*/ (() => {\n    class CdkScrollable {\n        constructor(elementRef, scrollDispatcher, ngZone, dir) {\n            this.elementRef = elementRef;\n            this.scrollDispatcher = scrollDispatcher;\n            this.ngZone = ngZone;\n            this.dir = dir;\n            this._destroyed = new Subject[\"a\" /* Subject */]();\n            this._elementScrolled = new Observable[\"a\" /* Observable */]((observer) => this.ngZone.runOutsideAngular(() => Object(fromEvent[\"a\" /* fromEvent */])(this.elementRef.nativeElement, 'scroll').pipe(takeUntil(this._destroyed))\n                .subscribe(observer)));\n        }\n        ngOnInit() {\n            this.scrollDispatcher.register(this);\n        }\n        ngOnDestroy() {\n            this.scrollDispatcher.deregister(this);\n            this._destroyed.next();\n            this._destroyed.complete();\n        }\n        /** Returns observable that emits when a scroll event is fired on the host element. */\n        elementScrolled() {\n            return this._elementScrolled;\n        }\n        /** Gets the ElementRef for the viewport. */\n        getElementRef() {\n            return this.elementRef;\n        }\n        /**\n         * Scrolls to the specified offsets. This is a normalized version of the browser's native scrollTo\n         * method, since browsers are not consistent about what scrollLeft means in RTL. For this method\n         * left and right always refer to the left and right side of the scrolling container irrespective\n         * of the layout direction. start and end refer to left and right in an LTR context and vice-versa\n         * in an RTL context.\n         * @param options specified the offsets to scroll to.\n         */\n        scrollTo(options) {\n            const el = this.elementRef.nativeElement;\n            const isRtl = this.dir && this.dir.value == 'rtl';\n            // Rewrite start & end offsets as right or left offsets.\n            if (options.left == null) {\n                options.left = isRtl ? options.end : options.start;\n            }\n            if (options.right == null) {\n                options.right = isRtl ? options.start : options.end;\n            }\n            // Rewrite the bottom offset as a top offset.\n            if (options.bottom != null) {\n                options.top =\n                    el.scrollHeight - el.clientHeight - options.bottom;\n            }\n            // Rewrite the right offset as a left offset.\n            if (isRtl && Object(fesm2015_platform[\"d\" /* getRtlScrollAxisType */])() != 0 /* NORMAL */) {\n                if (options.left != null) {\n                    options.right =\n                        el.scrollWidth - el.clientWidth - options.left;\n                }\n                if (Object(fesm2015_platform[\"d\" /* getRtlScrollAxisType */])() == 2 /* INVERTED */) {\n                    options.left = options.right;\n                }\n                else if (Object(fesm2015_platform[\"d\" /* getRtlScrollAxisType */])() == 1 /* NEGATED */) {\n                    options.left = options.right ? -options.right : options.right;\n                }\n            }\n            else {\n                if (options.right != null) {\n                    options.left =\n                        el.scrollWidth - el.clientWidth - options.right;\n                }\n            }\n            this._applyScrollToOptions(options);\n        }\n        _applyScrollToOptions(options) {\n            const el = this.elementRef.nativeElement;\n            if (Object(fesm2015_platform[\"f\" /* supportsScrollBehavior */])()) {\n                el.scrollTo(options);\n            }\n            else {\n                if (options.top != null) {\n                    el.scrollTop = options.top;\n                }\n                if (options.left != null) {\n                    el.scrollLeft = options.left;\n                }\n            }\n        }\n        /**\n         * Measures the scroll offset relative to the specified edge of the viewport. This method can be\n         * used instead of directly checking scrollLeft or scrollTop, since browsers are not consistent\n         * about what scrollLeft means in RTL. The values returned by this method are normalized such that\n         * left and right always refer to the left and right side of the scrolling container irrespective\n         * of the layout direction. start and end refer to left and right in an LTR context and vice-versa\n         * in an RTL context.\n         * @param from The edge to measure from.\n         */\n        measureScrollOffset(from) {\n            const LEFT = 'left';\n            const RIGHT = 'right';\n            const el = this.elementRef.nativeElement;\n            if (from == 'top') {\n                return el.scrollTop;\n            }\n            if (from == 'bottom') {\n                return el.scrollHeight - el.clientHeight - el.scrollTop;\n            }\n            // Rewrite start & end as left or right offsets.\n            const isRtl = this.dir && this.dir.value == 'rtl';\n            if (from == 'start') {\n                from = isRtl ? RIGHT : LEFT;\n            }\n            else if (from == 'end') {\n                from = isRtl ? LEFT : RIGHT;\n            }\n            if (isRtl && Object(fesm2015_platform[\"d\" /* getRtlScrollAxisType */])() == 2 /* INVERTED */) {\n                // For INVERTED, scrollLeft is (scrollWidth - clientWidth) when scrolled all the way left and\n                // 0 when scrolled all the way right.\n                if (from == LEFT) {\n                    return el.scrollWidth - el.clientWidth - el.scrollLeft;\n                }\n                else {\n                    return el.scrollLeft;\n                }\n            }\n            else if (isRtl && Object(fesm2015_platform[\"d\" /* getRtlScrollAxisType */])() == 1 /* NEGATED */) {\n                // For NEGATED, scrollLeft is -(scrollWidth - clientWidth) when scrolled all the way left and\n                // 0 when scrolled all the way right.\n                if (from == LEFT) {\n                    return el.scrollLeft + el.scrollWidth - el.clientWidth;\n                }\n                else {\n                    return -el.scrollLeft;\n                }\n            }\n            else {\n                // For NORMAL, as well as non-RTL contexts, scrollLeft is 0 when scrolled all the way left and\n                // (scrollWidth - clientWidth) when scrolled all the way right.\n                if (from == LEFT) {\n                    return el.scrollLeft;\n                }\n                else {\n                    return el.scrollWidth - el.clientWidth - el.scrollLeft;\n                }\n            }\n        }\n    }\n    CdkScrollable.ɵfac = function CdkScrollable_Factory(t) { return new (t || CdkScrollable)(core[\"Pb\" /* ɵɵdirectiveInject */](core[\"m\" /* ElementRef */]), core[\"Pb\" /* ɵɵdirectiveInject */](scrolling_ScrollDispatcher), core[\"Pb\" /* ɵɵdirectiveInject */](core[\"B\" /* NgZone */]), core[\"Pb\" /* ɵɵdirectiveInject */](bidi_Directionality, 8)); };\n    CdkScrollable.ɵdir = /*@__PURE__*/ core[\"Kb\" /* ɵɵdefineDirective */]({ type: CdkScrollable, selectors: [[\"\", \"cdk-scrollable\", \"\"], [\"\", \"cdkScrollable\", \"\"]] });\n    return CdkScrollable;\n})();\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/** Time in ms to throttle the resize events by default. */\nconst DEFAULT_RESIZE_TIME = 20;\nlet scrolling_ViewportRuler = /*@__PURE__*/ (() => {\n    class ViewportRuler {\n        constructor(_platform, ngZone, \n        /** @breaking-change 11.0.0 make document required */\n        document) {\n            this._platform = _platform;\n            this._document = document;\n            ngZone.runOutsideAngular(() => {\n                const window = this._getWindow();\n                this._change = _platform.isBrowser ?\n                    Object(merge[\"a\" /* merge */])(Object(fromEvent[\"a\" /* fromEvent */])(window, 'resize'), Object(fromEvent[\"a\" /* fromEvent */])(window, 'orientationchange')) :\n                    Object(of[\"a\" /* of */])();\n                // Note that we need to do the subscription inside `runOutsideAngular`\n                // since subscribing is what causes the event listener to be added.\n                this._invalidateCache = this.change().subscribe(() => this._updateViewportSize());\n            });\n        }\n        ngOnDestroy() {\n            this._invalidateCache.unsubscribe();\n        }\n        /** Returns the viewport's width and height. */\n        getViewportSize() {\n            if (!this._viewportSize) {\n                this._updateViewportSize();\n            }\n            const output = { width: this._viewportSize.width, height: this._viewportSize.height };\n            // If we're not on a browser, don't cache the size since it'll be mocked out anyway.\n            if (!this._platform.isBrowser) {\n                this._viewportSize = null;\n            }\n            return output;\n        }\n        /** Gets a ClientRect for the viewport's bounds. */\n        getViewportRect() {\n            // Use the document element's bounding rect rather than the window scroll properties\n            // (e.g. pageYOffset, scrollY) due to in issue in Chrome and IE where window scroll\n            // properties and client coordinates (boundingClientRect, clientX/Y, etc.) are in different\n            // conceptual viewports. Under most circumstances these viewports are equivalent, but they\n            // can disagree when the page is pinch-zoomed (on devices that support touch).\n            // See https://bugs.chromium.org/p/chromium/issues/detail?id=489206#c4\n            // We use the documentElement instead of the body because, by default (without a css reset)\n            // browsers typically give the document body an 8px margin, which is not included in\n            // getBoundingClientRect().\n            const scrollPosition = this.getViewportScrollPosition();\n            const { width, height } = this.getViewportSize();\n            return {\n                top: scrollPosition.top,\n                left: scrollPosition.left,\n                bottom: scrollPosition.top + height,\n                right: scrollPosition.left + width,\n                height,\n                width,\n            };\n        }\n        /** Gets the (top, left) scroll position of the viewport. */\n        getViewportScrollPosition() {\n            // While we can get a reference to the fake document\n            // during SSR, it doesn't have getBoundingClientRect.\n            if (!this._platform.isBrowser) {\n                return { top: 0, left: 0 };\n            }\n            // The top-left-corner of the viewport is determined by the scroll position of the document\n            // body, normally just (scrollLeft, scrollTop). However, Chrome and Firefox disagree about\n            // whether `document.body` or `document.documentElement` is the scrolled element, so reading\n            // `scrollTop` and `scrollLeft` is inconsistent. However, using the bounding rect of\n            // `document.documentElement` works consistently, where the `top` and `left` values will\n            // equal negative the scroll position.\n            const document = this._getDocument();\n            const window = this._getWindow();\n            const documentElement = document.documentElement;\n            const documentRect = documentElement.getBoundingClientRect();\n            const top = -documentRect.top || document.body.scrollTop || window.scrollY ||\n                documentElement.scrollTop || 0;\n            const left = -documentRect.left || document.body.scrollLeft || window.scrollX ||\n                documentElement.scrollLeft || 0;\n            return { top, left };\n        }\n        /**\n         * Returns a stream that emits whenever the size of the viewport changes.\n         * @param throttleTime Time in milliseconds to throttle the stream.\n         */\n        change(throttleTime = DEFAULT_RESIZE_TIME) {\n            return throttleTime > 0 ? this._change.pipe(auditTime(throttleTime)) : this._change;\n        }\n        /** Access injected document if available or fallback to global document reference */\n        _getDocument() {\n            return this._document || document;\n        }\n        /** Use defaultView of injected document if available or fallback to global window reference */\n        _getWindow() {\n            const doc = this._getDocument();\n            return doc.defaultView || window;\n        }\n        /** Updates the cached viewport size. */\n        _updateViewportSize() {\n            const window = this._getWindow();\n            this._viewportSize = this._platform.isBrowser ?\n                { width: window.innerWidth, height: window.innerHeight } :\n                { width: 0, height: 0 };\n        }\n    }\n    ViewportRuler.ɵfac = function ViewportRuler_Factory(t) { return new (t || ViewportRuler)(core[\"Zb\" /* ɵɵinject */](fesm2015_platform[\"a\" /* Platform */]), core[\"Zb\" /* ɵɵinject */](core[\"B\" /* NgZone */]), core[\"Zb\" /* ɵɵinject */](common[\"e\" /* DOCUMENT */], 8)); };\n    ViewportRuler.ɵprov = /*@__PURE__*/ Object(core[\"Lb\" /* ɵɵdefineInjectable */])({ factory: function ViewportRuler_Factory() { return new ViewportRuler(Object(core[\"Zb\" /* ɵɵinject */])(fesm2015_platform[\"a\" /* Platform */]), Object(core[\"Zb\" /* ɵɵinject */])(core[\"B\" /* NgZone */]), Object(core[\"Zb\" /* ɵɵinject */])(common[\"e\" /* DOCUMENT */], 8)); }, token: ViewportRuler, providedIn: \"root\" });\n    return ViewportRuler;\n})();\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/** Checks if the given ranges are equal. */\nfunction rangesEqual(r1, r2) {\n    return r1.start == r2.start && r1.end == r2.end;\n}\n/**\n * Scheduler to be used for scroll events. Needs to fall back to\n * something that doesn't rely on requestAnimationFrame on environments\n * that don't support it (e.g. server-side rendering).\n */\nconst SCROLL_SCHEDULER = typeof requestAnimationFrame !== 'undefined' ? animationFrame : asap;\nlet scrolling_CdkVirtualScrollViewport = /*@__PURE__*/ (() => {\n    class CdkVirtualScrollViewport extends scrolling_CdkScrollable {\n        constructor(elementRef, _changeDetectorRef, ngZone, _scrollStrategy, dir, scrollDispatcher, \n        /**\n         * @deprecated `viewportRuler` parameter to become required.\n         * @breaking-change 11.0.0\n         */\n        viewportRuler) {\n            super(elementRef, scrollDispatcher, ngZone, dir);\n            this.elementRef = elementRef;\n            this._changeDetectorRef = _changeDetectorRef;\n            this._scrollStrategy = _scrollStrategy;\n            /** Emits when the viewport is detached from a CdkVirtualForOf. */\n            this._detachedSubject = new Subject[\"a\" /* Subject */]();\n            /** Emits when the rendered range changes. */\n            this._renderedRangeSubject = new Subject[\"a\" /* Subject */]();\n            this._orientation = 'vertical';\n            // Note: we don't use the typical EventEmitter here because we need to subscribe to the scroll\n            // strategy lazily (i.e. only if the user is actually listening to the events). We do this because\n            // depending on how the strategy calculates the scrolled index, it may come at a cost to\n            // performance.\n            /** Emits when the index of the first element visible in the viewport changes. */\n            this.scrolledIndexChange = new Observable[\"a\" /* Observable */]((observer) => this._scrollStrategy.scrolledIndexChange.subscribe(index => Promise.resolve().then(() => this.ngZone.run(() => observer.next(index)))));\n            /** A stream that emits whenever the rendered range changes. */\n            this.renderedRangeStream = this._renderedRangeSubject.asObservable();\n            /**\n             * The total size of all content (in pixels), including content that is not currently rendered.\n             */\n            this._totalContentSize = 0;\n            /** A string representing the `style.width` property value to be used for the spacer element. */\n            this._totalContentWidth = '';\n            /** A string representing the `style.height` property value to be used for the spacer element. */\n            this._totalContentHeight = '';\n            /** The currently rendered range of indices. */\n            this._renderedRange = { start: 0, end: 0 };\n            /** The length of the data bound to this viewport (in number of items). */\n            this._dataLength = 0;\n            /** The size of the viewport (in pixels). */\n            this._viewportSize = 0;\n            /** The last rendered content offset that was set. */\n            this._renderedContentOffset = 0;\n            /**\n             * Whether the last rendered content offset was to the end of the content (and therefore needs to\n             * be rewritten as an offset to the start of the content).\n             */\n            this._renderedContentOffsetNeedsRewrite = false;\n            /** Whether there is a pending change detection cycle. */\n            this._isChangeDetectionPending = false;\n            /** A list of functions to run after the next change detection cycle. */\n            this._runAfterChangeDetection = [];\n            /** Subscription to changes in the viewport size. */\n            this._viewportChanges = Subscription[\"a\" /* Subscription */].EMPTY;\n            if (!_scrollStrategy) {\n                throw Error('Error: cdk-virtual-scroll-viewport requires the \"itemSize\" property to be set.');\n            }\n            // @breaking-change 11.0.0 Remove null check for `viewportRuler`.\n            if (viewportRuler) {\n                this._viewportChanges = viewportRuler.change().subscribe(() => {\n                    this.checkViewportSize();\n                });\n            }\n        }\n        /** The direction the viewport scrolls. */\n        get orientation() {\n            return this._orientation;\n        }\n        set orientation(orientation) {\n            if (this._orientation !== orientation) {\n                this._orientation = orientation;\n                this._calculateSpacerSize();\n            }\n        }\n        ngOnInit() {\n            super.ngOnInit();\n            // It's still too early to measure the viewport at this point. Deferring with a promise allows\n            // the Viewport to be rendered with the correct size before we measure. We run this outside the\n            // zone to avoid causing more change detection cycles. We handle the change detection loop\n            // ourselves instead.\n            this.ngZone.runOutsideAngular(() => Promise.resolve().then(() => {\n                this._measureViewportSize();\n                this._scrollStrategy.attach(this);\n                this.elementScrolled()\n                    .pipe(\n                // Start off with a fake scroll event so we properly detect our initial position.\n                Object(startWith[\"a\" /* startWith */])(null), \n                // Collect multiple events into one until the next animation frame. This way if\n                // there are multiple scroll events in the same frame we only need to recheck\n                // our layout once.\n                auditTime(0, SCROLL_SCHEDULER))\n                    .subscribe(() => this._scrollStrategy.onContentScrolled());\n                this._markChangeDetectionNeeded();\n            }));\n        }\n        ngOnDestroy() {\n            this.detach();\n            this._scrollStrategy.detach();\n            // Complete all subjects\n            this._renderedRangeSubject.complete();\n            this._detachedSubject.complete();\n            this._viewportChanges.unsubscribe();\n            super.ngOnDestroy();\n        }\n        /** Attaches a `CdkVirtualForOf` to this viewport. */\n        attach(forOf) {\n            if (this._forOf) {\n                throw Error('CdkVirtualScrollViewport is already attached.');\n            }\n            // Subscribe to the data stream of the CdkVirtualForOf to keep track of when the data length\n            // changes. Run outside the zone to avoid triggering change detection, since we're managing the\n            // change detection loop ourselves.\n            this.ngZone.runOutsideAngular(() => {\n                this._forOf = forOf;\n                this._forOf.dataStream.pipe(takeUntil(this._detachedSubject)).subscribe(data => {\n                    const newLength = data.length;\n                    if (newLength !== this._dataLength) {\n                        this._dataLength = newLength;\n                        this._scrollStrategy.onDataLengthChanged();\n                    }\n                    this._doChangeDetection();\n                });\n            });\n        }\n        /** Detaches the current `CdkVirtualForOf`. */\n        detach() {\n            this._forOf = null;\n            this._detachedSubject.next();\n        }\n        /** Gets the length of the data bound to this viewport (in number of items). */\n        getDataLength() {\n            return this._dataLength;\n        }\n        /** Gets the size of the viewport (in pixels). */\n        getViewportSize() {\n            return this._viewportSize;\n        }\n        // TODO(mmalerba): This is technically out of sync with what's really rendered until a render\n        // cycle happens. I'm being careful to only call it after the render cycle is complete and before\n        // setting it to something else, but its error prone and should probably be split into\n        // `pendingRange` and `renderedRange`, the latter reflecting whats actually in the DOM.\n        /** Get the current rendered range of items. */\n        getRenderedRange() {\n            return this._renderedRange;\n        }\n        /**\n         * Sets the total size of all content (in pixels), including content that is not currently\n         * rendered.\n         */\n        setTotalContentSize(size) {\n            if (this._totalContentSize !== size) {\n                this._totalContentSize = size;\n                this._calculateSpacerSize();\n                this._markChangeDetectionNeeded();\n            }\n        }\n        /** Sets the currently rendered range of indices. */\n        setRenderedRange(range) {\n            if (!rangesEqual(this._renderedRange, range)) {\n                this._renderedRangeSubject.next(this._renderedRange = range);\n                this._markChangeDetectionNeeded(() => this._scrollStrategy.onContentRendered());\n            }\n        }\n        /**\n         * Gets the offset from the start of the viewport to the start of the rendered data (in pixels).\n         */\n        getOffsetToRenderedContentStart() {\n            return this._renderedContentOffsetNeedsRewrite ? null : this._renderedContentOffset;\n        }\n        /**\n         * Sets the offset from the start of the viewport to either the start or end of the rendered data\n         * (in pixels).\n         */\n        setRenderedContentOffset(offset, to = 'to-start') {\n            // For a horizontal viewport in a right-to-left language we need to translate along the x-axis\n            // in the negative direction.\n            const isRtl = this.dir && this.dir.value == 'rtl';\n            const isHorizontal = this.orientation == 'horizontal';\n            const axis = isHorizontal ? 'X' : 'Y';\n            const axisDirection = isHorizontal && isRtl ? -1 : 1;\n            let transform = `translate${axis}(${Number(axisDirection * offset)}px)`;\n            this._renderedContentOffset = offset;\n            if (to === 'to-end') {\n                transform += ` translate${axis}(-100%)`;\n                // The viewport should rewrite this as a `to-start` offset on the next render cycle. Otherwise\n                // elements will appear to expand in the wrong direction (e.g. `mat-expansion-panel` would\n                // expand upward).\n                this._renderedContentOffsetNeedsRewrite = true;\n            }\n            if (this._renderedContentTransform != transform) {\n                // We know this value is safe because we parse `offset` with `Number()` before passing it\n                // into the string.\n                this._renderedContentTransform = transform;\n                this._markChangeDetectionNeeded(() => {\n                    if (this._renderedContentOffsetNeedsRewrite) {\n                        this._renderedContentOffset -= this.measureRenderedContentSize();\n                        this._renderedContentOffsetNeedsRewrite = false;\n                        this.setRenderedContentOffset(this._renderedContentOffset);\n                    }\n                    else {\n                        this._scrollStrategy.onRenderedOffsetChanged();\n                    }\n                });\n            }\n        }\n        /**\n         * Scrolls to the given offset from the start of the viewport. Please note that this is not always\n         * the same as setting `scrollTop` or `scrollLeft`. In a horizontal viewport with right-to-left\n         * direction, this would be the equivalent of setting a fictional `scrollRight` property.\n         * @param offset The offset to scroll to.\n         * @param behavior The ScrollBehavior to use when scrolling. Default is behavior is `auto`.\n         */\n        scrollToOffset(offset, behavior = 'auto') {\n            const options = { behavior };\n            if (this.orientation === 'horizontal') {\n                options.start = offset;\n            }\n            else {\n                options.top = offset;\n            }\n            this.scrollTo(options);\n        }\n        /**\n         * Scrolls to the offset for the given index.\n         * @param index The index of the element to scroll to.\n         * @param behavior The ScrollBehavior to use when scrolling. Default is behavior is `auto`.\n         */\n        scrollToIndex(index, behavior = 'auto') {\n            this._scrollStrategy.scrollToIndex(index, behavior);\n        }\n        /**\n         * Gets the current scroll offset from the start of the viewport (in pixels).\n         * @param from The edge to measure the offset from. Defaults to 'top' in vertical mode and 'start'\n         *     in horizontal mode.\n         */\n        measureScrollOffset(from) {\n            return from ?\n                super.measureScrollOffset(from) :\n                super.measureScrollOffset(this.orientation === 'horizontal' ? 'start' : 'top');\n        }\n        /** Measure the combined size of all of the rendered items. */\n        measureRenderedContentSize() {\n            const contentEl = this._contentWrapper.nativeElement;\n            return this.orientation === 'horizontal' ? contentEl.offsetWidth : contentEl.offsetHeight;\n        }\n        /**\n         * Measure the total combined size of the given range. Throws if the range includes items that are\n         * not rendered.\n         */\n        measureRangeSize(range) {\n            if (!this._forOf) {\n                return 0;\n            }\n            return this._forOf.measureRangeSize(range, this.orientation);\n        }\n        /** Update the viewport dimensions and re-render. */\n        checkViewportSize() {\n            // TODO: Cleanup later when add logic for handling content resize\n            this._measureViewportSize();\n            this._scrollStrategy.onDataLengthChanged();\n        }\n        /** Measure the viewport size. */\n        _measureViewportSize() {\n            const viewportEl = this.elementRef.nativeElement;\n            this._viewportSize = this.orientation === 'horizontal' ?\n                viewportEl.clientWidth : viewportEl.clientHeight;\n        }\n        /** Queue up change detection to run. */\n        _markChangeDetectionNeeded(runAfter) {\n            if (runAfter) {\n                this._runAfterChangeDetection.push(runAfter);\n            }\n            // Use a Promise to batch together calls to `_doChangeDetection`. This way if we set a bunch of\n            // properties sequentially we only have to run `_doChangeDetection` once at the end.\n            if (!this._isChangeDetectionPending) {\n                this._isChangeDetectionPending = true;\n                this.ngZone.runOutsideAngular(() => Promise.resolve().then(() => {\n                    this._doChangeDetection();\n                }));\n            }\n        }\n        /** Run change detection. */\n        _doChangeDetection() {\n            this._isChangeDetectionPending = false;\n            // Apply the content transform. The transform can't be set via an Angular binding because\n            // bypassSecurityTrustStyle is banned in Google. However the value is safe, it's composed of\n            // string literals, a variable that can only be 'X' or 'Y', and user input that is run through\n            // the `Number` function first to coerce it to a numeric value.\n            this._contentWrapper.nativeElement.style.transform = this._renderedContentTransform;\n            // Apply changes to Angular bindings. Note: We must call `markForCheck` to run change detection\n            // from the root, since the repeated items are content projected in. Calling `detectChanges`\n            // instead does not properly check the projected content.\n            this.ngZone.run(() => this._changeDetectorRef.markForCheck());\n            const runAfterChangeDetection = this._runAfterChangeDetection;\n            this._runAfterChangeDetection = [];\n            for (const fn of runAfterChangeDetection) {\n                fn();\n            }\n        }\n        /** Calculates the `style.width` and `style.height` for the spacer element. */\n        _calculateSpacerSize() {\n            this._totalContentHeight =\n                this.orientation === 'horizontal' ? '' : `${this._totalContentSize}px`;\n            this._totalContentWidth =\n                this.orientation === 'horizontal' ? `${this._totalContentSize}px` : '';\n        }\n    }\n    CdkVirtualScrollViewport.ɵfac = function CdkVirtualScrollViewport_Factory(t) { return new (t || CdkVirtualScrollViewport)(core[\"Pb\" /* ɵɵdirectiveInject */](core[\"m\" /* ElementRef */]), core[\"Pb\" /* ɵɵdirectiveInject */](core[\"i\" /* ChangeDetectorRef */]), core[\"Pb\" /* ɵɵdirectiveInject */](core[\"B\" /* NgZone */]), core[\"Pb\" /* ɵɵdirectiveInject */](VIRTUAL_SCROLL_STRATEGY, 8), core[\"Pb\" /* ɵɵdirectiveInject */](bidi_Directionality, 8), core[\"Pb\" /* ɵɵdirectiveInject */](scrolling_ScrollDispatcher), core[\"Pb\" /* ɵɵdirectiveInject */](scrolling_ViewportRuler, 8)); };\n    CdkVirtualScrollViewport.ɵcmp = /*@__PURE__*/ core[\"Jb\" /* ɵɵdefineComponent */]({ type: CdkVirtualScrollViewport, selectors: [[\"cdk-virtual-scroll-viewport\"]], viewQuery: function CdkVirtualScrollViewport_Query(rf, ctx) {\n            if (rf & 1) {\n                core[\"Kc\" /* ɵɵviewQuery */](scrolling_c0, 3);\n            }\n            if (rf & 2) {\n                let _t;\n                core[\"tc\" /* ɵɵqueryRefresh */](_t = core[\"ec\" /* ɵɵloadQuery */]()) && (ctx._contentWrapper = _t.first);\n            }\n        }, hostAttrs: [1, \"cdk-virtual-scroll-viewport\"], hostVars: 4, hostBindings: function CdkVirtualScrollViewport_HostBindings(rf, ctx) {\n            if (rf & 2) {\n                core[\"Hb\" /* ɵɵclassProp */](\"cdk-virtual-scroll-orientation-horizontal\", ctx.orientation === \"horizontal\")(\"cdk-virtual-scroll-orientation-vertical\", ctx.orientation !== \"horizontal\");\n            }\n        }, inputs: { orientation: \"orientation\" }, outputs: { scrolledIndexChange: \"scrolledIndexChange\" }, features: [/*@__PURE__*/ core[\"Cb\" /* ɵɵProvidersFeature */]([{\n                    provide: scrolling_CdkScrollable,\n                    useExisting: CdkVirtualScrollViewport\n                }]), core[\"Ab\" /* ɵɵInheritDefinitionFeature */]], ngContentSelectors: scrolling_c1, decls: 4, vars: 4, consts: [[1, \"cdk-virtual-scroll-content-wrapper\"], [\"contentWrapper\", \"\"], [1, \"cdk-virtual-scroll-spacer\"]], template: function CdkVirtualScrollViewport_Template(rf, ctx) {\n            if (rf & 1) {\n                core[\"kc\" /* ɵɵprojectionDef */]();\n                core[\"Vb\" /* ɵɵelementStart */](0, \"div\", 0, 1);\n                core[\"jc\" /* ɵɵprojection */](2);\n                core[\"Ub\" /* ɵɵelementEnd */]();\n                core[\"Qb\" /* ɵɵelement */](3, \"div\", 2);\n            }\n            if (rf & 2) {\n                core[\"Db\" /* ɵɵadvance */](3);\n                core[\"Bc\" /* ɵɵstyleProp */](\"width\", ctx._totalContentWidth)(\"height\", ctx._totalContentHeight);\n            }\n        }, styles: [\"cdk-virtual-scroll-viewport{display:block;position:relative;overflow:auto;contain:strict;transform:translateZ(0);will-change:scroll-position;-webkit-overflow-scrolling:touch}.cdk-virtual-scroll-content-wrapper{position:absolute;top:0;left:0;contain:content}[dir=rtl] .cdk-virtual-scroll-content-wrapper{right:0;left:auto}.cdk-virtual-scroll-orientation-horizontal .cdk-virtual-scroll-content-wrapper{min-height:100%}.cdk-virtual-scroll-orientation-horizontal .cdk-virtual-scroll-content-wrapper>dl:not([cdkVirtualFor]),.cdk-virtual-scroll-orientation-horizontal .cdk-virtual-scroll-content-wrapper>ol:not([cdkVirtualFor]),.cdk-virtual-scroll-orientation-horizontal .cdk-virtual-scroll-content-wrapper>table:not([cdkVirtualFor]),.cdk-virtual-scroll-orientation-horizontal .cdk-virtual-scroll-content-wrapper>ul:not([cdkVirtualFor]){padding-left:0;padding-right:0;margin-left:0;margin-right:0;border-left-width:0;border-right-width:0;outline:none}.cdk-virtual-scroll-orientation-vertical .cdk-virtual-scroll-content-wrapper{min-width:100%}.cdk-virtual-scroll-orientation-vertical .cdk-virtual-scroll-content-wrapper>dl:not([cdkVirtualFor]),.cdk-virtual-scroll-orientation-vertical .cdk-virtual-scroll-content-wrapper>ol:not([cdkVirtualFor]),.cdk-virtual-scroll-orientation-vertical .cdk-virtual-scroll-content-wrapper>table:not([cdkVirtualFor]),.cdk-virtual-scroll-orientation-vertical .cdk-virtual-scroll-content-wrapper>ul:not([cdkVirtualFor]){padding-top:0;padding-bottom:0;margin-top:0;margin-bottom:0;border-top-width:0;border-bottom-width:0;outline:none}.cdk-virtual-scroll-spacer{position:absolute;top:0;left:0;height:1px;width:1px;transform-origin:0 0}[dir=rtl] .cdk-virtual-scroll-spacer{right:0;left:auto;transform-origin:100% 0}\\n\"], encapsulation: 2, changeDetection: 0 });\n    return CdkVirtualScrollViewport;\n})();\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/** Helper to extract size from a DOM Node. */\nfunction getSize(orientation, node) {\n    const el = node;\n    if (!el.getBoundingClientRect) {\n        return 0;\n    }\n    const rect = el.getBoundingClientRect();\n    return orientation == 'horizontal' ? rect.width : rect.height;\n}\nlet scrolling_CdkVirtualForOf = /*@__PURE__*/ (() => {\n    class CdkVirtualForOf {\n        constructor(\n        /** The view container to add items to. */\n        _viewContainerRef, \n        /** The template to use when stamping out new items. */\n        _template, \n        /** The set of available differs. */\n        _differs, \n        /** The virtual scrolling viewport that these items are being rendered in. */\n        _viewport, ngZone) {\n            this._viewContainerRef = _viewContainerRef;\n            this._template = _template;\n            this._differs = _differs;\n            this._viewport = _viewport;\n            /** Emits when the rendered view of the data changes. */\n            this.viewChange = new Subject[\"a\" /* Subject */]();\n            /** Subject that emits when a new DataSource instance is given. */\n            this._dataSourceChanges = new Subject[\"a\" /* Subject */]();\n            /**\n             * The size of the cache used to store templates that are not being used for re-use later.\n             * Setting the cache size to `0` will disable caching. Defaults to 20 templates.\n             */\n            this.cdkVirtualForTemplateCacheSize = 20;\n            /** Emits whenever the data in the current DataSource changes. */\n            this.dataStream = this._dataSourceChanges\n                .pipe(\n            // Start off with null `DataSource`.\n            Object(startWith[\"a\" /* startWith */])(null), \n            // Bundle up the previous and current data sources so we can work with both.\n            pairwise(), \n            // Use `_changeDataSource` to disconnect from the previous data source and connect to the\n            // new one, passing back a stream of data changes which we run through `switchMap` to give\n            // us a data stream that emits the latest data from whatever the current `DataSource` is.\n            Object(switchMap[\"a\" /* switchMap */])(([prev, cur]) => this._changeDataSource(prev, cur)), \n            // Replay the last emitted data when someone subscribes.\n            Object(shareReplay[\"a\" /* shareReplay */])(1));\n            /** The differ used to calculate changes to the data. */\n            this._differ = null;\n            /**\n             * The template cache used to hold on ot template instancess that have been stamped out, but don't\n             * currently need to be rendered. These instances will be reused in the future rather than\n             * stamping out brand new ones.\n             */\n            this._templateCache = [];\n            /** Whether the rendered data should be updated during the next ngDoCheck cycle. */\n            this._needsUpdate = false;\n            this._destroyed = new Subject[\"a\" /* Subject */]();\n            this.dataStream.subscribe(data => {\n                this._data = data;\n                this._onRenderedDataChange();\n            });\n            this._viewport.renderedRangeStream.pipe(takeUntil(this._destroyed)).subscribe(range => {\n                this._renderedRange = range;\n                ngZone.run(() => this.viewChange.next(this._renderedRange));\n                this._onRenderedDataChange();\n            });\n            this._viewport.attach(this);\n        }\n        /** The DataSource to display. */\n        get cdkVirtualForOf() {\n            return this._cdkVirtualForOf;\n        }\n        set cdkVirtualForOf(value) {\n            this._cdkVirtualForOf = value;\n            if (isDataSource(value)) {\n                this._dataSourceChanges.next(value);\n            }\n            else {\n                // Slice the value if its an NgIterable to ensure we're working with an array.\n                this._dataSourceChanges.next(new collections_ArrayDataSource(Object(isObservable[\"a\" /* isObservable */])(value) ? value : Array.prototype.slice.call(value || [])));\n            }\n        }\n        /**\n         * The `TrackByFunction` to use for tracking changes. The `TrackByFunction` takes the index and\n         * the item and produces a value to be used as the item's identity when tracking changes.\n         */\n        get cdkVirtualForTrackBy() {\n            return this._cdkVirtualForTrackBy;\n        }\n        set cdkVirtualForTrackBy(fn) {\n            this._needsUpdate = true;\n            this._cdkVirtualForTrackBy = fn ?\n                (index, item) => fn(index + (this._renderedRange ? this._renderedRange.start : 0), item) :\n                undefined;\n        }\n        /** The template used to stamp out new elements. */\n        set cdkVirtualForTemplate(value) {\n            if (value) {\n                this._needsUpdate = true;\n                this._template = value;\n            }\n        }\n        /**\n         * Measures the combined size (width for horizontal orientation, height for vertical) of all items\n         * in the specified range. Throws an error if the range includes items that are not currently\n         * rendered.\n         */\n        measureRangeSize(range, orientation) {\n            if (range.start >= range.end) {\n                return 0;\n            }\n            if (range.start < this._renderedRange.start || range.end > this._renderedRange.end) {\n                throw Error(`Error: attempted to measure an item that isn't rendered.`);\n            }\n            // The index into the list of rendered views for the first item in the range.\n            const renderedStartIndex = range.start - this._renderedRange.start;\n            // The length of the range we're measuring.\n            const rangeLen = range.end - range.start;\n            // Loop over all root nodes for all items in the range and sum up their size.\n            let totalSize = 0;\n            let i = rangeLen;\n            while (i--) {\n                const view = this._viewContainerRef.get(i + renderedStartIndex);\n                let j = view ? view.rootNodes.length : 0;\n                while (j--) {\n                    totalSize += getSize(orientation, view.rootNodes[j]);\n                }\n            }\n            return totalSize;\n        }\n        ngDoCheck() {\n            if (this._differ && this._needsUpdate) {\n                // TODO(mmalerba): We should differentiate needs update due to scrolling and a new portion of\n                // this list being rendered (can use simpler algorithm) vs needs update due to data actually\n                // changing (need to do this diff).\n                const changes = this._differ.diff(this._renderedItems);\n                if (!changes) {\n                    this._updateContext();\n                }\n                else {\n                    this._applyChanges(changes);\n                }\n                this._needsUpdate = false;\n            }\n        }\n        ngOnDestroy() {\n            this._viewport.detach();\n            this._dataSourceChanges.next(undefined);\n            this._dataSourceChanges.complete();\n            this.viewChange.complete();\n            this._destroyed.next();\n            this._destroyed.complete();\n            for (let view of this._templateCache) {\n                view.destroy();\n            }\n        }\n        /** React to scroll state changes in the viewport. */\n        _onRenderedDataChange() {\n            if (!this._renderedRange) {\n                return;\n            }\n            this._renderedItems = this._data.slice(this._renderedRange.start, this._renderedRange.end);\n            if (!this._differ) {\n                this._differ = this._differs.find(this._renderedItems).create(this.cdkVirtualForTrackBy);\n            }\n            this._needsUpdate = true;\n        }\n        /** Swap out one `DataSource` for another. */\n        _changeDataSource(oldDs, newDs) {\n            if (oldDs) {\n                oldDs.disconnect(this);\n            }\n            this._needsUpdate = true;\n            return newDs ? newDs.connect(this) : Object(of[\"a\" /* of */])();\n        }\n        /** Update the `CdkVirtualForOfContext` for all views. */\n        _updateContext() {\n            const count = this._data.length;\n            let i = this._viewContainerRef.length;\n            while (i--) {\n                let view = this._viewContainerRef.get(i);\n                view.context.index = this._renderedRange.start + i;\n                view.context.count = count;\n                this._updateComputedContextProperties(view.context);\n                view.detectChanges();\n            }\n        }\n        /** Apply changes to the DOM. */\n        _applyChanges(changes) {\n            // Rearrange the views to put them in the right location.\n            changes.forEachOperation((record, adjustedPreviousIndex, currentIndex) => {\n                if (record.previousIndex == null) { // Item added.\n                    const view = this._insertViewForNewItem(currentIndex);\n                    view.context.$implicit = record.item;\n                }\n                else if (currentIndex == null) { // Item removed.\n                    this._cacheView(this._detachView(adjustedPreviousIndex));\n                }\n                else { // Item moved.\n                    const view = this._viewContainerRef.get(adjustedPreviousIndex);\n                    this._viewContainerRef.move(view, currentIndex);\n                    view.context.$implicit = record.item;\n                }\n            });\n            // Update $implicit for any items that had an identity change.\n            changes.forEachIdentityChange((record) => {\n                const view = this._viewContainerRef.get(record.currentIndex);\n                view.context.$implicit = record.item;\n            });\n            // Update the context variables on all items.\n            const count = this._data.length;\n            let i = this._viewContainerRef.length;\n            while (i--) {\n                const view = this._viewContainerRef.get(i);\n                view.context.index = this._renderedRange.start + i;\n                view.context.count = count;\n                this._updateComputedContextProperties(view.context);\n            }\n        }\n        /** Cache the given detached view. */\n        _cacheView(view) {\n            if (this._templateCache.length < this.cdkVirtualForTemplateCacheSize) {\n                this._templateCache.push(view);\n            }\n            else {\n                const index = this._viewContainerRef.indexOf(view);\n                // It's very unlikely that the index will ever be -1, but just in case,\n                // destroy the view on its own, otherwise destroy it through the\n                // container to ensure that all the references are removed.\n                if (index === -1) {\n                    view.destroy();\n                }\n                else {\n                    this._viewContainerRef.remove(index);\n                }\n            }\n        }\n        /** Inserts a view for a new item, either from the cache or by creating a new one. */\n        _insertViewForNewItem(index) {\n            return this._insertViewFromCache(index) || this._createEmbeddedViewAt(index);\n        }\n        /** Update the computed properties on the `CdkVirtualForOfContext`. */\n        _updateComputedContextProperties(context) {\n            context.first = context.index === 0;\n            context.last = context.index === context.count - 1;\n            context.even = context.index % 2 === 0;\n            context.odd = !context.even;\n        }\n        /** Creates a new embedded view and moves it to the given index */\n        _createEmbeddedViewAt(index) {\n            // Note that it's important that we insert the item directly at the proper index,\n            // rather than inserting it and the moving it in place, because if there's a directive\n            // on the same node that injects the `ViewContainerRef`, Angular will insert another\n            // comment node which can throw off the move when it's being repeated for all items.\n            return this._viewContainerRef.createEmbeddedView(this._template, {\n                $implicit: null,\n                // It's guaranteed that the iterable is not \"undefined\" or \"null\" because we only\n                // generate views for elements if the \"cdkVirtualForOf\" iterable has elements.\n                cdkVirtualForOf: this._cdkVirtualForOf,\n                index: -1,\n                count: -1,\n                first: false,\n                last: false,\n                odd: false,\n                even: false\n            }, index);\n        }\n        /** Inserts a recycled view from the cache at the given index. */\n        _insertViewFromCache(index) {\n            const cachedView = this._templateCache.pop();\n            if (cachedView) {\n                this._viewContainerRef.insert(cachedView, index);\n            }\n            return cachedView || null;\n        }\n        /** Detaches the embedded view at the given index. */\n        _detachView(index) {\n            return this._viewContainerRef.detach(index);\n        }\n    }\n    CdkVirtualForOf.ɵfac = function CdkVirtualForOf_Factory(t) { return new (t || CdkVirtualForOf)(core[\"Pb\" /* ɵɵdirectiveInject */](core[\"R\" /* ViewContainerRef */]), core[\"Pb\" /* ɵɵdirectiveInject */](core[\"N\" /* TemplateRef */]), core[\"Pb\" /* ɵɵdirectiveInject */](core[\"u\" /* IterableDiffers */]), core[\"Pb\" /* ɵɵdirectiveInject */](scrolling_CdkVirtualScrollViewport, 4), core[\"Pb\" /* ɵɵdirectiveInject */](core[\"B\" /* NgZone */])); };\n    CdkVirtualForOf.ɵdir = /*@__PURE__*/ core[\"Kb\" /* ɵɵdefineDirective */]({ type: CdkVirtualForOf, selectors: [[\"\", \"cdkVirtualFor\", \"\", \"cdkVirtualForOf\", \"\"]], inputs: { cdkVirtualForTemplateCacheSize: \"cdkVirtualForTemplateCacheSize\", cdkVirtualForOf: \"cdkVirtualForOf\", cdkVirtualForTrackBy: \"cdkVirtualForTrackBy\", cdkVirtualForTemplate: \"cdkVirtualForTemplate\" } });\n    return CdkVirtualForOf;\n})();\nlet scrolling_CdkScrollableModule = /*@__PURE__*/ (() => {\n    class CdkScrollableModule {\n    }\n    CdkScrollableModule.ɵmod = /*@__PURE__*/ core[\"Nb\" /* ɵɵdefineNgModule */]({ type: CdkScrollableModule });\n    CdkScrollableModule.ɵinj = /*@__PURE__*/ core[\"Mb\" /* ɵɵdefineInjector */]({ factory: function CdkScrollableModule_Factory(t) { return new (t || CdkScrollableModule)(); } });\n    return CdkScrollableModule;\n})();\n/*@__PURE__*/ (function () { (typeof ngJitMode === \"undefined\" || ngJitMode) && core[\"Ac\" /* ɵɵsetNgModuleScope */](scrolling_CdkScrollableModule, { declarations: [scrolling_CdkScrollable], exports: [scrolling_CdkScrollable] }); })();\nlet scrolling_ScrollingModule = /*@__PURE__*/ (() => {\n    class ScrollingModule {\n    }\n    ScrollingModule.ɵmod = /*@__PURE__*/ core[\"Nb\" /* ɵɵdefineNgModule */]({ type: ScrollingModule });\n    ScrollingModule.ɵinj = /*@__PURE__*/ core[\"Mb\" /* ɵɵdefineInjector */]({ factory: function ScrollingModule_Factory(t) { return new (t || ScrollingModule)(); }, imports: [[\n                bidi_BidiModule,\n                fesm2015_platform[\"b\" /* PlatformModule */],\n                scrolling_CdkScrollableModule\n            ], bidi_BidiModule, scrolling_CdkScrollableModule] });\n    return ScrollingModule;\n})();\n/*@__PURE__*/ (function () {\n    (typeof ngJitMode === \"undefined\" || ngJitMode) && core[\"Ac\" /* ɵɵsetNgModuleScope */](scrolling_ScrollingModule, { declarations: function () { return [scrolling_CdkFixedSizeVirtualScroll, scrolling_CdkVirtualForOf, scrolling_CdkVirtualScrollViewport]; }, imports: function () {\n            return [bidi_BidiModule,\n                fesm2015_platform[\"b\" /* PlatformModule */], scrolling_CdkScrollableModule];\n        }, exports: function () { return [bidi_BidiModule, scrolling_CdkScrollableModule, scrolling_CdkFixedSizeVirtualScroll, scrolling_CdkVirtualForOf, scrolling_CdkVirtualScrollViewport]; } });\n})();\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Generated bundle index. Do not edit.\n */\n\n//# sourceMappingURL=scrolling.js.map\n\n// CONCATENATED MODULE: ./node_modules/@angular/cdk/__ivy_ngcc__/fesm2015/overlay.js\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Strategy that will prevent the user from scrolling while the overlay is visible.\n */\nclass overlay_BlockScrollStrategy {\n    constructor(_viewportRuler, document) {\n        this._viewportRuler = _viewportRuler;\n        this._previousHTMLStyles = { top: '', left: '' };\n        this._isEnabled = false;\n        this._document = document;\n    }\n    /** Attaches this scroll strategy to an overlay. */\n    attach() { }\n    /** Blocks page-level scroll while the attached overlay is open. */\n    enable() {\n        if (this._canBeEnabled()) {\n            const root = this._document.documentElement;\n            this._previousScrollPosition = this._viewportRuler.getViewportScrollPosition();\n            // Cache the previous inline styles in case the user had set them.\n            this._previousHTMLStyles.left = root.style.left || '';\n            this._previousHTMLStyles.top = root.style.top || '';\n            // Note: we're using the `html` node, instead of the `body`, because the `body` may\n            // have the user agent margin, whereas the `html` is guaranteed not to have one.\n            root.style.left = coerceCssPixelValue(-this._previousScrollPosition.left);\n            root.style.top = coerceCssPixelValue(-this._previousScrollPosition.top);\n            root.classList.add('cdk-global-scrollblock');\n            this._isEnabled = true;\n        }\n    }\n    /** Unblocks page-level scroll while the attached overlay is open. */\n    disable() {\n        if (this._isEnabled) {\n            const html = this._document.documentElement;\n            const body = this._document.body;\n            const htmlStyle = html.style;\n            const bodyStyle = body.style;\n            const previousHtmlScrollBehavior = htmlStyle.scrollBehavior || '';\n            const previousBodyScrollBehavior = bodyStyle.scrollBehavior || '';\n            this._isEnabled = false;\n            htmlStyle.left = this._previousHTMLStyles.left;\n            htmlStyle.top = this._previousHTMLStyles.top;\n            html.classList.remove('cdk-global-scrollblock');\n            // Disable user-defined smooth scrolling temporarily while we restore the scroll position.\n            // See https://developer.mozilla.org/en-US/docs/Web/CSS/scroll-behavior\n            htmlStyle.scrollBehavior = bodyStyle.scrollBehavior = 'auto';\n            window.scroll(this._previousScrollPosition.left, this._previousScrollPosition.top);\n            htmlStyle.scrollBehavior = previousHtmlScrollBehavior;\n            bodyStyle.scrollBehavior = previousBodyScrollBehavior;\n        }\n    }\n    _canBeEnabled() {\n        // Since the scroll strategies can't be singletons, we have to use a global CSS class\n        // (`cdk-global-scrollblock`) to make sure that we don't try to disable global\n        // scrolling multiple times.\n        const html = this._document.documentElement;\n        if (html.classList.contains('cdk-global-scrollblock') || this._isEnabled) {\n            return false;\n        }\n        const body = this._document.body;\n        const viewport = this._viewportRuler.getViewportSize();\n        return body.scrollHeight > viewport.height || body.scrollWidth > viewport.width;\n    }\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Returns an error to be thrown when attempting to attach an already-attached scroll strategy.\n */\nfunction getMatScrollStrategyAlreadyAttachedError() {\n    return Error(`Scroll strategy has already been attached.`);\n}\n/**\n * Strategy that will close the overlay as soon as the user starts scrolling.\n */\nclass CloseScrollStrategy {\n    constructor(_scrollDispatcher, _ngZone, _viewportRuler, _config) {\n        this._scrollDispatcher = _scrollDispatcher;\n        this._ngZone = _ngZone;\n        this._viewportRuler = _viewportRuler;\n        this._config = _config;\n        this._scrollSubscription = null;\n        /** Detaches the overlay ref and disables the scroll strategy. */\n        this._detach = () => {\n            this.disable();\n            if (this._overlayRef.hasAttached()) {\n                this._ngZone.run(() => this._overlayRef.detach());\n            }\n        };\n    }\n    /** Attaches this scroll strategy to an overlay. */\n    attach(overlayRef) {\n        if (this._overlayRef) {\n            throw getMatScrollStrategyAlreadyAttachedError();\n        }\n        this._overlayRef = overlayRef;\n    }\n    /** Enables the closing of the attached overlay on scroll. */\n    enable() {\n        if (this._scrollSubscription) {\n            return;\n        }\n        const stream = this._scrollDispatcher.scrolled(0);\n        if (this._config && this._config.threshold && this._config.threshold > 1) {\n            this._initialScrollPosition = this._viewportRuler.getViewportScrollPosition().top;\n            this._scrollSubscription = stream.subscribe(() => {\n                const scrollPosition = this._viewportRuler.getViewportScrollPosition().top;\n                if (Math.abs(scrollPosition - this._initialScrollPosition) > this._config.threshold) {\n                    this._detach();\n                }\n                else {\n                    this._overlayRef.updatePosition();\n                }\n            });\n        }\n        else {\n            this._scrollSubscription = stream.subscribe(this._detach);\n        }\n    }\n    /** Disables the closing the attached overlay on scroll. */\n    disable() {\n        if (this._scrollSubscription) {\n            this._scrollSubscription.unsubscribe();\n            this._scrollSubscription = null;\n        }\n    }\n    detach() {\n        this.disable();\n        this._overlayRef = null;\n    }\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/** Scroll strategy that doesn't do anything. */\nclass NoopScrollStrategy {\n    /** Does nothing, as this scroll strategy is a no-op. */\n    enable() { }\n    /** Does nothing, as this scroll strategy is a no-op. */\n    disable() { }\n    /** Does nothing, as this scroll strategy is a no-op. */\n    attach() { }\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n// TODO(jelbourn): move this to live with the rest of the scrolling code\n// TODO(jelbourn): someday replace this with IntersectionObservers\n/**\n * Gets whether an element is scrolled outside of view by any of its parent scrolling containers.\n * @param element Dimensions of the element (from getBoundingClientRect)\n * @param scrollContainers Dimensions of element's scrolling containers (from getBoundingClientRect)\n * @returns Whether the element is scrolled out of view\n * @docs-private\n */\nfunction isElementScrolledOutsideView(element, scrollContainers) {\n    return scrollContainers.some(containerBounds => {\n        const outsideAbove = element.bottom < containerBounds.top;\n        const outsideBelow = element.top > containerBounds.bottom;\n        const outsideLeft = element.right < containerBounds.left;\n        const outsideRight = element.left > containerBounds.right;\n        return outsideAbove || outsideBelow || outsideLeft || outsideRight;\n    });\n}\n/**\n * Gets whether an element is clipped by any of its scrolling containers.\n * @param element Dimensions of the element (from getBoundingClientRect)\n * @param scrollContainers Dimensions of element's scrolling containers (from getBoundingClientRect)\n * @returns Whether the element is clipped\n * @docs-private\n */\nfunction isElementClippedByScrolling(element, scrollContainers) {\n    return scrollContainers.some(scrollContainerRect => {\n        const clippedAbove = element.top < scrollContainerRect.top;\n        const clippedBelow = element.bottom > scrollContainerRect.bottom;\n        const clippedLeft = element.left < scrollContainerRect.left;\n        const clippedRight = element.right > scrollContainerRect.right;\n        return clippedAbove || clippedBelow || clippedLeft || clippedRight;\n    });\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Strategy that will update the element position as the user is scrolling.\n */\nclass RepositionScrollStrategy {\n    constructor(_scrollDispatcher, _viewportRuler, _ngZone, _config) {\n        this._scrollDispatcher = _scrollDispatcher;\n        this._viewportRuler = _viewportRuler;\n        this._ngZone = _ngZone;\n        this._config = _config;\n        this._scrollSubscription = null;\n    }\n    /** Attaches this scroll strategy to an overlay. */\n    attach(overlayRef) {\n        if (this._overlayRef) {\n            throw getMatScrollStrategyAlreadyAttachedError();\n        }\n        this._overlayRef = overlayRef;\n    }\n    /** Enables repositioning of the attached overlay on scroll. */\n    enable() {\n        if (!this._scrollSubscription) {\n            const throttle = this._config ? this._config.scrollThrottle : 0;\n            this._scrollSubscription = this._scrollDispatcher.scrolled(throttle).subscribe(() => {\n                this._overlayRef.updatePosition();\n                // TODO(crisbeto): make `close` on by default once all components can handle it.\n                if (this._config && this._config.autoClose) {\n                    const overlayRect = this._overlayRef.overlayElement.getBoundingClientRect();\n                    const { width, height } = this._viewportRuler.getViewportSize();\n                    // TODO(crisbeto): include all ancestor scroll containers here once\n                    // we have a way of exposing the trigger element to the scroll strategy.\n                    const parentRects = [{ width, height, bottom: height, right: width, top: 0, left: 0 }];\n                    if (isElementScrolledOutsideView(overlayRect, parentRects)) {\n                        this.disable();\n                        this._ngZone.run(() => this._overlayRef.detach());\n                    }\n                }\n            });\n        }\n    }\n    /** Disables repositioning of the attached overlay on scroll. */\n    disable() {\n        if (this._scrollSubscription) {\n            this._scrollSubscription.unsubscribe();\n            this._scrollSubscription = null;\n        }\n    }\n    detach() {\n        this.disable();\n        this._overlayRef = null;\n    }\n}\nlet overlay_ScrollStrategyOptions = /*@__PURE__*/ (() => {\n    class ScrollStrategyOptions {\n        constructor(_scrollDispatcher, _viewportRuler, _ngZone, document) {\n            this._scrollDispatcher = _scrollDispatcher;\n            this._viewportRuler = _viewportRuler;\n            this._ngZone = _ngZone;\n            /** Do nothing on scroll. */\n            this.noop = () => new NoopScrollStrategy();\n            /**\n             * Close the overlay as soon as the user scrolls.\n             * @param config Configuration to be used inside the scroll strategy.\n             */\n            this.close = (config) => new CloseScrollStrategy(this._scrollDispatcher, this._ngZone, this._viewportRuler, config);\n            /** Block scrolling. */\n            this.block = () => new overlay_BlockScrollStrategy(this._viewportRuler, this._document);\n            /**\n             * Update the overlay's position on scroll.\n             * @param config Configuration to be used inside the scroll strategy.\n             * Allows debouncing the reposition calls.\n             */\n            this.reposition = (config) => new RepositionScrollStrategy(this._scrollDispatcher, this._viewportRuler, this._ngZone, config);\n            this._document = document;\n        }\n    }\n    ScrollStrategyOptions.ɵfac = function ScrollStrategyOptions_Factory(t) { return new (t || ScrollStrategyOptions)(core[\"Zb\" /* ɵɵinject */](scrolling_ScrollDispatcher), core[\"Zb\" /* ɵɵinject */](scrolling_ViewportRuler), core[\"Zb\" /* ɵɵinject */](core[\"B\" /* NgZone */]), core[\"Zb\" /* ɵɵinject */](common[\"e\" /* DOCUMENT */])); };\n    ScrollStrategyOptions.ɵprov = /*@__PURE__*/ Object(core[\"Lb\" /* ɵɵdefineInjectable */])({ factory: function ScrollStrategyOptions_Factory() { return new ScrollStrategyOptions(Object(core[\"Zb\" /* ɵɵinject */])(scrolling_ScrollDispatcher), Object(core[\"Zb\" /* ɵɵinject */])(scrolling_ViewportRuler), Object(core[\"Zb\" /* ɵɵinject */])(core[\"B\" /* NgZone */]), Object(core[\"Zb\" /* ɵɵinject */])(common[\"e\" /* DOCUMENT */])); }, token: ScrollStrategyOptions, providedIn: \"root\" });\n    return ScrollStrategyOptions;\n})();\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/** Initial configuration used when creating an overlay. */\nclass OverlayConfig {\n    constructor(config) {\n        /** Strategy to be used when handling scroll events while the overlay is open. */\n        this.scrollStrategy = new NoopScrollStrategy();\n        /** Custom class to add to the overlay pane. */\n        this.panelClass = '';\n        /** Whether the overlay has a backdrop. */\n        this.hasBackdrop = false;\n        /** Custom class to add to the backdrop */\n        this.backdropClass = 'cdk-overlay-dark-backdrop';\n        /**\n         * Whether the overlay should be disposed of when the user goes backwards/forwards in history.\n         * Note that this usually doesn't include clicking on links (unless the user is using\n         * the `HashLocationStrategy`).\n         */\n        this.disposeOnNavigation = false;\n        if (config) {\n            // Use `Iterable` instead of `Array` because TypeScript, as of 3.6.3,\n            // loses the array generic type in the `for of`. But we *also* have to use `Array` because\n            // typescript won't iterate over an `Iterable` unless you compile with `--downlevelIteration`\n            const configKeys = Object.keys(config);\n            for (const key of configKeys) {\n                if (config[key] !== undefined) {\n                    // TypeScript, as of version 3.5, sees the left-hand-side of this expression\n                    // as \"I don't know *which* key this is, so the only valid value is the intersection\n                    // of all the posible values.\" In this case, that happens to be `undefined`. TypeScript\n                    // is not smart enough to see that the right-hand-side is actually an access of the same\n                    // exact type with the same exact key, meaning that the value type must be identical.\n                    // So we use `any` to work around this.\n                    this[key] = config[key];\n                }\n            }\n        }\n    }\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/** The points of the origin element and the overlay element to connect. */\nclass ConnectionPositionPair {\n    constructor(origin, overlay, \n    /** Offset along the X axis. */\n    offsetX, \n    /** Offset along the Y axis. */\n    offsetY, \n    /** Class(es) to be applied to the panel while this position is active. */\n    panelClass) {\n        this.offsetX = offsetX;\n        this.offsetY = offsetY;\n        this.panelClass = panelClass;\n        this.originX = origin.originX;\n        this.originY = origin.originY;\n        this.overlayX = overlay.overlayX;\n        this.overlayY = overlay.overlayY;\n    }\n}\n/**\n * Set of properties regarding the position of the origin and overlay relative to the viewport\n * with respect to the containing Scrollable elements.\n *\n * The overlay and origin are clipped if any part of their bounding client rectangle exceeds the\n * bounds of any one of the strategy's Scrollable's bounding client rectangle.\n *\n * The overlay and origin are outside view if there is no overlap between their bounding client\n * rectangle and any one of the strategy's Scrollable's bounding client rectangle.\n *\n *       -----------                    -----------\n *       | outside |                    | clipped |\n *       |  view   |              --------------------------\n *       |         |              |     |         |        |\n *       ----------               |     -----------        |\n *  --------------------------    |                        |\n *  |                        |    |      Scrollable        |\n *  |                        |    |                        |\n *  |                        |     --------------------------\n *  |      Scrollable        |\n *  |                        |\n *  --------------------------\n *\n *  @docs-private\n */\nclass ScrollingVisibility {\n}\n/** The change event emitted by the strategy when a fallback position is used. */\nclass ConnectedOverlayPositionChange {\n    constructor(\n    /** The position used as a result of this change. */\n    connectionPair, \n    /** @docs-private */\n    scrollableViewProperties) {\n        this.connectionPair = connectionPair;\n        this.scrollableViewProperties = scrollableViewProperties;\n    }\n}\n/**\n * Validates whether a vertical position property matches the expected values.\n * @param property Name of the property being validated.\n * @param value Value of the property being validated.\n * @docs-private\n */\nfunction validateVerticalPosition(property, value) {\n    if (value !== 'top' && value !== 'bottom' && value !== 'center') {\n        throw Error(`ConnectedPosition: Invalid ${property} \"${value}\". ` +\n            `Expected \"top\", \"bottom\" or \"center\".`);\n    }\n}\n/**\n * Validates whether a horizontal position property matches the expected values.\n * @param property Name of the property being validated.\n * @param value Value of the property being validated.\n * @docs-private\n */\nfunction validateHorizontalPosition(property, value) {\n    if (value !== 'start' && value !== 'end' && value !== 'center') {\n        throw Error(`ConnectedPosition: Invalid ${property} \"${value}\". ` +\n            `Expected \"start\", \"end\" or \"center\".`);\n    }\n}\nlet overlay_OverlayKeyboardDispatcher = /*@__PURE__*/ (() => {\n    class OverlayKeyboardDispatcher {\n        constructor(document) {\n            /** Currently attached overlays in the order they were attached. */\n            this._attachedOverlays = [];\n            /** Keyboard event listener that will be attached to the body. */\n            this._keydownListener = (event) => {\n                const overlays = this._attachedOverlays;\n                for (let i = overlays.length - 1; i > -1; i--) {\n                    // Dispatch the keydown event to the top overlay which has subscribers to its keydown events.\n                    // We want to target the most recent overlay, rather than trying to match where the event came\n                    // from, because some components might open an overlay, but keep focus on a trigger element\n                    // (e.g. for select and autocomplete). We skip overlays without keydown event subscriptions,\n                    // because we don't want overlays that don't handle keyboard events to block the ones below\n                    // them that do.\n                    if (overlays[i]._keydownEvents.observers.length > 0) {\n                        overlays[i]._keydownEvents.next(event);\n                        break;\n                    }\n                }\n            };\n            this._document = document;\n        }\n        ngOnDestroy() {\n            this._detach();\n        }\n        /** Add a new overlay to the list of attached overlay refs. */\n        add(overlayRef) {\n            // Ensure that we don't get the same overlay multiple times.\n            this.remove(overlayRef);\n            // Lazily start dispatcher once first overlay is added\n            if (!this._isAttached) {\n                this._document.body.addEventListener('keydown', this._keydownListener);\n                this._isAttached = true;\n            }\n            this._attachedOverlays.push(overlayRef);\n        }\n        /** Remove an overlay from the list of attached overlay refs. */\n        remove(overlayRef) {\n            const index = this._attachedOverlays.indexOf(overlayRef);\n            if (index > -1) {\n                this._attachedOverlays.splice(index, 1);\n            }\n            // Remove the global listener once there are no more overlays.\n            if (this._attachedOverlays.length === 0) {\n                this._detach();\n            }\n        }\n        /** Detaches the global keyboard event listener. */\n        _detach() {\n            if (this._isAttached) {\n                this._document.body.removeEventListener('keydown', this._keydownListener);\n                this._isAttached = false;\n            }\n        }\n    }\n    OverlayKeyboardDispatcher.ɵfac = function OverlayKeyboardDispatcher_Factory(t) { return new (t || OverlayKeyboardDispatcher)(core[\"Zb\" /* ɵɵinject */](common[\"e\" /* DOCUMENT */])); };\n    OverlayKeyboardDispatcher.ɵprov = /*@__PURE__*/ Object(core[\"Lb\" /* ɵɵdefineInjectable */])({ factory: function OverlayKeyboardDispatcher_Factory() { return new OverlayKeyboardDispatcher(Object(core[\"Zb\" /* ɵɵinject */])(common[\"e\" /* DOCUMENT */])); }, token: OverlayKeyboardDispatcher, providedIn: \"root\" });\n    return OverlayKeyboardDispatcher;\n})();\n/** @docs-private @deprecated @breaking-change 8.0.0 */\nfunction OVERLAY_KEYBOARD_DISPATCHER_PROVIDER_FACTORY(dispatcher, _document) {\n    return dispatcher || new overlay_OverlayKeyboardDispatcher(_document);\n}\n/** @docs-private @deprecated @breaking-change 8.0.0 */\nconst OVERLAY_KEYBOARD_DISPATCHER_PROVIDER = {\n    // If there is already an OverlayKeyboardDispatcher available, use that.\n    // Otherwise, provide a new one.\n    provide: overlay_OverlayKeyboardDispatcher,\n    deps: [\n        [/*@__PURE__*/ new core[\"C\" /* Optional */](), /*@__PURE__*/ new core[\"L\" /* SkipSelf */](), overlay_OverlayKeyboardDispatcher],\n        // Coerce to `InjectionToken` so that the `deps` match the \"shape\"\n        // of the type expected by Angular\n        common[\"e\" /* DOCUMENT */]\n    ],\n    useFactory: OVERLAY_KEYBOARD_DISPATCHER_PROVIDER_FACTORY\n};\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Whether we're in a testing environment.\n * TODO(crisbeto): remove this once we have an overlay testing module.\n */\nconst isTestEnvironment = typeof window !== 'undefined' && !!window &&\n    !!(window.__karma__ || window.jasmine);\nlet overlay_OverlayContainer = /*@__PURE__*/ (() => {\n    class OverlayContainer {\n        constructor(document, \n        /**\n         * @deprecated `platform` parameter to become required.\n         * @breaking-change 10.0.0\n         */\n        _platform) {\n            this._platform = _platform;\n            this._document = document;\n        }\n        ngOnDestroy() {\n            const container = this._containerElement;\n            if (container && container.parentNode) {\n                container.parentNode.removeChild(container);\n            }\n        }\n        /**\n         * This method returns the overlay container element. It will lazily\n         * create the element the first time  it is called to facilitate using\n         * the container in non-browser environments.\n         * @returns the container element\n         */\n        getContainerElement() {\n            if (!this._containerElement) {\n                this._createContainer();\n            }\n            return this._containerElement;\n        }\n        /**\n         * Create the overlay container element, which is simply a div\n         * with the 'cdk-overlay-container' class on the document body.\n         */\n        _createContainer() {\n            // @breaking-change 10.0.0 Remove null check for `_platform`.\n            const isBrowser = this._platform ? this._platform.isBrowser : typeof window !== 'undefined';\n            const containerClass = 'cdk-overlay-container';\n            if (isBrowser || isTestEnvironment) {\n                const oppositePlatformContainers = this._document.querySelectorAll(`.${containerClass}[platform=\"server\"], ` +\n                    `.${containerClass}[platform=\"test\"]`);\n                // Remove any old containers from the opposite platform.\n                // This can happen when transitioning from the server to the client.\n                for (let i = 0; i < oppositePlatformContainers.length; i++) {\n                    oppositePlatformContainers[i].parentNode.removeChild(oppositePlatformContainers[i]);\n                }\n            }\n            const container = this._document.createElement('div');\n            container.classList.add(containerClass);\n            // A long time ago we kept adding new overlay containers whenever a new app was instantiated,\n            // but at some point we added logic which clears the duplicate ones in order to avoid leaks.\n            // The new logic was a little too aggressive since it was breaking some legitimate use cases.\n            // To mitigate the problem we made it so that only containers from a different platform are\n            // cleared, but the side-effect was that people started depending on the overly-aggressive\n            // logic to clean up their tests for them. Until we can introduce an overlay-specific testing\n            // module which does the cleanup, we try to detect that we're in a test environment and we\n            // always clear the container. See #17006.\n            // TODO(crisbeto): remove the test environment check once we have an overlay testing module.\n            if (isTestEnvironment) {\n                container.setAttribute('platform', 'test');\n            }\n            else if (!isBrowser) {\n                container.setAttribute('platform', 'server');\n            }\n            this._document.body.appendChild(container);\n            this._containerElement = container;\n        }\n    }\n    OverlayContainer.ɵfac = function OverlayContainer_Factory(t) { return new (t || OverlayContainer)(core[\"Zb\" /* ɵɵinject */](common[\"e\" /* DOCUMENT */]), core[\"Zb\" /* ɵɵinject */](fesm2015_platform[\"a\" /* Platform */])); };\n    OverlayContainer.ɵprov = /*@__PURE__*/ Object(core[\"Lb\" /* ɵɵdefineInjectable */])({ factory: function OverlayContainer_Factory() { return new OverlayContainer(Object(core[\"Zb\" /* ɵɵinject */])(common[\"e\" /* DOCUMENT */]), Object(core[\"Zb\" /* ɵɵinject */])(fesm2015_platform[\"a\" /* Platform */])); }, token: OverlayContainer, providedIn: \"root\" });\n    return OverlayContainer;\n})();\n/** @docs-private @deprecated @breaking-change 8.0.0 */\nfunction OVERLAY_CONTAINER_PROVIDER_FACTORY(parentContainer, _document) {\n    return parentContainer || new overlay_OverlayContainer(_document);\n}\n/** @docs-private @deprecated @breaking-change 8.0.0 */\nconst OVERLAY_CONTAINER_PROVIDER = {\n    // If there is already an OverlayContainer available, use that. Otherwise, provide a new one.\n    provide: overlay_OverlayContainer,\n    deps: [\n        [/*@__PURE__*/ new core[\"C\" /* Optional */](), /*@__PURE__*/ new core[\"L\" /* SkipSelf */](), overlay_OverlayContainer],\n        common[\"e\" /* DOCUMENT */] // We need to use the InjectionToken somewhere to keep TS happy\n    ],\n    useFactory: OVERLAY_CONTAINER_PROVIDER_FACTORY\n};\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Reference to an overlay that has been created with the Overlay service.\n * Used to manipulate or dispose of said overlay.\n */\nclass overlay_OverlayRef {\n    constructor(_portalOutlet, _host, _pane, _config, _ngZone, _keyboardDispatcher, _document, \n    // @breaking-change 8.0.0 `_location` parameter to be made required.\n    _location) {\n        this._portalOutlet = _portalOutlet;\n        this._host = _host;\n        this._pane = _pane;\n        this._config = _config;\n        this._ngZone = _ngZone;\n        this._keyboardDispatcher = _keyboardDispatcher;\n        this._document = _document;\n        this._location = _location;\n        this._backdropElement = null;\n        this._backdropClick = new Subject[\"a\" /* Subject */]();\n        this._attachments = new Subject[\"a\" /* Subject */]();\n        this._detachments = new Subject[\"a\" /* Subject */]();\n        this._locationChanges = Subscription[\"a\" /* Subscription */].EMPTY;\n        this._backdropClickHandler = (event) => this._backdropClick.next(event);\n        /** Stream of keydown events dispatched to this overlay. */\n        this._keydownEvents = new Subject[\"a\" /* Subject */]();\n        if (_config.scrollStrategy) {\n            this._scrollStrategy = _config.scrollStrategy;\n            this._scrollStrategy.attach(this);\n        }\n        this._positionStrategy = _config.positionStrategy;\n    }\n    /** The overlay's HTML element */\n    get overlayElement() {\n        return this._pane;\n    }\n    /** The overlay's backdrop HTML element. */\n    get backdropElement() {\n        return this._backdropElement;\n    }\n    /**\n     * Wrapper around the panel element. Can be used for advanced\n     * positioning where a wrapper with specific styling is\n     * required around the overlay pane.\n     */\n    get hostElement() {\n        return this._host;\n    }\n    /**\n     * Attaches content, given via a Portal, to the overlay.\n     * If the overlay is configured to have a backdrop, it will be created.\n     *\n     * @param portal Portal instance to which to attach the overlay.\n     * @returns The portal attachment result.\n     */\n    attach(portal) {\n        let attachResult = this._portalOutlet.attach(portal);\n        // Update the pane element with the given configuration.\n        if (!this._host.parentElement && this._previousHostParent) {\n            this._previousHostParent.appendChild(this._host);\n        }\n        if (this._positionStrategy) {\n            this._positionStrategy.attach(this);\n        }\n        this._updateStackingOrder();\n        this._updateElementSize();\n        this._updateElementDirection();\n        if (this._scrollStrategy) {\n            this._scrollStrategy.enable();\n        }\n        // Update the position once the zone is stable so that the overlay will be fully rendered\n        // before attempting to position it, as the position may depend on the size of the rendered\n        // content.\n        this._ngZone.onStable\n            .asObservable()\n            .pipe(Object(take[\"a\" /* take */])(1))\n            .subscribe(() => {\n            // The overlay could've been detached before the zone has stabilized.\n            if (this.hasAttached()) {\n                this.updatePosition();\n            }\n        });\n        // Enable pointer events for the overlay pane element.\n        this._togglePointerEvents(true);\n        if (this._config.hasBackdrop) {\n            this._attachBackdrop();\n        }\n        if (this._config.panelClass) {\n            this._toggleClasses(this._pane, this._config.panelClass, true);\n        }\n        // Only emit the `attachments` event once all other setup is done.\n        this._attachments.next();\n        // Track this overlay by the keyboard dispatcher\n        this._keyboardDispatcher.add(this);\n        // @breaking-change 8.0.0 remove the null check for `_location`\n        // once the constructor parameter is made required.\n        if (this._config.disposeOnNavigation && this._location) {\n            this._locationChanges = this._location.subscribe(() => this.dispose());\n        }\n        return attachResult;\n    }\n    /**\n     * Detaches an overlay from a portal.\n     * @returns The portal detachment result.\n     */\n    detach() {\n        if (!this.hasAttached()) {\n            return;\n        }\n        this.detachBackdrop();\n        // When the overlay is detached, the pane element should disable pointer events.\n        // This is necessary because otherwise the pane element will cover the page and disable\n        // pointer events therefore. Depends on the position strategy and the applied pane boundaries.\n        this._togglePointerEvents(false);\n        if (this._positionStrategy && this._positionStrategy.detach) {\n            this._positionStrategy.detach();\n        }\n        if (this._scrollStrategy) {\n            this._scrollStrategy.disable();\n        }\n        const detachmentResult = this._portalOutlet.detach();\n        // Only emit after everything is detached.\n        this._detachments.next();\n        // Remove this overlay from keyboard dispatcher tracking.\n        this._keyboardDispatcher.remove(this);\n        // Keeping the host element in the DOM can cause scroll jank, because it still gets\n        // rendered, even though it's transparent and unclickable which is why we remove it.\n        this._detachContentWhenStable();\n        // Stop listening for location changes.\n        this._locationChanges.unsubscribe();\n        return detachmentResult;\n    }\n    /** Cleans up the overlay from the DOM. */\n    dispose() {\n        const isAttached = this.hasAttached();\n        if (this._positionStrategy) {\n            this._positionStrategy.dispose();\n        }\n        this._disposeScrollStrategy();\n        this.detachBackdrop();\n        this._locationChanges.unsubscribe();\n        this._keyboardDispatcher.remove(this);\n        this._portalOutlet.dispose();\n        this._attachments.complete();\n        this._backdropClick.complete();\n        this._keydownEvents.complete();\n        if (this._host && this._host.parentNode) {\n            this._host.parentNode.removeChild(this._host);\n            this._host = null;\n        }\n        this._previousHostParent = this._pane = null;\n        if (isAttached) {\n            this._detachments.next();\n        }\n        this._detachments.complete();\n    }\n    /** Whether the overlay has attached content. */\n    hasAttached() {\n        return this._portalOutlet.hasAttached();\n    }\n    /** Gets an observable that emits when the backdrop has been clicked. */\n    backdropClick() {\n        return this._backdropClick.asObservable();\n    }\n    /** Gets an observable that emits when the overlay has been attached. */\n    attachments() {\n        return this._attachments.asObservable();\n    }\n    /** Gets an observable that emits when the overlay has been detached. */\n    detachments() {\n        return this._detachments.asObservable();\n    }\n    /** Gets an observable of keydown events targeted to this overlay. */\n    keydownEvents() {\n        return this._keydownEvents.asObservable();\n    }\n    /** Gets the current overlay configuration, which is immutable. */\n    getConfig() {\n        return this._config;\n    }\n    /** Updates the position of the overlay based on the position strategy. */\n    updatePosition() {\n        if (this._positionStrategy) {\n            this._positionStrategy.apply();\n        }\n    }\n    /** Switches to a new position strategy and updates the overlay position. */\n    updatePositionStrategy(strategy) {\n        if (strategy === this._positionStrategy) {\n            return;\n        }\n        if (this._positionStrategy) {\n            this._positionStrategy.dispose();\n        }\n        this._positionStrategy = strategy;\n        if (this.hasAttached()) {\n            strategy.attach(this);\n            this.updatePosition();\n        }\n    }\n    /** Update the size properties of the overlay. */\n    updateSize(sizeConfig) {\n        this._config = Object.assign(Object.assign({}, this._config), sizeConfig);\n        this._updateElementSize();\n    }\n    /** Sets the LTR/RTL direction for the overlay. */\n    setDirection(dir) {\n        this._config = Object.assign(Object.assign({}, this._config), { direction: dir });\n        this._updateElementDirection();\n    }\n    /** Add a CSS class or an array of classes to the overlay pane. */\n    addPanelClass(classes) {\n        if (this._pane) {\n            this._toggleClasses(this._pane, classes, true);\n        }\n    }\n    /** Remove a CSS class or an array of classes from the overlay pane. */\n    removePanelClass(classes) {\n        if (this._pane) {\n            this._toggleClasses(this._pane, classes, false);\n        }\n    }\n    /**\n     * Returns the layout direction of the overlay panel.\n     */\n    getDirection() {\n        const direction = this._config.direction;\n        if (!direction) {\n            return 'ltr';\n        }\n        return typeof direction === 'string' ? direction : direction.value;\n    }\n    /** Switches to a new scroll strategy. */\n    updateScrollStrategy(strategy) {\n        if (strategy === this._scrollStrategy) {\n            return;\n        }\n        this._disposeScrollStrategy();\n        this._scrollStrategy = strategy;\n        if (this.hasAttached()) {\n            strategy.attach(this);\n            strategy.enable();\n        }\n    }\n    /** Updates the text direction of the overlay panel. */\n    _updateElementDirection() {\n        this._host.setAttribute('dir', this.getDirection());\n    }\n    /** Updates the size of the overlay element based on the overlay config. */\n    _updateElementSize() {\n        if (!this._pane) {\n            return;\n        }\n        const style = this._pane.style;\n        style.width = coerceCssPixelValue(this._config.width);\n        style.height = coerceCssPixelValue(this._config.height);\n        style.minWidth = coerceCssPixelValue(this._config.minWidth);\n        style.minHeight = coerceCssPixelValue(this._config.minHeight);\n        style.maxWidth = coerceCssPixelValue(this._config.maxWidth);\n        style.maxHeight = coerceCssPixelValue(this._config.maxHeight);\n    }\n    /** Toggles the pointer events for the overlay pane element. */\n    _togglePointerEvents(enablePointer) {\n        this._pane.style.pointerEvents = enablePointer ? 'auto' : 'none';\n    }\n    /** Attaches a backdrop for this overlay. */\n    _attachBackdrop() {\n        const showingClass = 'cdk-overlay-backdrop-showing';\n        this._backdropElement = this._document.createElement('div');\n        this._backdropElement.classList.add('cdk-overlay-backdrop');\n        if (this._config.backdropClass) {\n            this._toggleClasses(this._backdropElement, this._config.backdropClass, true);\n        }\n        // Insert the backdrop before the pane in the DOM order,\n        // in order to handle stacked overlays properly.\n        this._host.parentElement.insertBefore(this._backdropElement, this._host);\n        // Forward backdrop clicks such that the consumer of the overlay can perform whatever\n        // action desired when such a click occurs (usually closing the overlay).\n        this._backdropElement.addEventListener('click', this._backdropClickHandler);\n        // Add class to fade-in the backdrop after one frame.\n        if (typeof requestAnimationFrame !== 'undefined') {\n            this._ngZone.runOutsideAngular(() => {\n                requestAnimationFrame(() => {\n                    if (this._backdropElement) {\n                        this._backdropElement.classList.add(showingClass);\n                    }\n                });\n            });\n        }\n        else {\n            this._backdropElement.classList.add(showingClass);\n        }\n    }\n    /**\n     * Updates the stacking order of the element, moving it to the top if necessary.\n     * This is required in cases where one overlay was detached, while another one,\n     * that should be behind it, was destroyed. The next time both of them are opened,\n     * the stacking will be wrong, because the detached element's pane will still be\n     * in its original DOM position.\n     */\n    _updateStackingOrder() {\n        if (this._host.nextSibling) {\n            this._host.parentNode.appendChild(this._host);\n        }\n    }\n    /** Detaches the backdrop (if any) associated with the overlay. */\n    detachBackdrop() {\n        let backdropToDetach = this._backdropElement;\n        if (!backdropToDetach) {\n            return;\n        }\n        let timeoutId;\n        let finishDetach = () => {\n            // It may not be attached to anything in certain cases (e.g. unit tests).\n            if (backdropToDetach) {\n                backdropToDetach.removeEventListener('click', this._backdropClickHandler);\n                backdropToDetach.removeEventListener('transitionend', finishDetach);\n                if (backdropToDetach.parentNode) {\n                    backdropToDetach.parentNode.removeChild(backdropToDetach);\n                }\n            }\n            // It is possible that a new portal has been attached to this overlay since we started\n            // removing the backdrop. If that is the case, only clear the backdrop reference if it\n            // is still the same instance that we started to remove.\n            if (this._backdropElement == backdropToDetach) {\n                this._backdropElement = null;\n            }\n            if (this._config.backdropClass) {\n                this._toggleClasses(backdropToDetach, this._config.backdropClass, false);\n            }\n            clearTimeout(timeoutId);\n        };\n        backdropToDetach.classList.remove('cdk-overlay-backdrop-showing');\n        this._ngZone.runOutsideAngular(() => {\n            backdropToDetach.addEventListener('transitionend', finishDetach);\n        });\n        // If the backdrop doesn't have a transition, the `transitionend` event won't fire.\n        // In this case we make it unclickable and we try to remove it after a delay.\n        backdropToDetach.style.pointerEvents = 'none';\n        // Run this outside the Angular zone because there's nothing that Angular cares about.\n        // If it were to run inside the Angular zone, every test that used Overlay would have to be\n        // either async or fakeAsync.\n        timeoutId = this._ngZone.runOutsideAngular(() => setTimeout(finishDetach, 500));\n    }\n    /** Toggles a single CSS class or an array of classes on an element. */\n    _toggleClasses(element, cssClasses, isAdd) {\n        const classList = element.classList;\n        coerceArray(cssClasses).forEach(cssClass => {\n            // We can't do a spread here, because IE doesn't support setting multiple classes.\n            // Also trying to add an empty string to a DOMTokenList will throw.\n            if (cssClass) {\n                isAdd ? classList.add(cssClass) : classList.remove(cssClass);\n            }\n        });\n    }\n    /** Detaches the overlay content next time the zone stabilizes. */\n    _detachContentWhenStable() {\n        // Normally we wouldn't have to explicitly run this outside the `NgZone`, however\n        // if the consumer is using `zone-patch-rxjs`, the `Subscription.unsubscribe` call will\n        // be patched to run inside the zone, which will throw us into an infinite loop.\n        this._ngZone.runOutsideAngular(() => {\n            // We can't remove the host here immediately, because the overlay pane's content\n            // might still be animating. This stream helps us avoid interrupting the animation\n            // by waiting for the pane to become empty.\n            const subscription = this._ngZone.onStable\n                .asObservable()\n                .pipe(takeUntil(Object(merge[\"a\" /* merge */])(this._attachments, this._detachments)))\n                .subscribe(() => {\n                // Needs a couple of checks for the pane and host, because\n                // they may have been removed by the time the zone stabilizes.\n                if (!this._pane || !this._host || this._pane.children.length === 0) {\n                    if (this._pane && this._config.panelClass) {\n                        this._toggleClasses(this._pane, this._config.panelClass, false);\n                    }\n                    if (this._host && this._host.parentElement) {\n                        this._previousHostParent = this._host.parentElement;\n                        this._previousHostParent.removeChild(this._host);\n                    }\n                    subscription.unsubscribe();\n                }\n            });\n        });\n    }\n    /** Disposes of a scroll strategy. */\n    _disposeScrollStrategy() {\n        const scrollStrategy = this._scrollStrategy;\n        if (scrollStrategy) {\n            scrollStrategy.disable();\n            if (scrollStrategy.detach) {\n                scrollStrategy.detach();\n            }\n        }\n    }\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n// TODO: refactor clipping detection into a separate thing (part of scrolling module)\n// TODO: doesn't handle both flexible width and height when it has to scroll along both axis.\n/** Class to be added to the overlay bounding box. */\nconst boundingBoxClass = 'cdk-overlay-connected-position-bounding-box';\n/** Regex used to split a string on its CSS units. */\nconst cssUnitPattern = /([A-Za-z%]+)$/;\n/**\n * A strategy for positioning overlays. Using this strategy, an overlay is given an\n * implicit position relative some origin element. The relative position is defined in terms of\n * a point on the origin element that is connected to a point on the overlay element. For example,\n * a basic dropdown is connecting the bottom-left corner of the origin to the top-left corner\n * of the overlay.\n */\nclass overlay_FlexibleConnectedPositionStrategy {\n    constructor(connectedTo, _viewportRuler, _document, _platform, _overlayContainer) {\n        this._viewportRuler = _viewportRuler;\n        this._document = _document;\n        this._platform = _platform;\n        this._overlayContainer = _overlayContainer;\n        /** Last size used for the bounding box. Used to avoid resizing the overlay after open. */\n        this._lastBoundingBoxSize = { width: 0, height: 0 };\n        /** Whether the overlay was pushed in a previous positioning. */\n        this._isPushed = false;\n        /** Whether the overlay can be pushed on-screen on the initial open. */\n        this._canPush = true;\n        /** Whether the overlay can grow via flexible width/height after the initial open. */\n        this._growAfterOpen = false;\n        /** Whether the overlay's width and height can be constrained to fit within the viewport. */\n        this._hasFlexibleDimensions = true;\n        /** Whether the overlay position is locked. */\n        this._positionLocked = false;\n        /** Amount of space that must be maintained between the overlay and the edge of the viewport. */\n        this._viewportMargin = 0;\n        /** The Scrollable containers used to check scrollable view properties on position change. */\n        this._scrollables = [];\n        /** Ordered list of preferred positions, from most to least desirable. */\n        this._preferredPositions = [];\n        /** Subject that emits whenever the position changes. */\n        this._positionChanges = new Subject[\"a\" /* Subject */]();\n        /** Subscription to viewport size changes. */\n        this._resizeSubscription = Subscription[\"a\" /* Subscription */].EMPTY;\n        /** Default offset for the overlay along the x axis. */\n        this._offsetX = 0;\n        /** Default offset for the overlay along the y axis. */\n        this._offsetY = 0;\n        /** Keeps track of the CSS classes that the position strategy has applied on the overlay panel. */\n        this._appliedPanelClasses = [];\n        /** Observable sequence of position changes. */\n        this.positionChanges = this._positionChanges.asObservable();\n        this.setOrigin(connectedTo);\n    }\n    /** Ordered list of preferred positions, from most to least desirable. */\n    get positions() {\n        return this._preferredPositions;\n    }\n    /** Attaches this position strategy to an overlay. */\n    attach(overlayRef) {\n        if (this._overlayRef && overlayRef !== this._overlayRef) {\n            throw Error('This position strategy is already attached to an overlay');\n        }\n        this._validatePositions();\n        overlayRef.hostElement.classList.add(boundingBoxClass);\n        this._overlayRef = overlayRef;\n        this._boundingBox = overlayRef.hostElement;\n        this._pane = overlayRef.overlayElement;\n        this._isDisposed = false;\n        this._isInitialRender = true;\n        this._lastPosition = null;\n        this._resizeSubscription.unsubscribe();\n        this._resizeSubscription = this._viewportRuler.change().subscribe(() => {\n            // When the window is resized, we want to trigger the next reposition as if it\n            // was an initial render, in order for the strategy to pick a new optimal position,\n            // otherwise position locking will cause it to stay at the old one.\n            this._isInitialRender = true;\n            this.apply();\n        });\n    }\n    /**\n     * Updates the position of the overlay element, using whichever preferred position relative\n     * to the origin best fits on-screen.\n     *\n     * The selection of a position goes as follows:\n     *  - If any positions fit completely within the viewport as-is,\n     *      choose the first position that does so.\n     *  - If flexible dimensions are enabled and at least one satifies the given minimum width/height,\n     *      choose the position with the greatest available size modified by the positions' weight.\n     *  - If pushing is enabled, take the position that went off-screen the least and push it\n     *      on-screen.\n     *  - If none of the previous criteria were met, use the position that goes off-screen the least.\n     * @docs-private\n     */\n    apply() {\n        // We shouldn't do anything if the strategy was disposed or we're on the server.\n        if (this._isDisposed || !this._platform.isBrowser) {\n            return;\n        }\n        // If the position has been applied already (e.g. when the overlay was opened) and the\n        // consumer opted into locking in the position, re-use the old position, in order to\n        // prevent the overlay from jumping around.\n        if (!this._isInitialRender && this._positionLocked && this._lastPosition) {\n            this.reapplyLastPosition();\n            return;\n        }\n        this._clearPanelClasses();\n        this._resetOverlayElementStyles();\n        this._resetBoundingBoxStyles();\n        // We need the bounding rects for the origin and the overlay to determine how to position\n        // the overlay relative to the origin.\n        // We use the viewport rect to determine whether a position would go off-screen.\n        this._viewportRect = this._getNarrowedViewportRect();\n        this._originRect = this._getOriginRect();\n        this._overlayRect = this._pane.getBoundingClientRect();\n        const originRect = this._originRect;\n        const overlayRect = this._overlayRect;\n        const viewportRect = this._viewportRect;\n        // Positions where the overlay will fit with flexible dimensions.\n        const flexibleFits = [];\n        // Fallback if none of the preferred positions fit within the viewport.\n        let fallback;\n        // Go through each of the preferred positions looking for a good fit.\n        // If a good fit is found, it will be applied immediately.\n        for (let pos of this._preferredPositions) {\n            // Get the exact (x, y) coordinate for the point-of-origin on the origin element.\n            let originPoint = this._getOriginPoint(originRect, pos);\n            // From that point-of-origin, get the exact (x, y) coordinate for the top-left corner of the\n            // overlay in this position. We use the top-left corner for calculations and later translate\n            // this into an appropriate (top, left, bottom, right) style.\n            let overlayPoint = this._getOverlayPoint(originPoint, overlayRect, pos);\n            // Calculate how well the overlay would fit into the viewport with this point.\n            let overlayFit = this._getOverlayFit(overlayPoint, overlayRect, viewportRect, pos);\n            // If the overlay, without any further work, fits into the viewport, use this position.\n            if (overlayFit.isCompletelyWithinViewport) {\n                this._isPushed = false;\n                this._applyPosition(pos, originPoint);\n                return;\n            }\n            // If the overlay has flexible dimensions, we can use this position\n            // so long as there's enough space for the minimum dimensions.\n            if (this._canFitWithFlexibleDimensions(overlayFit, overlayPoint, viewportRect)) {\n                // Save positions where the overlay will fit with flexible dimensions. We will use these\n                // if none of the positions fit *without* flexible dimensions.\n                flexibleFits.push({\n                    position: pos,\n                    origin: originPoint,\n                    overlayRect,\n                    boundingBoxRect: this._calculateBoundingBoxRect(originPoint, pos)\n                });\n                continue;\n            }\n            // If the current preferred position does not fit on the screen, remember the position\n            // if it has more visible area on-screen than we've seen and move onto the next preferred\n            // position.\n            if (!fallback || fallback.overlayFit.visibleArea < overlayFit.visibleArea) {\n                fallback = { overlayFit, overlayPoint, originPoint, position: pos, overlayRect };\n            }\n        }\n        // If there are any positions where the overlay would fit with flexible dimensions, choose the\n        // one that has the greatest area available modified by the position's weight\n        if (flexibleFits.length) {\n            let bestFit = null;\n            let bestScore = -1;\n            for (const fit of flexibleFits) {\n                const score = fit.boundingBoxRect.width * fit.boundingBoxRect.height * (fit.position.weight || 1);\n                if (score > bestScore) {\n                    bestScore = score;\n                    bestFit = fit;\n                }\n            }\n            this._isPushed = false;\n            this._applyPosition(bestFit.position, bestFit.origin);\n            return;\n        }\n        // When none of the preferred positions fit within the viewport, take the position\n        // that went off-screen the least and attempt to push it on-screen.\n        if (this._canPush) {\n            // TODO(jelbourn): after pushing, the opening \"direction\" of the overlay might not make sense.\n            this._isPushed = true;\n            this._applyPosition(fallback.position, fallback.originPoint);\n            return;\n        }\n        // All options for getting the overlay within the viewport have been exhausted, so go with the\n        // position that went off-screen the least.\n        this._applyPosition(fallback.position, fallback.originPoint);\n    }\n    detach() {\n        this._clearPanelClasses();\n        this._lastPosition = null;\n        this._previousPushAmount = null;\n        this._resizeSubscription.unsubscribe();\n    }\n    /** Cleanup after the element gets destroyed. */\n    dispose() {\n        if (this._isDisposed) {\n            return;\n        }\n        // We can't use `_resetBoundingBoxStyles` here, because it resets\n        // some properties to zero, rather than removing them.\n        if (this._boundingBox) {\n            extendStyles(this._boundingBox.style, {\n                top: '',\n                left: '',\n                right: '',\n                bottom: '',\n                height: '',\n                width: '',\n                alignItems: '',\n                justifyContent: '',\n            });\n        }\n        if (this._pane) {\n            this._resetOverlayElementStyles();\n        }\n        if (this._overlayRef) {\n            this._overlayRef.hostElement.classList.remove(boundingBoxClass);\n        }\n        this.detach();\n        this._positionChanges.complete();\n        this._overlayRef = this._boundingBox = null;\n        this._isDisposed = true;\n    }\n    /**\n     * This re-aligns the overlay element with the trigger in its last calculated position,\n     * even if a position higher in the \"preferred positions\" list would now fit. This\n     * allows one to re-align the panel without changing the orientation of the panel.\n     */\n    reapplyLastPosition() {\n        if (!this._isDisposed && (!this._platform || this._platform.isBrowser)) {\n            this._originRect = this._getOriginRect();\n            this._overlayRect = this._pane.getBoundingClientRect();\n            this._viewportRect = this._getNarrowedViewportRect();\n            const lastPosition = this._lastPosition || this._preferredPositions[0];\n            const originPoint = this._getOriginPoint(this._originRect, lastPosition);\n            this._applyPosition(lastPosition, originPoint);\n        }\n    }\n    /**\n     * Sets the list of Scrollable containers that host the origin element so that\n     * on reposition we can evaluate if it or the overlay has been clipped or outside view. Every\n     * Scrollable must be an ancestor element of the strategy's origin element.\n     */\n    withScrollableContainers(scrollables) {\n        this._scrollables = scrollables;\n        return this;\n    }\n    /**\n     * Adds new preferred positions.\n     * @param positions List of positions options for this overlay.\n     */\n    withPositions(positions) {\n        this._preferredPositions = positions;\n        // If the last calculated position object isn't part of the positions anymore, clear\n        // it in order to avoid it being picked up if the consumer tries to re-apply.\n        if (positions.indexOf(this._lastPosition) === -1) {\n            this._lastPosition = null;\n        }\n        this._validatePositions();\n        return this;\n    }\n    /**\n     * Sets a minimum distance the overlay may be positioned to the edge of the viewport.\n     * @param margin Required margin between the overlay and the viewport edge in pixels.\n     */\n    withViewportMargin(margin) {\n        this._viewportMargin = margin;\n        return this;\n    }\n    /** Sets whether the overlay's width and height can be constrained to fit within the viewport. */\n    withFlexibleDimensions(flexibleDimensions = true) {\n        this._hasFlexibleDimensions = flexibleDimensions;\n        return this;\n    }\n    /** Sets whether the overlay can grow after the initial open via flexible width/height. */\n    withGrowAfterOpen(growAfterOpen = true) {\n        this._growAfterOpen = growAfterOpen;\n        return this;\n    }\n    /** Sets whether the overlay can be pushed on-screen if none of the provided positions fit. */\n    withPush(canPush = true) {\n        this._canPush = canPush;\n        return this;\n    }\n    /**\n     * Sets whether the overlay's position should be locked in after it is positioned\n     * initially. When an overlay is locked in, it won't attempt to reposition itself\n     * when the position is re-applied (e.g. when the user scrolls away).\n     * @param isLocked Whether the overlay should locked in.\n     */\n    withLockedPosition(isLocked = true) {\n        this._positionLocked = isLocked;\n        return this;\n    }\n    /**\n     * Sets the origin, relative to which to position the overlay.\n     * Using an element origin is useful for building components that need to be positioned\n     * relatively to a trigger (e.g. dropdown menus or tooltips), whereas using a point can be\n     * used for cases like contextual menus which open relative to the user's pointer.\n     * @param origin Reference to the new origin.\n     */\n    setOrigin(origin) {\n        this._origin = origin;\n        return this;\n    }\n    /**\n     * Sets the default offset for the overlay's connection point on the x-axis.\n     * @param offset New offset in the X axis.\n     */\n    withDefaultOffsetX(offset) {\n        this._offsetX = offset;\n        return this;\n    }\n    /**\n     * Sets the default offset for the overlay's connection point on the y-axis.\n     * @param offset New offset in the Y axis.\n     */\n    withDefaultOffsetY(offset) {\n        this._offsetY = offset;\n        return this;\n    }\n    /**\n     * Configures that the position strategy should set a `transform-origin` on some elements\n     * inside the overlay, depending on the current position that is being applied. This is\n     * useful for the cases where the origin of an animation can change depending on the\n     * alignment of the overlay.\n     * @param selector CSS selector that will be used to find the target\n     *    elements onto which to set the transform origin.\n     */\n    withTransformOriginOn(selector) {\n        this._transformOriginSelector = selector;\n        return this;\n    }\n    /**\n     * Gets the (x, y) coordinate of a connection point on the origin based on a relative position.\n     */\n    _getOriginPoint(originRect, pos) {\n        let x;\n        if (pos.originX == 'center') {\n            // Note: when centering we should always use the `left`\n            // offset, otherwise the position will be wrong in RTL.\n            x = originRect.left + (originRect.width / 2);\n        }\n        else {\n            const startX = this._isRtl() ? originRect.right : originRect.left;\n            const endX = this._isRtl() ? originRect.left : originRect.right;\n            x = pos.originX == 'start' ? startX : endX;\n        }\n        let y;\n        if (pos.originY == 'center') {\n            y = originRect.top + (originRect.height / 2);\n        }\n        else {\n            y = pos.originY == 'top' ? originRect.top : originRect.bottom;\n        }\n        return { x, y };\n    }\n    /**\n     * Gets the (x, y) coordinate of the top-left corner of the overlay given a given position and\n     * origin point to which the overlay should be connected.\n     */\n    _getOverlayPoint(originPoint, overlayRect, pos) {\n        // Calculate the (overlayStartX, overlayStartY), the start of the\n        // potential overlay position relative to the origin point.\n        let overlayStartX;\n        if (pos.overlayX == 'center') {\n            overlayStartX = -overlayRect.width / 2;\n        }\n        else if (pos.overlayX === 'start') {\n            overlayStartX = this._isRtl() ? -overlayRect.width : 0;\n        }\n        else {\n            overlayStartX = this._isRtl() ? 0 : -overlayRect.width;\n        }\n        let overlayStartY;\n        if (pos.overlayY == 'center') {\n            overlayStartY = -overlayRect.height / 2;\n        }\n        else {\n            overlayStartY = pos.overlayY == 'top' ? 0 : -overlayRect.height;\n        }\n        // The (x, y) coordinates of the overlay.\n        return {\n            x: originPoint.x + overlayStartX,\n            y: originPoint.y + overlayStartY,\n        };\n    }\n    /** Gets how well an overlay at the given point will fit within the viewport. */\n    _getOverlayFit(point, overlay, viewport, position) {\n        let { x, y } = point;\n        let offsetX = this._getOffset(position, 'x');\n        let offsetY = this._getOffset(position, 'y');\n        // Account for the offsets since they could push the overlay out of the viewport.\n        if (offsetX) {\n            x += offsetX;\n        }\n        if (offsetY) {\n            y += offsetY;\n        }\n        // How much the overlay would overflow at this position, on each side.\n        let leftOverflow = 0 - x;\n        let rightOverflow = (x + overlay.width) - viewport.width;\n        let topOverflow = 0 - y;\n        let bottomOverflow = (y + overlay.height) - viewport.height;\n        // Visible parts of the element on each axis.\n        let visibleWidth = this._subtractOverflows(overlay.width, leftOverflow, rightOverflow);\n        let visibleHeight = this._subtractOverflows(overlay.height, topOverflow, bottomOverflow);\n        let visibleArea = visibleWidth * visibleHeight;\n        return {\n            visibleArea,\n            isCompletelyWithinViewport: (overlay.width * overlay.height) === visibleArea,\n            fitsInViewportVertically: visibleHeight === overlay.height,\n            fitsInViewportHorizontally: visibleWidth == overlay.width,\n        };\n    }\n    /**\n     * Whether the overlay can fit within the viewport when it may resize either its width or height.\n     * @param fit How well the overlay fits in the viewport at some position.\n     * @param point The (x, y) coordinates of the overlat at some position.\n     * @param viewport The geometry of the viewport.\n     */\n    _canFitWithFlexibleDimensions(fit, point, viewport) {\n        if (this._hasFlexibleDimensions) {\n            const availableHeight = viewport.bottom - point.y;\n            const availableWidth = viewport.right - point.x;\n            const minHeight = getPixelValue(this._overlayRef.getConfig().minHeight);\n            const minWidth = getPixelValue(this._overlayRef.getConfig().minWidth);\n            const verticalFit = fit.fitsInViewportVertically ||\n                (minHeight != null && minHeight <= availableHeight);\n            const horizontalFit = fit.fitsInViewportHorizontally ||\n                (minWidth != null && minWidth <= availableWidth);\n            return verticalFit && horizontalFit;\n        }\n        return false;\n    }\n    /**\n     * Gets the point at which the overlay can be \"pushed\" on-screen. If the overlay is larger than\n     * the viewport, the top-left corner will be pushed on-screen (with overflow occuring on the\n     * right and bottom).\n     *\n     * @param start Starting point from which the overlay is pushed.\n     * @param overlay Dimensions of the overlay.\n     * @param scrollPosition Current viewport scroll position.\n     * @returns The point at which to position the overlay after pushing. This is effectively a new\n     *     originPoint.\n     */\n    _pushOverlayOnScreen(start, overlay, scrollPosition) {\n        // If the position is locked and we've pushed the overlay already, reuse the previous push\n        // amount, rather than pushing it again. If we were to continue pushing, the element would\n        // remain in the viewport, which goes against the expectations when position locking is enabled.\n        if (this._previousPushAmount && this._positionLocked) {\n            return {\n                x: start.x + this._previousPushAmount.x,\n                y: start.y + this._previousPushAmount.y\n            };\n        }\n        const viewport = this._viewportRect;\n        // Determine how much the overlay goes outside the viewport on each\n        // side, which we'll use to decide which direction to push it.\n        const overflowRight = Math.max(start.x + overlay.width - viewport.right, 0);\n        const overflowBottom = Math.max(start.y + overlay.height - viewport.bottom, 0);\n        const overflowTop = Math.max(viewport.top - scrollPosition.top - start.y, 0);\n        const overflowLeft = Math.max(viewport.left - scrollPosition.left - start.x, 0);\n        // Amount by which to push the overlay in each axis such that it remains on-screen.\n        let pushX = 0;\n        let pushY = 0;\n        // If the overlay fits completely within the bounds of the viewport, push it from whichever\n        // direction is goes off-screen. Otherwise, push the top-left corner such that its in the\n        // viewport and allow for the trailing end of the overlay to go out of bounds.\n        if (overlay.width <= viewport.width) {\n            pushX = overflowLeft || -overflowRight;\n        }\n        else {\n            pushX = start.x < this._viewportMargin ? (viewport.left - scrollPosition.left) - start.x : 0;\n        }\n        if (overlay.height <= viewport.height) {\n            pushY = overflowTop || -overflowBottom;\n        }\n        else {\n            pushY = start.y < this._viewportMargin ? (viewport.top - scrollPosition.top) - start.y : 0;\n        }\n        this._previousPushAmount = { x: pushX, y: pushY };\n        return {\n            x: start.x + pushX,\n            y: start.y + pushY,\n        };\n    }\n    /**\n     * Applies a computed position to the overlay and emits a position change.\n     * @param position The position preference\n     * @param originPoint The point on the origin element where the overlay is connected.\n     */\n    _applyPosition(position, originPoint) {\n        this._setTransformOrigin(position);\n        this._setOverlayElementStyles(originPoint, position);\n        this._setBoundingBoxStyles(originPoint, position);\n        if (position.panelClass) {\n            this._addPanelClasses(position.panelClass);\n        }\n        // Save the last connected position in case the position needs to be re-calculated.\n        this._lastPosition = position;\n        // Notify that the position has been changed along with its change properties.\n        // We only emit if we've got any subscriptions, because the scroll visibility\n        // calculcations can be somewhat expensive.\n        if (this._positionChanges.observers.length) {\n            const scrollableViewProperties = this._getScrollVisibility();\n            const changeEvent = new ConnectedOverlayPositionChange(position, scrollableViewProperties);\n            this._positionChanges.next(changeEvent);\n        }\n        this._isInitialRender = false;\n    }\n    /** Sets the transform origin based on the configured selector and the passed-in position.  */\n    _setTransformOrigin(position) {\n        if (!this._transformOriginSelector) {\n            return;\n        }\n        const elements = this._boundingBox.querySelectorAll(this._transformOriginSelector);\n        let xOrigin;\n        let yOrigin = position.overlayY;\n        if (position.overlayX === 'center') {\n            xOrigin = 'center';\n        }\n        else if (this._isRtl()) {\n            xOrigin = position.overlayX === 'start' ? 'right' : 'left';\n        }\n        else {\n            xOrigin = position.overlayX === 'start' ? 'left' : 'right';\n        }\n        for (let i = 0; i < elements.length; i++) {\n            elements[i].style.transformOrigin = `${xOrigin} ${yOrigin}`;\n        }\n    }\n    /**\n     * Gets the position and size of the overlay's sizing container.\n     *\n     * This method does no measuring and applies no styles so that we can cheaply compute the\n     * bounds for all positions and choose the best fit based on these results.\n     */\n    _calculateBoundingBoxRect(origin, position) {\n        const viewport = this._viewportRect;\n        const isRtl = this._isRtl();\n        let height, top, bottom;\n        if (position.overlayY === 'top') {\n            // Overlay is opening \"downward\" and thus is bound by the bottom viewport edge.\n            top = origin.y;\n            height = viewport.height - top + this._viewportMargin;\n        }\n        else if (position.overlayY === 'bottom') {\n            // Overlay is opening \"upward\" and thus is bound by the top viewport edge. We need to add\n            // the viewport margin back in, because the viewport rect is narrowed down to remove the\n            // margin, whereas the `origin` position is calculated based on its `ClientRect`.\n            bottom = viewport.height - origin.y + this._viewportMargin * 2;\n            height = viewport.height - bottom + this._viewportMargin;\n        }\n        else {\n            // If neither top nor bottom, it means that the overlay is vertically centered on the\n            // origin point. Note that we want the position relative to the viewport, rather than\n            // the page, which is why we don't use something like `viewport.bottom - origin.y` and\n            // `origin.y - viewport.top`.\n            const smallestDistanceToViewportEdge = Math.min(viewport.bottom - origin.y + viewport.top, origin.y);\n            const previousHeight = this._lastBoundingBoxSize.height;\n            height = smallestDistanceToViewportEdge * 2;\n            top = origin.y - smallestDistanceToViewportEdge;\n            if (height > previousHeight && !this._isInitialRender && !this._growAfterOpen) {\n                top = origin.y - (previousHeight / 2);\n            }\n        }\n        // The overlay is opening 'right-ward' (the content flows to the right).\n        const isBoundedByRightViewportEdge = (position.overlayX === 'start' && !isRtl) ||\n            (position.overlayX === 'end' && isRtl);\n        // The overlay is opening 'left-ward' (the content flows to the left).\n        const isBoundedByLeftViewportEdge = (position.overlayX === 'end' && !isRtl) ||\n            (position.overlayX === 'start' && isRtl);\n        let width, left, right;\n        if (isBoundedByLeftViewportEdge) {\n            right = viewport.width - origin.x + this._viewportMargin;\n            width = origin.x - this._viewportMargin;\n        }\n        else if (isBoundedByRightViewportEdge) {\n            left = origin.x;\n            width = viewport.right - origin.x;\n        }\n        else {\n            // If neither start nor end, it means that the overlay is horizontally centered on the\n            // origin point. Note that we want the position relative to the viewport, rather than\n            // the page, which is why we don't use something like `viewport.right - origin.x` and\n            // `origin.x - viewport.left`.\n            const smallestDistanceToViewportEdge = Math.min(viewport.right - origin.x + viewport.left, origin.x);\n            const previousWidth = this._lastBoundingBoxSize.width;\n            width = smallestDistanceToViewportEdge * 2;\n            left = origin.x - smallestDistanceToViewportEdge;\n            if (width > previousWidth && !this._isInitialRender && !this._growAfterOpen) {\n                left = origin.x - (previousWidth / 2);\n            }\n        }\n        return { top: top, left: left, bottom: bottom, right: right, width, height };\n    }\n    /**\n     * Sets the position and size of the overlay's sizing wrapper. The wrapper is positioned on the\n     * origin's connection point and stetches to the bounds of the viewport.\n     *\n     * @param origin The point on the origin element where the overlay is connected.\n     * @param position The position preference\n     */\n    _setBoundingBoxStyles(origin, position) {\n        const boundingBoxRect = this._calculateBoundingBoxRect(origin, position);\n        // It's weird if the overlay *grows* while scrolling, so we take the last size into account\n        // when applying a new size.\n        if (!this._isInitialRender && !this._growAfterOpen) {\n            boundingBoxRect.height = Math.min(boundingBoxRect.height, this._lastBoundingBoxSize.height);\n            boundingBoxRect.width = Math.min(boundingBoxRect.width, this._lastBoundingBoxSize.width);\n        }\n        const styles = {};\n        if (this._hasExactPosition()) {\n            styles.top = styles.left = '0';\n            styles.bottom = styles.right = styles.maxHeight = styles.maxWidth = '';\n            styles.width = styles.height = '100%';\n        }\n        else {\n            const maxHeight = this._overlayRef.getConfig().maxHeight;\n            const maxWidth = this._overlayRef.getConfig().maxWidth;\n            styles.height = coerceCssPixelValue(boundingBoxRect.height);\n            styles.top = coerceCssPixelValue(boundingBoxRect.top);\n            styles.bottom = coerceCssPixelValue(boundingBoxRect.bottom);\n            styles.width = coerceCssPixelValue(boundingBoxRect.width);\n            styles.left = coerceCssPixelValue(boundingBoxRect.left);\n            styles.right = coerceCssPixelValue(boundingBoxRect.right);\n            // Push the pane content towards the proper direction.\n            if (position.overlayX === 'center') {\n                styles.alignItems = 'center';\n            }\n            else {\n                styles.alignItems = position.overlayX === 'end' ? 'flex-end' : 'flex-start';\n            }\n            if (position.overlayY === 'center') {\n                styles.justifyContent = 'center';\n            }\n            else {\n                styles.justifyContent = position.overlayY === 'bottom' ? 'flex-end' : 'flex-start';\n            }\n            if (maxHeight) {\n                styles.maxHeight = coerceCssPixelValue(maxHeight);\n            }\n            if (maxWidth) {\n                styles.maxWidth = coerceCssPixelValue(maxWidth);\n            }\n        }\n        this._lastBoundingBoxSize = boundingBoxRect;\n        extendStyles(this._boundingBox.style, styles);\n    }\n    /** Resets the styles for the bounding box so that a new positioning can be computed. */\n    _resetBoundingBoxStyles() {\n        extendStyles(this._boundingBox.style, {\n            top: '0',\n            left: '0',\n            right: '0',\n            bottom: '0',\n            height: '',\n            width: '',\n            alignItems: '',\n            justifyContent: '',\n        });\n    }\n    /** Resets the styles for the overlay pane so that a new positioning can be computed. */\n    _resetOverlayElementStyles() {\n        extendStyles(this._pane.style, {\n            top: '',\n            left: '',\n            bottom: '',\n            right: '',\n            position: '',\n            transform: '',\n        });\n    }\n    /** Sets positioning styles to the overlay element. */\n    _setOverlayElementStyles(originPoint, position) {\n        const styles = {};\n        const hasExactPosition = this._hasExactPosition();\n        const hasFlexibleDimensions = this._hasFlexibleDimensions;\n        const config = this._overlayRef.getConfig();\n        if (hasExactPosition) {\n            const scrollPosition = this._viewportRuler.getViewportScrollPosition();\n            extendStyles(styles, this._getExactOverlayY(position, originPoint, scrollPosition));\n            extendStyles(styles, this._getExactOverlayX(position, originPoint, scrollPosition));\n        }\n        else {\n            styles.position = 'static';\n        }\n        // Use a transform to apply the offsets. We do this because the `center` positions rely on\n        // being in the normal flex flow and setting a `top` / `left` at all will completely throw\n        // off the position. We also can't use margins, because they won't have an effect in some\n        // cases where the element doesn't have anything to \"push off of\". Finally, this works\n        // better both with flexible and non-flexible positioning.\n        let transformString = '';\n        let offsetX = this._getOffset(position, 'x');\n        let offsetY = this._getOffset(position, 'y');\n        if (offsetX) {\n            transformString += `translateX(${offsetX}px) `;\n        }\n        if (offsetY) {\n            transformString += `translateY(${offsetY}px)`;\n        }\n        styles.transform = transformString.trim();\n        // If a maxWidth or maxHeight is specified on the overlay, we remove them. We do this because\n        // we need these values to both be set to \"100%\" for the automatic flexible sizing to work.\n        // The maxHeight and maxWidth are set on the boundingBox in order to enforce the constraint.\n        // Note that this doesn't apply when we have an exact position, in which case we do want to\n        // apply them because they'll be cleared from the bounding box.\n        if (config.maxHeight) {\n            if (hasExactPosition) {\n                styles.maxHeight = coerceCssPixelValue(config.maxHeight);\n            }\n            else if (hasFlexibleDimensions) {\n                styles.maxHeight = '';\n            }\n        }\n        if (config.maxWidth) {\n            if (hasExactPosition) {\n                styles.maxWidth = coerceCssPixelValue(config.maxWidth);\n            }\n            else if (hasFlexibleDimensions) {\n                styles.maxWidth = '';\n            }\n        }\n        extendStyles(this._pane.style, styles);\n    }\n    /** Gets the exact top/bottom for the overlay when not using flexible sizing or when pushing. */\n    _getExactOverlayY(position, originPoint, scrollPosition) {\n        // Reset any existing styles. This is necessary in case the\n        // preferred position has changed since the last `apply`.\n        let styles = { top: '', bottom: '' };\n        let overlayPoint = this._getOverlayPoint(originPoint, this._overlayRect, position);\n        if (this._isPushed) {\n            overlayPoint = this._pushOverlayOnScreen(overlayPoint, this._overlayRect, scrollPosition);\n        }\n        let virtualKeyboardOffset = this._overlayContainer.getContainerElement().getBoundingClientRect().top;\n        // Normally this would be zero, however when the overlay is attached to an input (e.g. in an\n        // autocomplete), mobile browsers will shift everything in order to put the input in the middle\n        // of the screen and to make space for the virtual keyboard. We need to account for this offset,\n        // otherwise our positioning will be thrown off.\n        overlayPoint.y -= virtualKeyboardOffset;\n        // We want to set either `top` or `bottom` based on whether the overlay wants to appear\n        // above or below the origin and the direction in which the element will expand.\n        if (position.overlayY === 'bottom') {\n            // When using `bottom`, we adjust the y position such that it is the distance\n            // from the bottom of the viewport rather than the top.\n            const documentHeight = this._document.documentElement.clientHeight;\n            styles.bottom = `${documentHeight - (overlayPoint.y + this._overlayRect.height)}px`;\n        }\n        else {\n            styles.top = coerceCssPixelValue(overlayPoint.y);\n        }\n        return styles;\n    }\n    /** Gets the exact left/right for the overlay when not using flexible sizing or when pushing. */\n    _getExactOverlayX(position, originPoint, scrollPosition) {\n        // Reset any existing styles. This is necessary in case the preferred position has\n        // changed since the last `apply`.\n        let styles = { left: '', right: '' };\n        let overlayPoint = this._getOverlayPoint(originPoint, this._overlayRect, position);\n        if (this._isPushed) {\n            overlayPoint = this._pushOverlayOnScreen(overlayPoint, this._overlayRect, scrollPosition);\n        }\n        // We want to set either `left` or `right` based on whether the overlay wants to appear \"before\"\n        // or \"after\" the origin, which determines the direction in which the element will expand.\n        // For the horizontal axis, the meaning of \"before\" and \"after\" change based on whether the\n        // page is in RTL or LTR.\n        let horizontalStyleProperty;\n        if (this._isRtl()) {\n            horizontalStyleProperty = position.overlayX === 'end' ? 'left' : 'right';\n        }\n        else {\n            horizontalStyleProperty = position.overlayX === 'end' ? 'right' : 'left';\n        }\n        // When we're setting `right`, we adjust the x position such that it is the distance\n        // from the right edge of the viewport rather than the left edge.\n        if (horizontalStyleProperty === 'right') {\n            const documentWidth = this._document.documentElement.clientWidth;\n            styles.right = `${documentWidth - (overlayPoint.x + this._overlayRect.width)}px`;\n        }\n        else {\n            styles.left = coerceCssPixelValue(overlayPoint.x);\n        }\n        return styles;\n    }\n    /**\n     * Gets the view properties of the trigger and overlay, including whether they are clipped\n     * or completely outside the view of any of the strategy's scrollables.\n     */\n    _getScrollVisibility() {\n        // Note: needs fresh rects since the position could've changed.\n        const originBounds = this._getOriginRect();\n        const overlayBounds = this._pane.getBoundingClientRect();\n        // TODO(jelbourn): instead of needing all of the client rects for these scrolling containers\n        // every time, we should be able to use the scrollTop of the containers if the size of those\n        // containers hasn't changed.\n        const scrollContainerBounds = this._scrollables.map(scrollable => {\n            return scrollable.getElementRef().nativeElement.getBoundingClientRect();\n        });\n        return {\n            isOriginClipped: isElementClippedByScrolling(originBounds, scrollContainerBounds),\n            isOriginOutsideView: isElementScrolledOutsideView(originBounds, scrollContainerBounds),\n            isOverlayClipped: isElementClippedByScrolling(overlayBounds, scrollContainerBounds),\n            isOverlayOutsideView: isElementScrolledOutsideView(overlayBounds, scrollContainerBounds),\n        };\n    }\n    /** Subtracts the amount that an element is overflowing on an axis from its length. */\n    _subtractOverflows(length, ...overflows) {\n        return overflows.reduce((currentValue, currentOverflow) => {\n            return currentValue - Math.max(currentOverflow, 0);\n        }, length);\n    }\n    /** Narrows the given viewport rect by the current _viewportMargin. */\n    _getNarrowedViewportRect() {\n        // We recalculate the viewport rect here ourselves, rather than using the ViewportRuler,\n        // because we want to use the `clientWidth` and `clientHeight` as the base. The difference\n        // being that the client properties don't include the scrollbar, as opposed to `innerWidth`\n        // and `innerHeight` that do. This is necessary, because the overlay container uses\n        // 100% `width` and `height` which don't include the scrollbar either.\n        const width = this._document.documentElement.clientWidth;\n        const height = this._document.documentElement.clientHeight;\n        const scrollPosition = this._viewportRuler.getViewportScrollPosition();\n        return {\n            top: scrollPosition.top + this._viewportMargin,\n            left: scrollPosition.left + this._viewportMargin,\n            right: scrollPosition.left + width - this._viewportMargin,\n            bottom: scrollPosition.top + height - this._viewportMargin,\n            width: width - (2 * this._viewportMargin),\n            height: height - (2 * this._viewportMargin),\n        };\n    }\n    /** Whether the we're dealing with an RTL context */\n    _isRtl() {\n        return this._overlayRef.getDirection() === 'rtl';\n    }\n    /** Determines whether the overlay uses exact or flexible positioning. */\n    _hasExactPosition() {\n        return !this._hasFlexibleDimensions || this._isPushed;\n    }\n    /** Retrieves the offset of a position along the x or y axis. */\n    _getOffset(position, axis) {\n        if (axis === 'x') {\n            // We don't do something like `position['offset' + axis]` in\n            // order to avoid breking minifiers that rename properties.\n            return position.offsetX == null ? this._offsetX : position.offsetX;\n        }\n        return position.offsetY == null ? this._offsetY : position.offsetY;\n    }\n    /** Validates that the current position match the expected values. */\n    _validatePositions() {\n        if (!this._preferredPositions.length) {\n            throw Error('FlexibleConnectedPositionStrategy: At least one position is required.');\n        }\n        // TODO(crisbeto): remove these once Angular's template type\n        // checking is advanced enough to catch these cases.\n        this._preferredPositions.forEach(pair => {\n            validateHorizontalPosition('originX', pair.originX);\n            validateVerticalPosition('originY', pair.originY);\n            validateHorizontalPosition('overlayX', pair.overlayX);\n            validateVerticalPosition('overlayY', pair.overlayY);\n        });\n    }\n    /** Adds a single CSS class or an array of classes on the overlay panel. */\n    _addPanelClasses(cssClasses) {\n        if (this._pane) {\n            coerceArray(cssClasses).forEach(cssClass => {\n                if (cssClass !== '' && this._appliedPanelClasses.indexOf(cssClass) === -1) {\n                    this._appliedPanelClasses.push(cssClass);\n                    this._pane.classList.add(cssClass);\n                }\n            });\n        }\n    }\n    /** Clears the classes that the position strategy has applied from the overlay panel. */\n    _clearPanelClasses() {\n        if (this._pane) {\n            this._appliedPanelClasses.forEach(cssClass => {\n                this._pane.classList.remove(cssClass);\n            });\n            this._appliedPanelClasses = [];\n        }\n    }\n    /** Returns the ClientRect of the current origin. */\n    _getOriginRect() {\n        const origin = this._origin;\n        if (origin instanceof core[\"m\" /* ElementRef */]) {\n            return origin.nativeElement.getBoundingClientRect();\n        }\n        // Check for Element so SVG elements are also supported.\n        if (origin instanceof Element) {\n            return origin.getBoundingClientRect();\n        }\n        const width = origin.width || 0;\n        const height = origin.height || 0;\n        // If the origin is a point, return a client rect as if it was a 0x0 element at the point.\n        return {\n            top: origin.y,\n            bottom: origin.y + height,\n            left: origin.x,\n            right: origin.x + width,\n            height,\n            width\n        };\n    }\n}\n/** Shallow-extends a stylesheet object with another stylesheet object. */\nfunction extendStyles(destination, source) {\n    for (let key in source) {\n        if (source.hasOwnProperty(key)) {\n            destination[key] = source[key];\n        }\n    }\n    return destination;\n}\n/**\n * Extracts the pixel value as a number from a value, if it's a number\n * or a CSS pixel string (e.g. `1337px`). Otherwise returns null.\n */\nfunction getPixelValue(input) {\n    if (typeof input !== 'number' && input != null) {\n        const [value, units] = input.split(cssUnitPattern);\n        return (!units || units === 'px') ? parseFloat(value) : null;\n    }\n    return input || null;\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * A strategy for positioning overlays. Using this strategy, an overlay is given an\n * implicit position relative to some origin element. The relative position is defined in terms of\n * a point on the origin element that is connected to a point on the overlay element. For example,\n * a basic dropdown is connecting the bottom-left corner of the origin to the top-left corner\n * of the overlay.\n * @deprecated Use `FlexibleConnectedPositionStrategy` instead.\n * @breaking-change 8.0.0\n */\nclass ConnectedPositionStrategy {\n    constructor(originPos, overlayPos, connectedTo, viewportRuler, document, platform, overlayContainer) {\n        /** Ordered list of preferred positions, from most to least desirable. */\n        this._preferredPositions = [];\n        // Since the `ConnectedPositionStrategy` is deprecated and we don't want to maintain\n        // the extra logic, we create an instance of the positioning strategy that has some\n        // defaults that make it behave as the old position strategy and to which we'll\n        // proxy all of the API calls.\n        this._positionStrategy = new overlay_FlexibleConnectedPositionStrategy(connectedTo, viewportRuler, document, platform, overlayContainer)\n            .withFlexibleDimensions(false)\n            .withPush(false)\n            .withViewportMargin(0);\n        this.withFallbackPosition(originPos, overlayPos);\n    }\n    /** Whether the we're dealing with an RTL context */\n    get _isRtl() {\n        return this._overlayRef.getDirection() === 'rtl';\n    }\n    /** Emits an event when the connection point changes. */\n    get onPositionChange() {\n        return this._positionStrategy.positionChanges;\n    }\n    /** Ordered list of preferred positions, from most to least desirable. */\n    get positions() {\n        return this._preferredPositions;\n    }\n    /** Attach this position strategy to an overlay. */\n    attach(overlayRef) {\n        this._overlayRef = overlayRef;\n        this._positionStrategy.attach(overlayRef);\n        if (this._direction) {\n            overlayRef.setDirection(this._direction);\n            this._direction = null;\n        }\n    }\n    /** Disposes all resources used by the position strategy. */\n    dispose() {\n        this._positionStrategy.dispose();\n    }\n    /** @docs-private */\n    detach() {\n        this._positionStrategy.detach();\n    }\n    /**\n     * Updates the position of the overlay element, using whichever preferred position relative\n     * to the origin fits on-screen.\n     * @docs-private\n     */\n    apply() {\n        this._positionStrategy.apply();\n    }\n    /**\n     * Re-positions the overlay element with the trigger in its last calculated position,\n     * even if a position higher in the \"preferred positions\" list would now fit. This\n     * allows one to re-align the panel without changing the orientation of the panel.\n     */\n    recalculateLastPosition() {\n        this._positionStrategy.reapplyLastPosition();\n    }\n    /**\n     * Sets the list of Scrollable containers that host the origin element so that\n     * on reposition we can evaluate if it or the overlay has been clipped or outside view. Every\n     * Scrollable must be an ancestor element of the strategy's origin element.\n     */\n    withScrollableContainers(scrollables) {\n        this._positionStrategy.withScrollableContainers(scrollables);\n    }\n    /**\n     * Adds a new preferred fallback position.\n     * @param originPos\n     * @param overlayPos\n     */\n    withFallbackPosition(originPos, overlayPos, offsetX, offsetY) {\n        const position = new ConnectionPositionPair(originPos, overlayPos, offsetX, offsetY);\n        this._preferredPositions.push(position);\n        this._positionStrategy.withPositions(this._preferredPositions);\n        return this;\n    }\n    /**\n     * Sets the layout direction so the overlay's position can be adjusted to match.\n     * @param dir New layout direction.\n     */\n    withDirection(dir) {\n        // Since the direction might be declared before the strategy is attached,\n        // we save the value in a temporary property and we'll transfer it to the\n        // overlay ref on attachment.\n        if (this._overlayRef) {\n            this._overlayRef.setDirection(dir);\n        }\n        else {\n            this._direction = dir;\n        }\n        return this;\n    }\n    /**\n     * Sets an offset for the overlay's connection point on the x-axis\n     * @param offset New offset in the X axis.\n     */\n    withOffsetX(offset) {\n        this._positionStrategy.withDefaultOffsetX(offset);\n        return this;\n    }\n    /**\n     * Sets an offset for the overlay's connection point on the y-axis\n     * @param  offset New offset in the Y axis.\n     */\n    withOffsetY(offset) {\n        this._positionStrategy.withDefaultOffsetY(offset);\n        return this;\n    }\n    /**\n     * Sets whether the overlay's position should be locked in after it is positioned\n     * initially. When an overlay is locked in, it won't attempt to reposition itself\n     * when the position is re-applied (e.g. when the user scrolls away).\n     * @param isLocked Whether the overlay should locked in.\n     */\n    withLockedPosition(isLocked) {\n        this._positionStrategy.withLockedPosition(isLocked);\n        return this;\n    }\n    /**\n     * Overwrites the current set of positions with an array of new ones.\n     * @param positions Position pairs to be set on the strategy.\n     */\n    withPositions(positions) {\n        this._preferredPositions = positions.slice();\n        this._positionStrategy.withPositions(this._preferredPositions);\n        return this;\n    }\n    /**\n     * Sets the origin element, relative to which to position the overlay.\n     * @param origin Reference to the new origin element.\n     */\n    setOrigin(origin) {\n        this._positionStrategy.setOrigin(origin);\n        return this;\n    }\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/** Class to be added to the overlay pane wrapper. */\nconst wrapperClass = 'cdk-global-overlay-wrapper';\n/**\n * A strategy for positioning overlays. Using this strategy, an overlay is given an\n * explicit position relative to the browser's viewport. We use flexbox, instead of\n * transforms, in order to avoid issues with subpixel rendering which can cause the\n * element to become blurry.\n */\nclass GlobalPositionStrategy {\n    constructor() {\n        this._cssPosition = 'static';\n        this._topOffset = '';\n        this._bottomOffset = '';\n        this._leftOffset = '';\n        this._rightOffset = '';\n        this._alignItems = '';\n        this._justifyContent = '';\n        this._width = '';\n        this._height = '';\n    }\n    attach(overlayRef) {\n        const config = overlayRef.getConfig();\n        this._overlayRef = overlayRef;\n        if (this._width && !config.width) {\n            overlayRef.updateSize({ width: this._width });\n        }\n        if (this._height && !config.height) {\n            overlayRef.updateSize({ height: this._height });\n        }\n        overlayRef.hostElement.classList.add(wrapperClass);\n        this._isDisposed = false;\n    }\n    /**\n     * Sets the top position of the overlay. Clears any previously set vertical position.\n     * @param value New top offset.\n     */\n    top(value = '') {\n        this._bottomOffset = '';\n        this._topOffset = value;\n        this._alignItems = 'flex-start';\n        return this;\n    }\n    /**\n     * Sets the left position of the overlay. Clears any previously set horizontal position.\n     * @param value New left offset.\n     */\n    left(value = '') {\n        this._rightOffset = '';\n        this._leftOffset = value;\n        this._justifyContent = 'flex-start';\n        return this;\n    }\n    /**\n     * Sets the bottom position of the overlay. Clears any previously set vertical position.\n     * @param value New bottom offset.\n     */\n    bottom(value = '') {\n        this._topOffset = '';\n        this._bottomOffset = value;\n        this._alignItems = 'flex-end';\n        return this;\n    }\n    /**\n     * Sets the right position of the overlay. Clears any previously set horizontal position.\n     * @param value New right offset.\n     */\n    right(value = '') {\n        this._leftOffset = '';\n        this._rightOffset = value;\n        this._justifyContent = 'flex-end';\n        return this;\n    }\n    /**\n     * Sets the overlay width and clears any previously set width.\n     * @param value New width for the overlay\n     * @deprecated Pass the `width` through the `OverlayConfig`.\n     * @breaking-change 8.0.0\n     */\n    width(value = '') {\n        if (this._overlayRef) {\n            this._overlayRef.updateSize({ width: value });\n        }\n        else {\n            this._width = value;\n        }\n        return this;\n    }\n    /**\n     * Sets the overlay height and clears any previously set height.\n     * @param value New height for the overlay\n     * @deprecated Pass the `height` through the `OverlayConfig`.\n     * @breaking-change 8.0.0\n     */\n    height(value = '') {\n        if (this._overlayRef) {\n            this._overlayRef.updateSize({ height: value });\n        }\n        else {\n            this._height = value;\n        }\n        return this;\n    }\n    /**\n     * Centers the overlay horizontally with an optional offset.\n     * Clears any previously set horizontal position.\n     *\n     * @param offset Overlay offset from the horizontal center.\n     */\n    centerHorizontally(offset = '') {\n        this.left(offset);\n        this._justifyContent = 'center';\n        return this;\n    }\n    /**\n     * Centers the overlay vertically with an optional offset.\n     * Clears any previously set vertical position.\n     *\n     * @param offset Overlay offset from the vertical center.\n     */\n    centerVertically(offset = '') {\n        this.top(offset);\n        this._alignItems = 'center';\n        return this;\n    }\n    /**\n     * Apply the position to the element.\n     * @docs-private\n     */\n    apply() {\n        // Since the overlay ref applies the strategy asynchronously, it could\n        // have been disposed before it ends up being applied. If that is the\n        // case, we shouldn't do anything.\n        if (!this._overlayRef || !this._overlayRef.hasAttached()) {\n            return;\n        }\n        const styles = this._overlayRef.overlayElement.style;\n        const parentStyles = this._overlayRef.hostElement.style;\n        const config = this._overlayRef.getConfig();\n        const { width, height, maxWidth, maxHeight } = config;\n        const shouldBeFlushHorizontally = (width === '100%' || width === '100vw') &&\n            (!maxWidth || maxWidth === '100%' || maxWidth === '100vw');\n        const shouldBeFlushVertically = (height === '100%' || height === '100vh') &&\n            (!maxHeight || maxHeight === '100%' || maxHeight === '100vh');\n        styles.position = this._cssPosition;\n        styles.marginLeft = shouldBeFlushHorizontally ? '0' : this._leftOffset;\n        styles.marginTop = shouldBeFlushVertically ? '0' : this._topOffset;\n        styles.marginBottom = this._bottomOffset;\n        styles.marginRight = this._rightOffset;\n        if (shouldBeFlushHorizontally) {\n            parentStyles.justifyContent = 'flex-start';\n        }\n        else if (this._justifyContent === 'center') {\n            parentStyles.justifyContent = 'center';\n        }\n        else if (this._overlayRef.getConfig().direction === 'rtl') {\n            // In RTL the browser will invert `flex-start` and `flex-end` automatically, but we\n            // don't want that because our positioning is explicitly `left` and `right`, hence\n            // why we do another inversion to ensure that the overlay stays in the same position.\n            // TODO: reconsider this if we add `start` and `end` methods.\n            if (this._justifyContent === 'flex-start') {\n                parentStyles.justifyContent = 'flex-end';\n            }\n            else if (this._justifyContent === 'flex-end') {\n                parentStyles.justifyContent = 'flex-start';\n            }\n        }\n        else {\n            parentStyles.justifyContent = this._justifyContent;\n        }\n        parentStyles.alignItems = shouldBeFlushVertically ? 'flex-start' : this._alignItems;\n    }\n    /**\n     * Cleans up the DOM changes from the position strategy.\n     * @docs-private\n     */\n    dispose() {\n        if (this._isDisposed || !this._overlayRef) {\n            return;\n        }\n        const styles = this._overlayRef.overlayElement.style;\n        const parent = this._overlayRef.hostElement;\n        const parentStyles = parent.style;\n        parent.classList.remove(wrapperClass);\n        parentStyles.justifyContent = parentStyles.alignItems = styles.marginTop =\n            styles.marginBottom = styles.marginLeft = styles.marginRight = styles.position = '';\n        this._overlayRef = null;\n        this._isDisposed = true;\n    }\n}\nlet overlay_OverlayPositionBuilder = /*@__PURE__*/ (() => {\n    class OverlayPositionBuilder {\n        constructor(_viewportRuler, _document, _platform, _overlayContainer) {\n            this._viewportRuler = _viewportRuler;\n            this._document = _document;\n            this._platform = _platform;\n            this._overlayContainer = _overlayContainer;\n        }\n        /**\n         * Creates a global position strategy.\n         */\n        global() {\n            return new GlobalPositionStrategy();\n        }\n        /**\n         * Creates a relative position strategy.\n         * @param elementRef\n         * @param originPos\n         * @param overlayPos\n         * @deprecated Use `flexibleConnectedTo` instead.\n         * @breaking-change 8.0.0\n         */\n        connectedTo(elementRef, originPos, overlayPos) {\n            return new ConnectedPositionStrategy(originPos, overlayPos, elementRef, this._viewportRuler, this._document, this._platform, this._overlayContainer);\n        }\n        /**\n         * Creates a flexible position strategy.\n         * @param origin Origin relative to which to position the overlay.\n         */\n        flexibleConnectedTo(origin) {\n            return new overlay_FlexibleConnectedPositionStrategy(origin, this._viewportRuler, this._document, this._platform, this._overlayContainer);\n        }\n    }\n    OverlayPositionBuilder.ɵfac = function OverlayPositionBuilder_Factory(t) { return new (t || OverlayPositionBuilder)(core[\"Zb\" /* ɵɵinject */](scrolling_ViewportRuler), core[\"Zb\" /* ɵɵinject */](common[\"e\" /* DOCUMENT */]), core[\"Zb\" /* ɵɵinject */](fesm2015_platform[\"a\" /* Platform */]), core[\"Zb\" /* ɵɵinject */](overlay_OverlayContainer)); };\n    OverlayPositionBuilder.ɵprov = /*@__PURE__*/ Object(core[\"Lb\" /* ɵɵdefineInjectable */])({ factory: function OverlayPositionBuilder_Factory() { return new OverlayPositionBuilder(Object(core[\"Zb\" /* ɵɵinject */])(scrolling_ViewportRuler), Object(core[\"Zb\" /* ɵɵinject */])(common[\"e\" /* DOCUMENT */]), Object(core[\"Zb\" /* ɵɵinject */])(fesm2015_platform[\"a\" /* Platform */]), Object(core[\"Zb\" /* ɵɵinject */])(overlay_OverlayContainer)); }, token: OverlayPositionBuilder, providedIn: \"root\" });\n    return OverlayPositionBuilder;\n})();\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/** Next overlay unique ID. */\nlet nextUniqueId = 0;\nlet overlay_Overlay = /*@__PURE__*/ (() => {\n    class Overlay {\n        constructor(\n        /** Scrolling strategies that can be used when creating an overlay. */\n        scrollStrategies, _overlayContainer, _componentFactoryResolver, _positionBuilder, _keyboardDispatcher, _injector, _ngZone, _document, _directionality, \n        // @breaking-change 8.0.0 `_location` parameter to be made required.\n        _location) {\n            this.scrollStrategies = scrollStrategies;\n            this._overlayContainer = _overlayContainer;\n            this._componentFactoryResolver = _componentFactoryResolver;\n            this._positionBuilder = _positionBuilder;\n            this._keyboardDispatcher = _keyboardDispatcher;\n            this._injector = _injector;\n            this._ngZone = _ngZone;\n            this._document = _document;\n            this._directionality = _directionality;\n            this._location = _location;\n        }\n        /**\n         * Creates an overlay.\n         * @param config Configuration applied to the overlay.\n         * @returns Reference to the created overlay.\n         */\n        create(config) {\n            const host = this._createHostElement();\n            const pane = this._createPaneElement(host);\n            const portalOutlet = this._createPortalOutlet(pane);\n            const overlayConfig = new OverlayConfig(config);\n            overlayConfig.direction = overlayConfig.direction || this._directionality.value;\n            return new overlay_OverlayRef(portalOutlet, host, pane, overlayConfig, this._ngZone, this._keyboardDispatcher, this._document, this._location);\n        }\n        /**\n         * Gets a position builder that can be used, via fluent API,\n         * to construct and configure a position strategy.\n         * @returns An overlay position builder.\n         */\n        position() {\n            return this._positionBuilder;\n        }\n        /**\n         * Creates the DOM element for an overlay and appends it to the overlay container.\n         * @returns Newly-created pane element\n         */\n        _createPaneElement(host) {\n            const pane = this._document.createElement('div');\n            pane.id = `cdk-overlay-${nextUniqueId++}`;\n            pane.classList.add('cdk-overlay-pane');\n            host.appendChild(pane);\n            return pane;\n        }\n        /**\n         * Creates the host element that wraps around an overlay\n         * and can be used for advanced positioning.\n         * @returns Newly-create host element.\n         */\n        _createHostElement() {\n            const host = this._document.createElement('div');\n            this._overlayContainer.getContainerElement().appendChild(host);\n            return host;\n        }\n        /**\n         * Create a DomPortalOutlet into which the overlay content can be loaded.\n         * @param pane The DOM element to turn into a portal outlet.\n         * @returns A portal outlet for the given DOM element.\n         */\n        _createPortalOutlet(pane) {\n            // We have to resolve the ApplicationRef later in order to allow people\n            // to use overlay-based providers during app initialization.\n            if (!this._appRef) {\n                this._appRef = this._injector.get(core[\"g\" /* ApplicationRef */]);\n            }\n            return new DomPortalOutlet(pane, this._componentFactoryResolver, this._appRef, this._injector, this._document);\n        }\n    }\n    Overlay.ɵfac = function Overlay_Factory(t) { return new (t || Overlay)(core[\"Zb\" /* ɵɵinject */](overlay_ScrollStrategyOptions), core[\"Zb\" /* ɵɵinject */](overlay_OverlayContainer), core[\"Zb\" /* ɵɵinject */](core[\"k\" /* ComponentFactoryResolver */]), core[\"Zb\" /* ɵɵinject */](overlay_OverlayPositionBuilder), core[\"Zb\" /* ɵɵinject */](overlay_OverlayKeyboardDispatcher), core[\"Zb\" /* ɵɵinject */](core[\"t\" /* Injector */]), core[\"Zb\" /* ɵɵinject */](core[\"B\" /* NgZone */]), core[\"Zb\" /* ɵɵinject */](common[\"e\" /* DOCUMENT */]), core[\"Zb\" /* ɵɵinject */](bidi_Directionality), core[\"Zb\" /* ɵɵinject */](common[\"i\" /* Location */], 8)); };\n    Overlay.ɵprov = /*@__PURE__*/ core[\"Lb\" /* ɵɵdefineInjectable */]({ token: Overlay, factory: Overlay.ɵfac });\n    return Overlay;\n})();\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/** Default set of positions for the overlay. Follows the behavior of a dropdown. */\nconst defaultPositionList = [\n    {\n        originX: 'start',\n        originY: 'bottom',\n        overlayX: 'start',\n        overlayY: 'top'\n    },\n    {\n        originX: 'start',\n        originY: 'top',\n        overlayX: 'start',\n        overlayY: 'bottom'\n    },\n    {\n        originX: 'end',\n        originY: 'top',\n        overlayX: 'end',\n        overlayY: 'bottom'\n    },\n    {\n        originX: 'end',\n        originY: 'bottom',\n        overlayX: 'end',\n        overlayY: 'top'\n    }\n];\n/** Injection token that determines the scroll handling while the connected overlay is open. */\nconst CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY = /*@__PURE__*/ new core[\"s\" /* InjectionToken */]('cdk-connected-overlay-scroll-strategy');\n/** @docs-private @deprecated @breaking-change 8.0.0 */\nfunction CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY_FACTORY(overlay) {\n    return (config) => overlay.scrollStrategies.reposition(config);\n}\nlet overlay_CdkOverlayOrigin = /*@__PURE__*/ (() => {\n    class CdkOverlayOrigin {\n        constructor(\n        /** Reference to the element on which the directive is applied. */\n        elementRef) {\n            this.elementRef = elementRef;\n        }\n    }\n    CdkOverlayOrigin.ɵfac = function CdkOverlayOrigin_Factory(t) { return new (t || CdkOverlayOrigin)(core[\"Pb\" /* ɵɵdirectiveInject */](core[\"m\" /* ElementRef */])); };\n    CdkOverlayOrigin.ɵdir = /*@__PURE__*/ core[\"Kb\" /* ɵɵdefineDirective */]({ type: CdkOverlayOrigin, selectors: [[\"\", \"cdk-overlay-origin\", \"\"], [\"\", \"overlay-origin\", \"\"], [\"\", \"cdkOverlayOrigin\", \"\"]], exportAs: [\"cdkOverlayOrigin\"] });\n    return CdkOverlayOrigin;\n})();\nlet overlay_CdkConnectedOverlay = /*@__PURE__*/ (() => {\n    class CdkConnectedOverlay {\n        // TODO(jelbourn): inputs for size, scroll behavior, animation, etc.\n        constructor(_overlay, templateRef, viewContainerRef, scrollStrategyFactory, _dir) {\n            this._overlay = _overlay;\n            this._dir = _dir;\n            this._hasBackdrop = false;\n            this._lockPosition = false;\n            this._growAfterOpen = false;\n            this._flexibleDimensions = false;\n            this._push = false;\n            this._backdropSubscription = Subscription[\"a\" /* Subscription */].EMPTY;\n            /** Margin between the overlay and the viewport edges. */\n            this.viewportMargin = 0;\n            /** Whether the overlay is open. */\n            this.open = false;\n            /** Event emitted when the backdrop is clicked. */\n            this.backdropClick = new core[\"o\" /* EventEmitter */]();\n            /** Event emitted when the position has changed. */\n            this.positionChange = new core[\"o\" /* EventEmitter */]();\n            /** Event emitted when the overlay has been attached. */\n            this.attach = new core[\"o\" /* EventEmitter */]();\n            /** Event emitted when the overlay has been detached. */\n            this.detach = new core[\"o\" /* EventEmitter */]();\n            /** Emits when there are keyboard events that are targeted at the overlay. */\n            this.overlayKeydown = new core[\"o\" /* EventEmitter */]();\n            this._templatePortal = new TemplatePortal(templateRef, viewContainerRef);\n            this._scrollStrategyFactory = scrollStrategyFactory;\n            this.scrollStrategy = this._scrollStrategyFactory();\n        }\n        /** The offset in pixels for the overlay connection point on the x-axis */\n        get offsetX() { return this._offsetX; }\n        set offsetX(offsetX) {\n            this._offsetX = offsetX;\n            if (this._position) {\n                this._updatePositionStrategy(this._position);\n            }\n        }\n        /** The offset in pixels for the overlay connection point on the y-axis */\n        get offsetY() { return this._offsetY; }\n        set offsetY(offsetY) {\n            this._offsetY = offsetY;\n            if (this._position) {\n                this._updatePositionStrategy(this._position);\n            }\n        }\n        /** Whether or not the overlay should attach a backdrop. */\n        get hasBackdrop() { return this._hasBackdrop; }\n        set hasBackdrop(value) { this._hasBackdrop = coerceBooleanProperty(value); }\n        /** Whether or not the overlay should be locked when scrolling. */\n        get lockPosition() { return this._lockPosition; }\n        set lockPosition(value) { this._lockPosition = coerceBooleanProperty(value); }\n        /** Whether the overlay's width and height can be constrained to fit within the viewport. */\n        get flexibleDimensions() { return this._flexibleDimensions; }\n        set flexibleDimensions(value) {\n            this._flexibleDimensions = coerceBooleanProperty(value);\n        }\n        /** Whether the overlay can grow after the initial open when flexible positioning is turned on. */\n        get growAfterOpen() { return this._growAfterOpen; }\n        set growAfterOpen(value) { this._growAfterOpen = coerceBooleanProperty(value); }\n        /** Whether the overlay can be pushed on-screen if none of the provided positions fit. */\n        get push() { return this._push; }\n        set push(value) { this._push = coerceBooleanProperty(value); }\n        /** The associated overlay reference. */\n        get overlayRef() {\n            return this._overlayRef;\n        }\n        /** The element's layout direction. */\n        get dir() {\n            return this._dir ? this._dir.value : 'ltr';\n        }\n        ngOnDestroy() {\n            if (this._overlayRef) {\n                this._overlayRef.dispose();\n            }\n            this._backdropSubscription.unsubscribe();\n        }\n        ngOnChanges(changes) {\n            if (this._position) {\n                this._updatePositionStrategy(this._position);\n                this._overlayRef.updateSize({\n                    width: this.width,\n                    minWidth: this.minWidth,\n                    height: this.height,\n                    minHeight: this.minHeight,\n                });\n                if (changes['origin'] && this.open) {\n                    this._position.apply();\n                }\n            }\n            if (changes['open']) {\n                this.open ? this._attachOverlay() : this._detachOverlay();\n            }\n        }\n        /** Creates an overlay */\n        _createOverlay() {\n            if (!this.positions || !this.positions.length) {\n                this.positions = defaultPositionList;\n            }\n            this._overlayRef = this._overlay.create(this._buildConfig());\n            this._overlayRef.keydownEvents().subscribe((event) => {\n                this.overlayKeydown.next(event);\n                if (event.keyCode === ESCAPE && !hasModifierKey(event)) {\n                    event.preventDefault();\n                    this._detachOverlay();\n                }\n            });\n        }\n        /** Builds the overlay config based on the directive's inputs */\n        _buildConfig() {\n            const positionStrategy = this._position =\n                this.positionStrategy || this._createPositionStrategy();\n            const overlayConfig = new OverlayConfig({\n                direction: this._dir,\n                positionStrategy,\n                scrollStrategy: this.scrollStrategy,\n                hasBackdrop: this.hasBackdrop\n            });\n            if (this.width || this.width === 0) {\n                overlayConfig.width = this.width;\n            }\n            if (this.height || this.height === 0) {\n                overlayConfig.height = this.height;\n            }\n            if (this.minWidth || this.minWidth === 0) {\n                overlayConfig.minWidth = this.minWidth;\n            }\n            if (this.minHeight || this.minHeight === 0) {\n                overlayConfig.minHeight = this.minHeight;\n            }\n            if (this.backdropClass) {\n                overlayConfig.backdropClass = this.backdropClass;\n            }\n            if (this.panelClass) {\n                overlayConfig.panelClass = this.panelClass;\n            }\n            return overlayConfig;\n        }\n        /** Updates the state of a position strategy, based on the values of the directive inputs. */\n        _updatePositionStrategy(positionStrategy) {\n            const positions = this.positions.map(currentPosition => ({\n                originX: currentPosition.originX,\n                originY: currentPosition.originY,\n                overlayX: currentPosition.overlayX,\n                overlayY: currentPosition.overlayY,\n                offsetX: currentPosition.offsetX || this.offsetX,\n                offsetY: currentPosition.offsetY || this.offsetY,\n                panelClass: currentPosition.panelClass || undefined,\n            }));\n            return positionStrategy\n                .setOrigin(this.origin.elementRef)\n                .withPositions(positions)\n                .withFlexibleDimensions(this.flexibleDimensions)\n                .withPush(this.push)\n                .withGrowAfterOpen(this.growAfterOpen)\n                .withViewportMargin(this.viewportMargin)\n                .withLockedPosition(this.lockPosition)\n                .withTransformOriginOn(this.transformOriginSelector);\n        }\n        /** Returns the position strategy of the overlay to be set on the overlay config */\n        _createPositionStrategy() {\n            const strategy = this._overlay.position().flexibleConnectedTo(this.origin.elementRef);\n            this._updatePositionStrategy(strategy);\n            strategy.positionChanges.subscribe(p => this.positionChange.emit(p));\n            return strategy;\n        }\n        /** Attaches the overlay and subscribes to backdrop clicks if backdrop exists */\n        _attachOverlay() {\n            if (!this._overlayRef) {\n                this._createOverlay();\n            }\n            else {\n                // Update the overlay size, in case the directive's inputs have changed\n                this._overlayRef.getConfig().hasBackdrop = this.hasBackdrop;\n            }\n            if (!this._overlayRef.hasAttached()) {\n                this._overlayRef.attach(this._templatePortal);\n                this.attach.emit();\n            }\n            if (this.hasBackdrop) {\n                this._backdropSubscription = this._overlayRef.backdropClick().subscribe(event => {\n                    this.backdropClick.emit(event);\n                });\n            }\n            else {\n                this._backdropSubscription.unsubscribe();\n            }\n        }\n        /** Detaches the overlay and unsubscribes to backdrop clicks if backdrop exists */\n        _detachOverlay() {\n            if (this._overlayRef) {\n                this._overlayRef.detach();\n                this.detach.emit();\n            }\n            this._backdropSubscription.unsubscribe();\n        }\n    }\n    CdkConnectedOverlay.ɵfac = function CdkConnectedOverlay_Factory(t) { return new (t || CdkConnectedOverlay)(core[\"Pb\" /* ɵɵdirectiveInject */](overlay_Overlay), core[\"Pb\" /* ɵɵdirectiveInject */](core[\"N\" /* TemplateRef */]), core[\"Pb\" /* ɵɵdirectiveInject */](core[\"R\" /* ViewContainerRef */]), core[\"Pb\" /* ɵɵdirectiveInject */](CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY), core[\"Pb\" /* ɵɵdirectiveInject */](bidi_Directionality, 8)); };\n    CdkConnectedOverlay.ɵdir = /*@__PURE__*/ core[\"Kb\" /* ɵɵdefineDirective */]({ type: CdkConnectedOverlay, selectors: [[\"\", \"cdk-connected-overlay\", \"\"], [\"\", \"connected-overlay\", \"\"], [\"\", \"cdkConnectedOverlay\", \"\"]], inputs: { viewportMargin: [\"cdkConnectedOverlayViewportMargin\", \"viewportMargin\"], open: [\"cdkConnectedOverlayOpen\", \"open\"], scrollStrategy: [\"cdkConnectedOverlayScrollStrategy\", \"scrollStrategy\"], offsetX: [\"cdkConnectedOverlayOffsetX\", \"offsetX\"], offsetY: [\"cdkConnectedOverlayOffsetY\", \"offsetY\"], hasBackdrop: [\"cdkConnectedOverlayHasBackdrop\", \"hasBackdrop\"], lockPosition: [\"cdkConnectedOverlayLockPosition\", \"lockPosition\"], flexibleDimensions: [\"cdkConnectedOverlayFlexibleDimensions\", \"flexibleDimensions\"], growAfterOpen: [\"cdkConnectedOverlayGrowAfterOpen\", \"growAfterOpen\"], push: [\"cdkConnectedOverlayPush\", \"push\"], positions: [\"cdkConnectedOverlayPositions\", \"positions\"], origin: [\"cdkConnectedOverlayOrigin\", \"origin\"], positionStrategy: [\"cdkConnectedOverlayPositionStrategy\", \"positionStrategy\"], width: [\"cdkConnectedOverlayWidth\", \"width\"], height: [\"cdkConnectedOverlayHeight\", \"height\"], minWidth: [\"cdkConnectedOverlayMinWidth\", \"minWidth\"], minHeight: [\"cdkConnectedOverlayMinHeight\", \"minHeight\"], backdropClass: [\"cdkConnectedOverlayBackdropClass\", \"backdropClass\"], panelClass: [\"cdkConnectedOverlayPanelClass\", \"panelClass\"], transformOriginSelector: [\"cdkConnectedOverlayTransformOriginOn\", \"transformOriginSelector\"] }, outputs: { backdropClick: \"backdropClick\", positionChange: \"positionChange\", attach: \"attach\", detach: \"detach\", overlayKeydown: \"overlayKeydown\" }, exportAs: [\"cdkConnectedOverlay\"], features: [core[\"Bb\" /* ɵɵNgOnChangesFeature */]] });\n    return CdkConnectedOverlay;\n})();\n/** @docs-private */\nfunction CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY_PROVIDER_FACTORY(overlay) {\n    return () => overlay.scrollStrategies.reposition();\n}\n/** @docs-private */\nconst CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY_PROVIDER = {\n    provide: CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY,\n    deps: [overlay_Overlay],\n    useFactory: CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY_PROVIDER_FACTORY,\n};\nlet overlay_OverlayModule = /*@__PURE__*/ (() => {\n    class OverlayModule {\n    }\n    OverlayModule.ɵmod = /*@__PURE__*/ core[\"Nb\" /* ɵɵdefineNgModule */]({ type: OverlayModule });\n    OverlayModule.ɵinj = /*@__PURE__*/ core[\"Mb\" /* ɵɵdefineInjector */]({ factory: function OverlayModule_Factory(t) { return new (t || OverlayModule)(); }, providers: [\n            overlay_Overlay,\n            CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY_PROVIDER,\n        ], imports: [[bidi_BidiModule, portal_PortalModule, scrolling_ScrollingModule], scrolling_ScrollingModule] });\n    return OverlayModule;\n})();\n/*@__PURE__*/ (function () { (typeof ngJitMode === \"undefined\" || ngJitMode) && core[\"Ac\" /* ɵɵsetNgModuleScope */](overlay_OverlayModule, { declarations: function () { return [overlay_CdkConnectedOverlay, overlay_CdkOverlayOrigin]; }, imports: function () { return [bidi_BidiModule, portal_PortalModule, scrolling_ScrollingModule]; }, exports: function () { return [overlay_CdkConnectedOverlay, overlay_CdkOverlayOrigin, scrolling_ScrollingModule]; } }); })();\n/**\n * @deprecated Use `OverlayModule` instead.\n * @breaking-change 8.0.0\n * @docs-private\n */\nconst OVERLAY_PROVIDERS = [\n    overlay_Overlay,\n    overlay_OverlayPositionBuilder,\n    OVERLAY_KEYBOARD_DISPATCHER_PROVIDER,\n    OVERLAY_CONTAINER_PROVIDER,\n    CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY_PROVIDER,\n];\nlet overlay_FullscreenOverlayContainer = /*@__PURE__*/ (() => {\n    class FullscreenOverlayContainer extends overlay_OverlayContainer {\n        constructor(_document, \n        /**\n         * @deprecated `platform` parameter to become required.\n         * @breaking-change 10.0.0\n         */\n        platform) {\n            super(_document, platform);\n        }\n        ngOnDestroy() {\n            super.ngOnDestroy();\n            if (this._fullScreenEventName && this._fullScreenListener) {\n                this._document.removeEventListener(this._fullScreenEventName, this._fullScreenListener);\n            }\n        }\n        _createContainer() {\n            super._createContainer();\n            this._adjustParentForFullscreenChange();\n            this._addFullscreenChangeListener(() => this._adjustParentForFullscreenChange());\n        }\n        _adjustParentForFullscreenChange() {\n            if (!this._containerElement) {\n                return;\n            }\n            const fullscreenElement = this.getFullscreenElement();\n            const parent = fullscreenElement || this._document.body;\n            parent.appendChild(this._containerElement);\n        }\n        _addFullscreenChangeListener(fn) {\n            const eventName = this._getEventName();\n            if (eventName) {\n                if (this._fullScreenListener) {\n                    this._document.removeEventListener(eventName, this._fullScreenListener);\n                }\n                this._document.addEventListener(eventName, fn);\n                this._fullScreenListener = fn;\n            }\n        }\n        _getEventName() {\n            if (!this._fullScreenEventName) {\n                const _document = this._document;\n                if (_document.fullscreenEnabled) {\n                    this._fullScreenEventName = 'fullscreenchange';\n                }\n                else if (_document.webkitFullscreenEnabled) {\n                    this._fullScreenEventName = 'webkitfullscreenchange';\n                }\n                else if (_document.mozFullScreenEnabled) {\n                    this._fullScreenEventName = 'mozfullscreenchange';\n                }\n                else if (_document.msFullscreenEnabled) {\n                    this._fullScreenEventName = 'MSFullscreenChange';\n                }\n            }\n            return this._fullScreenEventName;\n        }\n        /**\n         * When the page is put into fullscreen mode, a specific element is specified.\n         * Only that element and its children are visible when in fullscreen mode.\n         */\n        getFullscreenElement() {\n            const _document = this._document;\n            return _document.fullscreenElement ||\n                _document.webkitFullscreenElement ||\n                _document.mozFullScreenElement ||\n                _document.msFullscreenElement ||\n                null;\n        }\n    }\n    FullscreenOverlayContainer.ɵfac = function FullscreenOverlayContainer_Factory(t) { return new (t || FullscreenOverlayContainer)(core[\"Zb\" /* ɵɵinject */](common[\"e\" /* DOCUMENT */]), core[\"Zb\" /* ɵɵinject */](fesm2015_platform[\"a\" /* Platform */])); };\n    FullscreenOverlayContainer.ɵprov = /*@__PURE__*/ Object(core[\"Lb\" /* ɵɵdefineInjectable */])({ factory: function FullscreenOverlayContainer_Factory() { return new FullscreenOverlayContainer(Object(core[\"Zb\" /* ɵɵinject */])(common[\"e\" /* DOCUMENT */]), Object(core[\"Zb\" /* ɵɵinject */])(fesm2015_platform[\"a\" /* Platform */])); }, token: FullscreenOverlayContainer, providedIn: \"root\" });\n    return FullscreenOverlayContainer;\n})();\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Generated bundle index. Do not edit.\n */\n\n//# sourceMappingURL=overlay.js.map\n\n// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/observable/from.js + 6 modules\nvar observable_from = __webpack_require__(\"Cfvw\");\n\n// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/operators/finalize.js\nvar finalize = __webpack_require__(\"nYR2\");\n\n// CONCATENATED MODULE: ./node_modules/ng-gallery/__ivy_ngcc__/fesm2015/ng-gallery-lightbox.js\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nconst ng_gallery_lightbox_c0 = function (a0, a1) { return { startAnimationTime: a0, exitAnimationTime: a1 }; };\nconst ng_gallery_lightbox_c1 = function (a0, a1) { return { value: a0, params: a1 }; };\nconst LIGHTBOX_CONFIG = new core[\"s\" /* InjectionToken */]('LIGHTBOX_CONFIG');\nconst lightboxAnimation = Object(animations[\"l\" /* trigger */])('lightbox', [\n    // Note: The `enter` animation transitions to `transform: none`, because for some reason\n    // specifying the transform explicitly, causes IE both to blur the dialog content and\n    // decimate the animation performance. Leaving it as `none` solves both issues.\n    Object(animations[\"i\" /* state */])('void, exit', Object(animations[\"j\" /* style */])({ opacity: 0, transform: 'scale(0.7)' })),\n    Object(animations[\"i\" /* state */])('enter', Object(animations[\"j\" /* style */])({ transform: 'none' })),\n    Object(animations[\"k\" /* transition */])('* => enter', Object(animations[\"e\" /* animate */])('{{startAnimationTime}}ms cubic-bezier(0, 0, 0.2, 1)', Object(animations[\"j\" /* style */])({ transform: 'none', opacity: 1 }))),\n    Object(animations[\"k\" /* transition */])('* => void, * => exit', Object(animations[\"e\" /* animate */])('{{exitAnimationTime}}ms cubic-bezier(0.4, 0.0, 0.2, 1)', Object(animations[\"j\" /* style */])({ opacity: 0 }))),\n]);\nlet ng_gallery_lightbox_LightboxComponent = /*@__PURE__*/ (() => {\n    class LightboxComponent {\n        constructor(_document, _focusTrapFactory, _elementRef, sanitizer) {\n            this._document = _document;\n            this._focusTrapFactory = _focusTrapFactory;\n            this._elementRef = _elementRef;\n            this.sanitizer = sanitizer;\n            /** State of the lightbox animation. */\n            this.state = 'enter';\n            this._savePreviouslyFocusedElement();\n        }\n        /** Callback, invoked whenever an animation on the host completes. */\n        onAnimationDone(event) {\n            if (event.toState === 'enter') {\n                this._trapFocus();\n            }\n            else {\n                this.overlayRef.dispose();\n                this._restoreFocus();\n            }\n        }\n        /** Moves the focus inside the focus trap. */\n        _trapFocus() {\n            if (!this._focusTrap) {\n                this._focusTrap = this._focusTrapFactory.create(this._elementRef.nativeElement);\n            }\n            // If were to attempt to focus immediately, then the content of the lightbox would not yet be\n            // ready in instances where change detection has to run first. To deal with this, we simply\n            // wait for the microtask queue to be empty.\n            this._focusTrap.focusInitialElementWhenReady();\n        }\n        /** Saves a reference to the element that was focused before the lightbox was opened. */\n        _savePreviouslyFocusedElement() {\n            if (this._document) {\n                this._elementFocusedBeforeDialogWasOpened = this._document.activeElement;\n                // Note that there is no focus method when rendering on the server.\n                if (this._elementRef.nativeElement.focus) {\n                    // Move focus onto the lightbox immediately in order to prevent the user from accidentally\n                    // opening multiple dialogs at the same time. Needs to be async, because the element\n                    // may not be focusable immediately.\n                    Promise.resolve().then(() => this._elementRef.nativeElement.focus());\n                }\n            }\n        }\n        /** Restores focus to the element that was focused before the lightbox opened. */\n        _restoreFocus() {\n            const toFocus = this._elementFocusedBeforeDialogWasOpened;\n            // We need the extra check, because IE can set the `activeElement` to null in some cases.\n            if (toFocus && typeof toFocus.focus === 'function') {\n                toFocus.focus();\n            }\n            if (this._focusTrap) {\n                this._focusTrap.destroy();\n            }\n        }\n    }\n    LightboxComponent.ɵfac = function LightboxComponent_Factory(t) { return new (t || LightboxComponent)(core[\"Pb\" /* ɵɵdirectiveInject */](common[\"e\" /* DOCUMENT */], 8), core[\"Pb\" /* ɵɵdirectiveInject */](a11y_ConfigurableFocusTrapFactory), core[\"Pb\" /* ɵɵdirectiveInject */](core[\"m\" /* ElementRef */]), core[\"Pb\" /* ɵɵdirectiveInject */](platform_browser[\"b\" /* DomSanitizer */])); };\n    LightboxComponent.ɵcmp = core[\"Jb\" /* ɵɵdefineComponent */]({ type: LightboxComponent, selectors: [[\"lightbox\"]], hostAttrs: [\"tabindex\", \"-1\", \"aria-modal\", \"true\"], hostVars: 12, hostBindings: function LightboxComponent_HostBindings(rf, ctx) {\n            if (rf & 1) {\n                core[\"Cc\" /* ɵɵsyntheticHostListener */](\"@lightbox.done\", function LightboxComponent_animation_lightbox_done_HostBindingHandler($event) { return ctx.onAnimationDone($event); });\n            }\n            if (rf & 2) {\n                core[\"Eb\" /* ɵɵattribute */](\"id\", \"lightbox-\" + ctx.id)(\"role\", ctx.role)(\"aria-labelledby\", ctx.ariaLabel ? null : ctx.ariaLabelledBy)(\"aria-label\", ctx.ariaLabel)(\"aria-describedby\", ctx.ariaDescribedBy || null);\n                core[\"Dc\" /* ɵɵsyntheticHostProperty */](\"@lightbox\", core[\"qc\" /* ɵɵpureFunction2 */](9, ng_gallery_lightbox_c1, ctx.state, core[\"qc\" /* ɵɵpureFunction2 */](6, ng_gallery_lightbox_c0, ctx.startAnimationTime, ctx.exitAnimationTime)));\n            }\n        }, decls: 2, vars: 4, consts: [[3, \"id\", \"destroyRef\", \"skipInitConfig\"], [\"aria-label\", \"Close\", 1, \"g-btn-close\", 3, \"innerHTML\", \"click\"]], template: function LightboxComponent_Template(rf, ctx) {\n            if (rf & 1) {\n                core[\"Vb\" /* ɵɵelementStart */](0, \"gallery\", 0);\n                core[\"Vb\" /* ɵɵelementStart */](1, \"i\", 1);\n                core[\"dc\" /* ɵɵlistener */](\"click\", function LightboxComponent_Template_i_click_1_listener() { return ctx.overlayRef.detach(); });\n                core[\"Ub\" /* ɵɵelementEnd */]();\n                core[\"Ub\" /* ɵɵelementEnd */]();\n            }\n            if (rf & 2) {\n                core[\"lc\" /* ɵɵproperty */](\"id\", ctx.id)(\"destroyRef\", false)(\"skipInitConfig\", true);\n                core[\"Db\" /* ɵɵadvance */](1);\n                core[\"lc\" /* ɵɵproperty */](\"innerHTML\", ctx.sanitizer.bypassSecurityTrustHtml(ctx.closeIcon), core[\"wc\" /* ɵɵsanitizeHtml */]);\n            }\n        }, directives: [ng_gallery_GalleryComponent], styles: [\"lightbox{border-radius:4px;box-shadow:0 11px 15px -7px rgba(0,0,0,.2),0 24px 38px 3px rgba(0,0,0,.14),0 9px 46px 8px rgba(0,0,0,.12);display:block;height:800px;max-height:90vh;max-width:94vw;overflow:hidden;position:relative;width:1100px}  lightbox:focus{outline:none}  lightbox gallery{display:block;height:100%;margin:0;overflow:hidden;width:100%}  .g-backdrop{background-color:rgba(0,0,0,.32)}  .fullscreen{width:100%}  .fullscreen   lightbox{border-radius:0;bottom:0;height:100%;left:0;max-height:unset;max-width:unset;position:fixed;right:0;top:0;width:100%}  .g-overlay{margin:auto}@media only screen and (max-width:480px){  .g-overlay{width:100%}  .g-overlay   lightbox{border-radius:0;bottom:0;height:100%;left:0;max-height:unset;max-width:unset;position:fixed;right:0;top:0;width:100%}}  .g-btn-close{cursor:pointer;height:20px;position:absolute;right:.9em;top:.9em;width:20px;z-index:60}@media only screen and (max-width:480px){  .g-btn-close{right:.7em;top:.7em}}\"], data: { animation: [lightboxAnimation] }, changeDetection: 0 });\n    return LightboxComponent;\n})();\nconst ng_gallery_lightbox_defaultConfig = {\n    backdropClass: 'g-backdrop',\n    panelClass: 'g-overlay',\n    hasBackdrop: true,\n    keyboardShortcuts: true,\n    role: 'lightbox',\n    startAnimationTime: 150,\n    exitAnimationTime: 75,\n    closeIcon: `<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<svg width=\"512px\" height=\"512px\" enable-background=\"new 0 0 47.971 47.971\" version=\"1.1\" viewBox=\"0 0 47.971 47.971\" xml:space=\"preserve\" xmlns=\"http://www.w3.org/2000/svg\">\n\t<path d=\"M28.228,23.986L47.092,5.122c1.172-1.171,1.172-3.071,0-4.242c-1.172-1.172-3.07-1.172-4.242,0L23.986,19.744L5.121,0.88   c-1.172-1.172-3.07-1.172-4.242,0c-1.172,1.171-1.172,3.071,0,4.242l18.865,18.864L0.879,42.85c-1.172,1.171-1.172,3.071,0,4.242   C1.465,47.677,2.233,47.97,3,47.97s1.535-0.293,2.121-0.879l18.865-18.864L42.85,47.091c0.586,0.586,1.354,0.879,2.121,0.879   s1.535-0.293,2.121-0.879c1.172-1.171,1.172-3.071,0-4.242L28.228,23.986z\" fill=\"#fff\"/>\n</svg>\n`\n};\nlet ng_gallery_lightbox_Lightbox = /*@__PURE__*/ (() => {\n    class Lightbox {\n        constructor(config, _gallery, _overlay) {\n            this._gallery = _gallery;\n            this._overlay = _overlay;\n            /** Stream that emits when lightbox is opened */\n            this.opened = new Subject[\"a\" /* Subject */]();\n            /** Stream that emits when lightbox is closed */\n            this.closed = new Subject[\"a\" /* Subject */]();\n            this._config = config ? Object.assign(Object.assign({}, ng_gallery_lightbox_defaultConfig), config) : ng_gallery_lightbox_defaultConfig;\n        }\n        /**\n         * Set Lightbox Config\n         * @param config - LightboxConfig\n         */\n        setConfig(config) {\n            this._config = Object.assign(Object.assign({}, this._config), config);\n        }\n        /**\n         * Open Lightbox Overlay\n         * @param i - Current Index\n         * @param id - Gallery ID\n         * @param config - Lightbox Config\n         */\n        open(i = 0, id = 'lightbox', config) {\n            const _config = config ? Object.assign(Object.assign({}, this._config), config) : this._config;\n            const overlayConfig = {\n                backdropClass: _config.backdropClass,\n                panelClass: _config.panelClass,\n                hasBackdrop: _config.hasBackdrop,\n                positionStrategy: this._overlay.position().global().centerHorizontally().centerVertically(),\n                scrollStrategy: this._overlay.scrollStrategies.block(),\n                disposeOnNavigation: true\n            };\n            const galleryRef = this._gallery.ref(id);\n            galleryRef.set(i);\n            this._overlayRef = this._overlay.create(overlayConfig);\n            // overlay opened event\n            this._overlayRef.attachments().subscribe(() => this.opened.next(id));\n            // overlay closed event\n            this._overlayRef.detachments().subscribe(() => this.closed.next(id));\n            // Attach gallery to the overlay\n            const galleryPortal = new ComponentPortal(ng_gallery_lightbox_LightboxComponent);\n            const lightboxRef = this._overlayRef.attach(galleryPortal);\n            lightboxRef.instance.id = id;\n            lightboxRef.instance.overlayRef = this._overlayRef;\n            lightboxRef.instance.closeIcon = this._config.closeIcon;\n            lightboxRef.instance.role = this._config.role;\n            lightboxRef.instance.ariaLabel = this._config.ariaLabel;\n            lightboxRef.instance.ariaLabelledBy = this._config.ariaLabelledBy;\n            lightboxRef.instance.ariaDescribedBy = this._config.ariaDescribedBy;\n            lightboxRef.instance.startAnimationTime = this._config.startAnimationTime;\n            lightboxRef.instance.exitAnimationTime = this._config.exitAnimationTime;\n            if (_config.hasBackdrop) {\n                this._overlayRef.backdropClick().subscribe(() => this.close());\n            }\n            // Add keyboard shortcuts\n            if (_config.keyboardShortcuts) {\n                this._overlayRef.keydownEvents().subscribe((event) => {\n                    switch (event.keyCode) {\n                        case LEFT_ARROW:\n                            galleryRef.prev();\n                            break;\n                        case RIGHT_ARROW:\n                            galleryRef.next();\n                            break;\n                        case ESCAPE:\n                            this.close();\n                    }\n                });\n            }\n        }\n        /**\n         * Close Lightbox Overlay\n         */\n        close() {\n            if (this._overlayRef.hasAttached()) {\n                this._overlayRef.detach();\n            }\n        }\n    }\n    Lightbox.ɵfac = function Lightbox_Factory(t) { return new (t || Lightbox)(core[\"Zb\" /* ɵɵinject */](LIGHTBOX_CONFIG, 8), core[\"Zb\" /* ɵɵinject */](ng_gallery_Gallery), core[\"Zb\" /* ɵɵinject */](overlay_Overlay)); };\n    Lightbox.ɵprov = core[\"Lb\" /* ɵɵdefineInjectable */]({ token: Lightbox, factory: Lightbox.ɵfac });\n    return Lightbox;\n})();\nlet ng_gallery_lightbox_GallerizeDirective = /*@__PURE__*/ (() => {\n    class GallerizeDirective {\n        constructor(_zone, _el, _gallery, _lightbox, _renderer, platform, _document, _galleryCmp) {\n            this._zone = _zone;\n            this._el = _el;\n            this._gallery = _gallery;\n            this._lightbox = _lightbox;\n            this._renderer = _renderer;\n            this._document = _document;\n            this._galleryCmp = _galleryCmp;\n            /** Default gallery id */\n            this._galleryId = 'lightbox';\n            /** The selector used to query images elements */\n            this.selector = 'img';\n            // Set gallerize mode\n            if (Object(common[\"w\" /* isPlatformBrowser */])(platform)) {\n                this._mode = _galleryCmp ? \"gallery\" /* Gallery */ : \"detector\" /* Detector */;\n            }\n        }\n        ngOnInit() {\n            this._zone.runOutsideAngular(() => {\n                this._galleryId = this.gallerize || this._galleryId;\n                const ref = this._gallery.ref(this._galleryId);\n                switch (this._mode) {\n                    case \"detector\" /* Detector */:\n                        this.detectorMode(ref);\n                        break;\n                    case \"gallery\" /* Gallery */:\n                        this.galleryMode(ref);\n                }\n            });\n        }\n        ngOnDestroy() {\n            switch (this._mode) {\n                case \"detector\" /* Detector */:\n                    this._detector$.complete();\n                    this._observer$.disconnect();\n                    break;\n                case \"gallery\" /* Gallery */:\n                    this._itemClick$.unsubscribe();\n                    this._itemChange$.unsubscribe();\n            }\n        }\n        /** Gallery mode: means `gallerize` directive is used on `<gallery>` component\n         * Adds a click event to each gallery item so it opens in lightbox */\n        galleryMode(galleryRef) {\n            // Clone its items to the new gallery instance\n            this._itemClick$ = this._galleryCmp.galleryRef.itemClick.subscribe((i) => this._lightbox.open(i, this._galleryId));\n            this._itemChange$ = this._galleryCmp.galleryRef.itemsChanged.subscribe((state) => galleryRef.load(state.items));\n        }\n        /** Detector mode: means `gallerize` directive is used on a normal HTMLElement\n         *  Detects images and adds a click event to each image so it opens in the lightbox */\n        detectorMode(galleryRef) {\n            this._detector$ = new Subject[\"a\" /* Subject */]();\n            // Query image elements\n            this._detector$.pipe(debounceTime(300), Object(switchMap[\"a\" /* switchMap */])(() => {\n                /** get all img elements from content */\n                const imageElements = this._el.nativeElement.querySelectorAll(this.selector);\n                if (imageElements && imageElements.length) {\n                    const images = [];\n                    return Object(observable_from[\"a\" /* from */])(imageElements).pipe(Object(map[\"a\" /* map */])((el, i) => {\n                        // Add click event to the image\n                        this._renderer.setStyle(el, 'cursor', 'pointer');\n                        this._renderer.setProperty(el, 'onclick', () => this._zone.run(() => this._lightbox.open(i, this._galleryId)));\n                        if (el instanceof HTMLImageElement) {\n                            // If element is type of img use the src property\n                            return {\n                                src: el.getAttribute('imageSrc') || el.src,\n                                thumb: el.getAttribute('thumbSrc') || el.src\n                            };\n                        }\n                        else {\n                            // Otherwise, use element background-image url\n                            const elStyle = el.currentStyle || this._document.defaultView.getComputedStyle(el, null);\n                            const background = elStyle.backgroundImage.slice(4, -1).replace(/\"/g, '');\n                            return {\n                                src: el.getAttribute('imageSrc') || background,\n                                thumb: el.getAttribute('thumbSrc') || background\n                            };\n                        }\n                    }), Object(tap[\"a\" /* tap */])((data) => images.push(new ImageItem(data))), Object(finalize[\"a\" /* finalize */])(() => galleryRef.load(images)));\n                }\n                else {\n                    return empty[\"a\" /* EMPTY */];\n                }\n            })).subscribe();\n            // Observe content changes\n            this._observer$ = new MutationObserver(() => this._detector$.next());\n            this._observer$.observe(this._el.nativeElement, { childList: true, subtree: true });\n        }\n    }\n    GallerizeDirective.ɵfac = function GallerizeDirective_Factory(t) { return new (t || GallerizeDirective)(core[\"Pb\" /* ɵɵdirectiveInject */](core[\"B\" /* NgZone */]), core[\"Pb\" /* ɵɵdirectiveInject */](core[\"m\" /* ElementRef */]), core[\"Pb\" /* ɵɵdirectiveInject */](ng_gallery_Gallery), core[\"Pb\" /* ɵɵdirectiveInject */](ng_gallery_lightbox_Lightbox), core[\"Pb\" /* ɵɵdirectiveInject */](core[\"G\" /* Renderer2 */]), core[\"Pb\" /* ɵɵdirectiveInject */](core[\"D\" /* PLATFORM_ID */]), core[\"Pb\" /* ɵɵdirectiveInject */](common[\"e\" /* DOCUMENT */]), core[\"Pb\" /* ɵɵdirectiveInject */](ng_gallery_GalleryComponent, 11)); };\n    GallerizeDirective.ɵdir = core[\"Kb\" /* ɵɵdefineDirective */]({ type: GallerizeDirective, selectors: [[\"\", \"gallerize\", \"\"]], inputs: { selector: \"selector\", gallerize: \"gallerize\" } });\n    return GallerizeDirective;\n})();\nlet ng_gallery_lightbox_LightboxDirective = /*@__PURE__*/ (() => {\n    class LightboxDirective {\n        constructor(_lightbox, _el, _renderer) {\n            this._lightbox = _lightbox;\n            this._el = _el;\n            this._renderer = _renderer;\n            this.clickEvent = Subscription[\"a\" /* Subscription */].EMPTY;\n            this.index = 0;\n            this.id = 'root';\n        }\n        ngOnInit() {\n            this._renderer.setStyle(this._el.nativeElement, 'cursor', 'pointer');\n            this.clickEvent = Object(fromEvent[\"a\" /* fromEvent */])(this._el.nativeElement, 'click').pipe(Object(tap[\"a\" /* tap */])(() => this._lightbox.open(this.index, this.id))).subscribe();\n        }\n        ngOnDestroy() {\n            this.clickEvent.unsubscribe();\n        }\n    }\n    LightboxDirective.ɵfac = function LightboxDirective_Factory(t) { return new (t || LightboxDirective)(core[\"Pb\" /* ɵɵdirectiveInject */](ng_gallery_lightbox_Lightbox), core[\"Pb\" /* ɵɵdirectiveInject */](core[\"m\" /* ElementRef */]), core[\"Pb\" /* ɵɵdirectiveInject */](core[\"G\" /* Renderer2 */])); };\n    LightboxDirective.ɵdir = core[\"Kb\" /* ɵɵdefineDirective */]({ type: LightboxDirective, selectors: [[\"\", \"lightbox\", \"\"]], inputs: { index: [\"lightbox\", \"index\"], id: [\"gallery\", \"id\"] } });\n    return LightboxDirective;\n})();\nlet ng_gallery_lightbox_LightboxModule = /*@__PURE__*/ (() => {\n    class LightboxModule {\n        static withConfig(config) {\n            return {\n                ngModule: LightboxModule,\n                providers: [\n                    {\n                        provide: LIGHTBOX_CONFIG,\n                        useValue: config\n                    }\n                ]\n            };\n        }\n    }\n    LightboxModule.ɵmod = core[\"Nb\" /* ɵɵdefineNgModule */]({ type: LightboxModule });\n    LightboxModule.ɵinj = core[\"Mb\" /* ɵɵdefineInjector */]({ factory: function LightboxModule_Factory(t) { return new (t || LightboxModule)(); }, providers: [\n            ng_gallery_lightbox_Lightbox\n        ], imports: [[\n                overlay_OverlayModule,\n                ng_gallery_GalleryModule,\n                a11y_A11yModule\n            ]] });\n    return LightboxModule;\n})();\n(function () {\n    (typeof ngJitMode === \"undefined\" || ngJitMode) && core[\"Ac\" /* ɵɵsetNgModuleScope */](ng_gallery_lightbox_LightboxModule, { declarations: function () { return [ng_gallery_lightbox_LightboxComponent, ng_gallery_lightbox_LightboxDirective, ng_gallery_lightbox_GallerizeDirective]; }, imports: function () {\n            return [overlay_OverlayModule,\n                ng_gallery_GalleryModule,\n                a11y_A11yModule];\n        }, exports: function () { return [ng_gallery_lightbox_LightboxDirective, ng_gallery_lightbox_GallerizeDirective]; } });\n})();\n/**\n * Generated bundle index. Do not edit.\n */\n\n//# sourceMappingURL=ng-gallery-lightbox.js.map\n\n// EXTERNAL MODULE: ./node_modules/@ionic-native/social-sharing/__ivy_ngcc__/ngx/index.js\nvar ngx = __webpack_require__(\"/XPu\");\n\n// EXTERNAL MODULE: ./src/app/components/empty-view/empty-view.ts\nvar empty_view = __webpack_require__(\"4ro/\");\n\n// EXTERNAL MODULE: ./node_modules/ngx-skeleton-loader/__ivy_ngcc__/fesm2015/ngx-skeleton-loader.js + 4 modules\nvar ngx_skeleton_loader = __webpack_require__(\"xJkR\");\n\n// EXTERNAL MODULE: ./node_modules/ng-lazyload-image/__ivy_ngcc__/fesm2015/ng-lazyload-image.js + 1 modules\nvar ng_lazyload_image = __webpack_require__(\"wf0l\");\n\n// CONCATENATED MODULE: ./src/app/pages/place-detail/place-detail.ts\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nconst place_detail_c0 = [\"itemGalleryTemplate\"];\r\nfunction PlaceDetailPage_empty_view_13_Template(rf, ctx) {\r\n    if (rf & 1) {\r\n        core[\"Qb\" /* ɵɵelement */](0, \"empty-view\", 24);\r\n        core[\"gc\" /* ɵɵpipe */](1, \"translate\");\r\n    }\r\n    if (rf & 2) {\r\n        core[\"lc\" /* ɵɵproperty */](\"text\", core[\"hc\" /* ɵɵpipeBind1 */](1, 1, \"EMPTY_DATA\"));\r\n    }\r\n}\r\nfunction PlaceDetailPage_empty_view_14_Template(rf, ctx) {\r\n    if (rf & 1) {\r\n        core[\"Qb\" /* ɵɵelement */](0, \"empty-view\", 24);\r\n        core[\"gc\" /* ɵɵpipe */](1, \"translate\");\r\n    }\r\n    if (rf & 2) {\r\n        core[\"lc\" /* ɵɵproperty */](\"text\", core[\"hc\" /* ɵɵpipeBind1 */](1, 1, \"ERROR_NETWORK\"));\r\n    }\r\n}\r\nfunction PlaceDetailPage_ng_template_15_Template(rf, ctx) {\r\n    if (rf & 1) {\r\n        core[\"Tb\" /* ɵɵelementContainerStart */](0);\r\n        core[\"Vb\" /* ɵɵelementStart */](1, \"ion-slides\", 25);\r\n        core[\"Vb\" /* ɵɵelementStart */](2, \"ion-slide\");\r\n        core[\"Vb\" /* ɵɵelementStart */](3, \"div\", 26);\r\n        core[\"Qb\" /* ɵɵelement */](4, \"img\", 27);\r\n        core[\"Ub\" /* ɵɵelementEnd */]();\r\n        core[\"Ub\" /* ɵɵelementEnd */]();\r\n        core[\"Ub\" /* ɵɵelementEnd */]();\r\n        core[\"Sb\" /* ɵɵelementContainerEnd */]();\r\n    }\r\n    if (rf & 2) {\r\n        const data_r9 = ctx.data;\r\n        const ctx_r4 = core[\"fc\" /* ɵɵnextContext */]();\r\n        core[\"Db\" /* ɵɵadvance */](1);\r\n        core[\"lc\" /* ɵɵproperty */](\"options\", ctx_r4.sliderGalleryOpts);\r\n        core[\"Db\" /* ɵɵadvance */](3);\r\n        core[\"lc\" /* ɵɵproperty */](\"src\", data_r9.src, core[\"zc\" /* ɵɵsanitizeUrl */]);\r\n    }\r\n}\r\nconst place_detail_c1 = function () { return { width: \"150px\", height: \"150px\", \"border-radius\": \"4px\" }; };\r\nfunction PlaceDetailPage_section_25_ion_col_2_Template(rf, ctx) {\r\n    if (rf & 1) {\r\n        core[\"Vb\" /* ɵɵelementStart */](0, \"ion-col\", 38);\r\n        core[\"Qb\" /* ɵɵelement */](1, \"ngx-skeleton-loader\", 39);\r\n        core[\"Ub\" /* ɵɵelementEnd */]();\r\n    }\r\n    if (rf & 2) {\r\n        core[\"Db\" /* ɵɵadvance */](1);\r\n        core[\"lc\" /* ɵɵproperty */](\"theme\", core[\"oc\" /* ɵɵpureFunction0 */](1, place_detail_c1));\r\n    }\r\n}\r\nconst place_detail_c2 = function () { return { width: \"80px\", height: \"80px\" }; };\r\nconst place_detail_c3 = function () { return { width: \"30%\", \"border-radius\": \"0\", height: \"15px\", \"margin-bottom\": \"10px\" }; };\r\nconst place_detail_c4 = function () { return { width: \"70%\", \"border-radius\": \"0\", height: \"15px\" }; };\r\nconst _c5 = function () { return { width: \"100px\", height: \"100px\" }; };\r\nfunction PlaceDetailPage_section_25_Template(rf, ctx) {\r\n    if (rf & 1) {\r\n        core[\"Vb\" /* ɵɵelementStart */](0, \"section\", 28);\r\n        core[\"Vb\" /* ɵɵelementStart */](1, \"ion-row\", 29);\r\n        core[\"Ec\" /* ɵɵtemplate */](2, PlaceDetailPage_section_25_ion_col_2_Template, 2, 2, \"ion-col\", 30);\r\n        core[\"Ub\" /* ɵɵelementEnd */]();\r\n        core[\"Vb\" /* ɵɵelementStart */](3, \"div\", 31);\r\n        core[\"Vb\" /* ɵɵelementStart */](4, \"div\", 32);\r\n        core[\"Vb\" /* ɵɵelementStart */](5, \"div\", 33);\r\n        core[\"Qb\" /* ɵɵelement */](6, \"ngx-skeleton-loader\", 34);\r\n        core[\"Ub\" /* ɵɵelementEnd */]();\r\n        core[\"Vb\" /* ɵɵelementStart */](7, \"div\", 35);\r\n        core[\"Vb\" /* ɵɵelementStart */](8, \"div\");\r\n        core[\"Qb\" /* ɵɵelement */](9, \"ngx-skeleton-loader\", 36);\r\n        core[\"Ub\" /* ɵɵelementEnd */]();\r\n        core[\"Vb\" /* ɵɵelementStart */](10, \"div\");\r\n        core[\"Qb\" /* ɵɵelement */](11, \"ngx-skeleton-loader\", 36);\r\n        core[\"Ub\" /* ɵɵelementEnd */]();\r\n        core[\"Ub\" /* ɵɵelementEnd */]();\r\n        core[\"Ub\" /* ɵɵelementEnd */]();\r\n        core[\"Ub\" /* ɵɵelementEnd */]();\r\n        core[\"Vb\" /* ɵɵelementStart */](12, \"ion-row\");\r\n        core[\"Vb\" /* ɵɵelementStart */](13, \"ion-col\", 37);\r\n        core[\"Vb\" /* ɵɵelementStart */](14, \"div\");\r\n        core[\"Qb\" /* ɵɵelement */](15, \"ngx-skeleton-loader\", 34);\r\n        core[\"Ub\" /* ɵɵelementEnd */]();\r\n        core[\"Ub\" /* ɵɵelementEnd */]();\r\n        core[\"Vb\" /* ɵɵelementStart */](16, \"ion-col\", 37);\r\n        core[\"Vb\" /* ɵɵelementStart */](17, \"div\");\r\n        core[\"Qb\" /* ɵɵelement */](18, \"ngx-skeleton-loader\", 34);\r\n        core[\"Ub\" /* ɵɵelementEnd */]();\r\n        core[\"Ub\" /* ɵɵelementEnd */]();\r\n        core[\"Vb\" /* ɵɵelementStart */](19, \"ion-col\", 37);\r\n        core[\"Vb\" /* ɵɵelementStart */](20, \"div\");\r\n        core[\"Qb\" /* ɵɵelement */](21, \"ngx-skeleton-loader\", 34);\r\n        core[\"Ub\" /* ɵɵelementEnd */]();\r\n        core[\"Ub\" /* ɵɵelementEnd */]();\r\n        core[\"Ub\" /* ɵɵelementEnd */]();\r\n        core[\"Ub\" /* ɵɵelementEnd */]();\r\n    }\r\n    if (rf & 2) {\r\n        const ctx_r5 = core[\"fc\" /* ɵɵnextContext */]();\r\n        core[\"Db\" /* ɵɵadvance */](2);\r\n        core[\"lc\" /* ɵɵproperty */](\"ngForOf\", ctx_r5.skeletonImages);\r\n        core[\"Db\" /* ɵɵadvance */](4);\r\n        core[\"lc\" /* ɵɵproperty */](\"theme\", core[\"oc\" /* ɵɵpureFunction0 */](7, place_detail_c2));\r\n        core[\"Db\" /* ɵɵadvance */](3);\r\n        core[\"lc\" /* ɵɵproperty */](\"theme\", core[\"oc\" /* ɵɵpureFunction0 */](8, place_detail_c3));\r\n        core[\"Db\" /* ɵɵadvance */](2);\r\n        core[\"lc\" /* ɵɵproperty */](\"theme\", core[\"oc\" /* ɵɵpureFunction0 */](9, place_detail_c4));\r\n        core[\"Db\" /* ɵɵadvance */](4);\r\n        core[\"lc\" /* ɵɵproperty */](\"theme\", core[\"oc\" /* ɵɵpureFunction0 */](10, _c5));\r\n        core[\"Db\" /* ɵɵadvance */](3);\r\n        core[\"lc\" /* ɵɵproperty */](\"theme\", core[\"oc\" /* ɵɵpureFunction0 */](11, _c5));\r\n        core[\"Db\" /* ɵɵadvance */](3);\r\n        core[\"lc\" /* ɵɵproperty */](\"theme\", core[\"oc\" /* ɵɵpureFunction0 */](12, _c5));\r\n    }\r\n}\r\nfunction PlaceDetailPage_section_26_div_1_Template(rf, ctx) {\r\n    if (rf & 1) {\r\n        core[\"Vb\" /* ɵɵelementStart */](0, \"div\", 41);\r\n        core[\"Vb\" /* ɵɵelementStart */](1, \"div\", 32);\r\n        core[\"Vb\" /* ɵɵelementStart */](2, \"div\", 33);\r\n        core[\"Qb\" /* ɵɵelement */](3, \"ngx-skeleton-loader\", 34);\r\n        core[\"Ub\" /* ɵɵelementEnd */]();\r\n        core[\"Vb\" /* ɵɵelementStart */](4, \"div\", 35);\r\n        core[\"Vb\" /* ɵɵelementStart */](5, \"div\");\r\n        core[\"Qb\" /* ɵɵelement */](6, \"ngx-skeleton-loader\", 36);\r\n        core[\"Ub\" /* ɵɵelementEnd */]();\r\n        core[\"Vb\" /* ɵɵelementStart */](7, \"div\");\r\n        core[\"Qb\" /* ɵɵelement */](8, \"ngx-skeleton-loader\", 36);\r\n        core[\"Ub\" /* ɵɵelementEnd */]();\r\n        core[\"Ub\" /* ɵɵelementEnd */]();\r\n        core[\"Ub\" /* ɵɵelementEnd */]();\r\n        core[\"Ub\" /* ɵɵelementEnd */]();\r\n    }\r\n    if (rf & 2) {\r\n        core[\"Db\" /* ɵɵadvance */](3);\r\n        core[\"lc\" /* ɵɵproperty */](\"theme\", core[\"oc\" /* ɵɵpureFunction0 */](3, place_detail_c2));\r\n        core[\"Db\" /* ɵɵadvance */](3);\r\n        core[\"lc\" /* ɵɵproperty */](\"theme\", core[\"oc\" /* ɵɵpureFunction0 */](4, place_detail_c3));\r\n        core[\"Db\" /* ɵɵadvance */](2);\r\n        core[\"lc\" /* ɵɵproperty */](\"theme\", core[\"oc\" /* ɵɵpureFunction0 */](5, place_detail_c4));\r\n    }\r\n}\r\nfunction PlaceDetailPage_section_26_Template(rf, ctx) {\r\n    if (rf & 1) {\r\n        core[\"Vb\" /* ɵɵelementStart */](0, \"section\");\r\n        core[\"Ec\" /* ɵɵtemplate */](1, PlaceDetailPage_section_26_div_1_Template, 9, 6, \"div\", 40);\r\n        core[\"Ub\" /* ɵɵelementEnd */]();\r\n    }\r\n    if (rf & 2) {\r\n        const ctx_r6 = core[\"fc\" /* ɵɵnextContext */]();\r\n        core[\"Db\" /* ɵɵadvance */](1);\r\n        core[\"lc\" /* ɵɵproperty */](\"ngForOf\", ctx_r6.skeletonReviews);\r\n    }\r\n}\r\nfunction PlaceDetailPage_section_27_ion_slide_5_Template(rf, ctx) {\r\n    if (rf & 1) {\r\n        core[\"Vb\" /* ɵɵelementStart */](0, \"ion-slide\");\r\n        core[\"Qb\" /* ɵɵelement */](1, \"div\", 58);\r\n        core[\"Ub\" /* ɵɵelementEnd */]();\r\n    }\r\n    if (rf & 2) {\r\n        const image_r18 = ctx.$implicit;\r\n        const ctx_r14 = core[\"fc\" /* ɵɵnextContext */](2);\r\n        core[\"Db\" /* ɵɵadvance */](1);\r\n        core[\"lc\" /* ɵɵproperty */](\"lazyLoad\", image_r18.url())(\"customObservable\", ctx_r14.loadAndScroll);\r\n        core[\"Eb\" /* ɵɵattribute */](\"imageSrc\", image_r18.url())(\"thumbSrc\", image_r18.url());\r\n    }\r\n}\r\nfunction PlaceDetailPage_section_27_ion_thumbnail_8_Template(rf, ctx) {\r\n    if (rf & 1) {\r\n        core[\"Vb\" /* ɵɵelementStart */](0, \"ion-thumbnail\", 59);\r\n        core[\"Qb\" /* ɵɵelement */](1, \"img\", 60);\r\n        core[\"Ub\" /* ɵɵelementEnd */]();\r\n    }\r\n    if (rf & 2) {\r\n        const ctx_r15 = core[\"fc\" /* ɵɵnextContext */](2);\r\n        core[\"Db\" /* ɵɵadvance */](1);\r\n        core[\"lc\" /* ɵɵproperty */](\"alt\", ctx_r15.place.title)(\"lazyLoad\", ctx_r15.place == null ? null : ctx_r15.place.imageThumb == null ? null : ctx_r15.place.imageThumb.url())(\"customObservable\", ctx_r15.loadAndScroll);\r\n    }\r\n}\r\nfunction PlaceDetailPage_section_27_bar_rating_21_Template(rf, ctx) {\r\n    if (rf & 1) {\r\n        core[\"Qb\" /* ɵɵelement */](0, \"bar-rating\", 61);\r\n    }\r\n    if (rf & 2) {\r\n        const ctx_r16 = core[\"fc\" /* ɵɵnextContext */](2);\r\n        core[\"lc\" /* ɵɵproperty */](\"rate\", ctx_r16.place.ratingAvg)(\"readOnly\", true)(\"max\", 5)(\"theme\", \"stars\");\r\n    }\r\n}\r\nfunction PlaceDetailPage_section_27_div_26_Template(rf, ctx) {\r\n    if (rf & 1) {\r\n        const _r20 = core[\"Wb\" /* ɵɵgetCurrentView */]();\r\n        core[\"Vb\" /* ɵɵelementStart */](0, \"div\", 62);\r\n        core[\"dc\" /* ɵɵlistener */](\"click\", function PlaceDetailPage_section_27_div_26_Template_div_click_0_listener($event) { core[\"vc\" /* ɵɵrestoreView */](_r20); const ctx_r19 = core[\"fc\" /* ɵɵnextContext */](2); return ctx_r19.onContentTouched($event); });\r\n        core[\"Ub\" /* ɵɵelementEnd */]();\r\n    }\r\n    if (rf & 2) {\r\n        const ctx_r17 = core[\"fc\" /* ɵɵnextContext */](2);\r\n        core[\"lc\" /* ɵɵproperty */](\"innerHTML\", ctx_r17.description, core[\"wc\" /* ɵɵsanitizeHtml */]);\r\n    }\r\n}\r\nfunction PlaceDetailPage_section_27_Template(rf, ctx) {\r\n    if (rf & 1) {\r\n        const _r22 = core[\"Wb\" /* ɵɵgetCurrentView */]();\r\n        core[\"Vb\" /* ɵɵelementStart */](0, \"section\");\r\n        core[\"Vb\" /* ɵɵelementStart */](1, \"ion-row\");\r\n        core[\"Vb\" /* ɵɵelementStart */](2, \"ion-col\", 42);\r\n        core[\"Vb\" /* ɵɵelementStart */](3, \"div\", 43);\r\n        core[\"Vb\" /* ɵɵelementStart */](4, \"ion-slides\", 44);\r\n        core[\"dc\" /* ɵɵlistener */](\"ionSlidesDidLoad\", function PlaceDetailPage_section_27_Template_ion_slides_ionSlidesDidLoad_4_listener() { core[\"vc\" /* ɵɵrestoreView */](_r22); const ctx_r21 = core[\"fc\" /* ɵɵnextContext */](); return ctx_r21.onSlidesDidLoad(); })(\"ionSlideDrag\", function PlaceDetailPage_section_27_Template_ion_slides_ionSlideDrag_4_listener() { core[\"vc\" /* ɵɵrestoreView */](_r22); const ctx_r23 = core[\"fc\" /* ɵɵnextContext */](); return ctx_r23.onSlidesDrag(); });\r\n        core[\"Ec\" /* ɵɵtemplate */](5, PlaceDetailPage_section_27_ion_slide_5_Template, 2, 4, \"ion-slide\", 45);\r\n        core[\"Ub\" /* ɵɵelementEnd */]();\r\n        core[\"Vb\" /* ɵɵelementStart */](6, \"div\", 46);\r\n        core[\"Vb\" /* ɵɵelementStart */](7, \"ion-item\", 47);\r\n        core[\"Ec\" /* ɵɵtemplate */](8, PlaceDetailPage_section_27_ion_thumbnail_8_Template, 2, 3, \"ion-thumbnail\", 48);\r\n        core[\"Vb\" /* ɵɵelementStart */](9, \"ion-label\", 49);\r\n        core[\"Vb\" /* ɵɵelementStart */](10, \"ion-text\", 50);\r\n        core[\"Vb\" /* ɵɵelementStart */](11, \"h2\", 51);\r\n        core[\"Gc\" /* ɵɵtext */](12);\r\n        core[\"Ub\" /* ɵɵelementEnd */]();\r\n        core[\"Ub\" /* ɵɵelementEnd */]();\r\n        core[\"Vb\" /* ɵɵelementStart */](13, \"div\", 49);\r\n        core[\"Vb\" /* ɵɵelementStart */](14, \"ion-text\", 52);\r\n        core[\"Vb\" /* ɵɵelementStart */](15, \"p\");\r\n        core[\"Vb\" /* ɵɵelementStart */](16, \"span\", 53);\r\n        core[\"Gc\" /* ɵɵtext */](17);\r\n        core[\"Ub\" /* ɵɵelementEnd */]();\r\n        core[\"Vb\" /* ɵɵelementStart */](18, \"span\", 54);\r\n        core[\"Gc\" /* ɵɵtext */](19);\r\n        core[\"Ub\" /* ɵɵelementEnd */]();\r\n        core[\"Ub\" /* ɵɵelementEnd */]();\r\n        core[\"Ub\" /* ɵɵelementEnd */]();\r\n        core[\"Ub\" /* ɵɵelementEnd */]();\r\n        core[\"Vb\" /* ɵɵelementStart */](20, \"div\");\r\n        core[\"Ec\" /* ɵɵtemplate */](21, PlaceDetailPage_section_27_bar_rating_21_Template, 1, 4, \"bar-rating\", 55);\r\n        core[\"Ub\" /* ɵɵelementEnd */]();\r\n        core[\"Ub\" /* ɵɵelementEnd */]();\r\n        core[\"Ub\" /* ɵɵelementEnd */]();\r\n        core[\"Vb\" /* ɵɵelementStart */](22, \"div\", 56);\r\n        core[\"Vb\" /* ɵɵelementStart */](23, \"ion-text\", 52);\r\n        core[\"Vb\" /* ɵɵelementStart */](24, \"p\", 54);\r\n        core[\"Gc\" /* ɵɵtext */](25);\r\n        core[\"Ub\" /* ɵɵelementEnd */]();\r\n        core[\"Ub\" /* ɵɵelementEnd */]();\r\n        core[\"Ub\" /* ɵɵelementEnd */]();\r\n        core[\"Ub\" /* ɵɵelementEnd */]();\r\n        core[\"Ub\" /* ɵɵelementEnd */]();\r\n        core[\"Ub\" /* ɵɵelementEnd */]();\r\n        core[\"Ub\" /* ɵɵelementEnd */]();\r\n        core[\"Ec\" /* ɵɵtemplate */](26, PlaceDetailPage_section_27_div_26_Template, 1, 1, \"div\", 57);\r\n        core[\"Ub\" /* ɵɵelementEnd */]();\r\n    }\r\n    if (rf & 2) {\r\n        const ctx_r7 = core[\"fc\" /* ɵɵnextContext */]();\r\n        core[\"Db\" /* ɵɵadvance */](4);\r\n        core[\"lc\" /* ɵɵproperty */](\"options\", ctx_r7.slidesConfig);\r\n        core[\"Db\" /* ɵɵadvance */](1);\r\n        core[\"lc\" /* ɵɵproperty */](\"ngForOf\", ctx_r7.images);\r\n        core[\"Db\" /* ɵɵadvance */](3);\r\n        core[\"lc\" /* ɵɵproperty */](\"ngIf\", ctx_r7.place == null ? null : ctx_r7.place.imageThumb);\r\n        core[\"Db\" /* ɵɵadvance */](4);\r\n        core[\"Ic\" /* ɵɵtextInterpolate1 */](\" \", ctx_r7.place == null ? null : ctx_r7.place.title, \" \");\r\n        core[\"Db\" /* ɵɵadvance */](5);\r\n        core[\"Ic\" /* ɵɵtextInterpolate1 */](\" \", ctx_r7.place.categories.join(\" \\u2022 \"), \" \");\r\n        core[\"Db\" /* ɵɵadvance */](1);\r\n        core[\"Hb\" /* ɵɵclassProp */](\"hidden\", !ctx_r7.location && !ctx_r7.preference.unit);\r\n        core[\"Db\" /* ɵɵadvance */](1);\r\n        core[\"Ic\" /* ɵɵtextInterpolate1 */](\" - \", ctx_r7.place == null ? null : ctx_r7.place.distance(ctx_r7.location, ctx_r7.preference.unit), \" \");\r\n        core[\"Db\" /* ɵɵadvance */](2);\r\n        core[\"lc\" /* ɵɵproperty */](\"ngIf\", ctx_r7.place.ratingAvg);\r\n        core[\"Db\" /* ɵɵadvance */](4);\r\n        core[\"Hc\" /* ɵɵtextInterpolate */](ctx_r7.place == null ? null : ctx_r7.place.description);\r\n        core[\"Db\" /* ɵɵadvance */](1);\r\n        core[\"lc\" /* ɵɵproperty */](\"ngIf\", ctx_r7.description);\r\n    }\r\n}\r\nfunction PlaceDetailPage_section_28_ion_col_2_div_12_Template(rf, ctx) {\r\n    if (rf & 1) {\r\n        core[\"Vb\" /* ɵɵelementStart */](0, \"div\", 84);\r\n        core[\"Vb\" /* ɵɵelementStart */](1, \"div\", 85);\r\n        core[\"Vb\" /* ɵɵelementStart */](2, \"ion-text\", 52);\r\n        core[\"Vb\" /* ɵɵelementStart */](3, \"p\", 86);\r\n        core[\"Gc\" /* ɵɵtext */](4);\r\n        core[\"gc\" /* ɵɵpipe */](5, \"translate\");\r\n        core[\"Ub\" /* ɵɵelementEnd */]();\r\n        core[\"Ub\" /* ɵɵelementEnd */]();\r\n        core[\"Ub\" /* ɵɵelementEnd */]();\r\n        core[\"Ub\" /* ɵɵelementEnd */]();\r\n    }\r\n    if (rf & 2) {\r\n        core[\"Db\" /* ɵɵadvance */](4);\r\n        core[\"Ic\" /* ɵɵtextInterpolate1 */](\" \", core[\"hc\" /* ɵɵpipeBind1 */](5, 1, \"EMPTY_REVIEWS\"), \" \");\r\n    }\r\n}\r\nfunction PlaceDetailPage_section_28_ion_col_2_div_14_Template(rf, ctx) {\r\n    if (rf & 1) {\r\n        core[\"Vb\" /* ɵɵelementStart */](0, \"div\", 87);\r\n        core[\"Vb\" /* ɵɵelementStart */](1, \"ion-item\", 88);\r\n        core[\"Vb\" /* ɵɵelementStart */](2, \"ion-avatar\", 2);\r\n        core[\"Qb\" /* ɵɵelement */](3, \"img\", 89);\r\n        core[\"Ub\" /* ɵɵelementEnd */]();\r\n        core[\"Vb\" /* ɵɵelementStart */](4, \"ion-label\", 90);\r\n        core[\"Vb\" /* ɵɵelementStart */](5, \"ion-text\", 91);\r\n        core[\"Vb\" /* ɵɵelementStart */](6, \"span\", 92);\r\n        core[\"Gc\" /* ɵɵtext */](7);\r\n        core[\"gc\" /* ɵɵpipe */](8, \"date\");\r\n        core[\"Ub\" /* ɵɵelementEnd */]();\r\n        core[\"Ub\" /* ɵɵelementEnd */]();\r\n        core[\"Vb\" /* ɵɵelementStart */](9, \"ion-text\", 50);\r\n        core[\"Vb\" /* ɵɵelementStart */](10, \"h3\", 93);\r\n        core[\"Gc\" /* ɵɵtext */](11);\r\n        core[\"Ub\" /* ɵɵelementEnd */]();\r\n        core[\"Ub\" /* ɵɵelementEnd */]();\r\n        core[\"Qb\" /* ɵɵelement */](12, \"bar-rating\", 61);\r\n        core[\"Vb\" /* ɵɵelementStart */](13, \"ion-text\", 50);\r\n        core[\"Vb\" /* ɵɵelementStart */](14, \"p\", 94);\r\n        core[\"Gc\" /* ɵɵtext */](15);\r\n        core[\"Ub\" /* ɵɵelementEnd */]();\r\n        core[\"Ub\" /* ɵɵelementEnd */]();\r\n        core[\"Ub\" /* ɵɵelementEnd */]();\r\n        core[\"Ub\" /* ɵɵelementEnd */]();\r\n        core[\"Ub\" /* ɵɵelementEnd */]();\r\n    }\r\n    if (rf & 2) {\r\n        const review_r34 = ctx.$implicit;\r\n        const ctx_r32 = core[\"fc\" /* ɵɵnextContext */](3);\r\n        core[\"Db\" /* ɵɵadvance */](3);\r\n        core[\"lc\" /* ɵɵproperty */](\"alt\", review_r34.user == null ? null : review_r34.user.name)(\"lazyLoad\", review_r34.user == null ? null : review_r34.user.photo == null ? null : review_r34.user.photo.url())(\"customObservable\", ctx_r32.loadAndScroll);\r\n        core[\"Db\" /* ɵɵadvance */](4);\r\n        core[\"Ic\" /* ɵɵtextInterpolate1 */](\" \", core[\"ic\" /* ɵɵpipeBind2 */](8, 10, review_r34.createdAt, \"mediumDate\"), \" \");\r\n        core[\"Db\" /* ɵɵadvance */](4);\r\n        core[\"Hc\" /* ɵɵtextInterpolate */](review_r34.user == null ? null : review_r34.user.name);\r\n        core[\"Db\" /* ɵɵadvance */](1);\r\n        core[\"lc\" /* ɵɵproperty */](\"rate\", review_r34.rating)(\"readOnly\", true)(\"max\", 5)(\"theme\", \"stars\");\r\n        core[\"Db\" /* ɵɵadvance */](3);\r\n        core[\"Hc\" /* ɵɵtextInterpolate */](review_r34.comment);\r\n    }\r\n}\r\nconst _c6 = function () { return [\"./reviews\"]; };\r\nfunction PlaceDetailPage_section_28_ion_col_2_div_15_Template(rf, ctx) {\r\n    if (rf & 1) {\r\n        core[\"Vb\" /* ɵɵelementStart */](0, \"div\", 70);\r\n        core[\"Vb\" /* ɵɵelementStart */](1, \"ion-button\", 95);\r\n        core[\"Gc\" /* ɵɵtext */](2);\r\n        core[\"gc\" /* ɵɵpipe */](3, \"translate\");\r\n        core[\"Qb\" /* ɵɵelement */](4, \"ion-icon\", 96);\r\n        core[\"Ub\" /* ɵɵelementEnd */]();\r\n        core[\"Ub\" /* ɵɵelementEnd */]();\r\n    }\r\n    if (rf & 2) {\r\n        core[\"Db\" /* ɵɵadvance */](1);\r\n        core[\"lc\" /* ɵɵproperty */](\"routerLink\", core[\"oc\" /* ɵɵpureFunction0 */](4, _c6));\r\n        core[\"Db\" /* ɵɵadvance */](1);\r\n        core[\"Ic\" /* ɵɵtextInterpolate1 */](\" \", core[\"hc\" /* ɵɵpipeBind1 */](3, 2, \"VIEW_ALL_REVIEWS\"), \" \");\r\n    }\r\n}\r\nfunction PlaceDetailPage_section_28_ion_col_2_Template(rf, ctx) {\r\n    if (rf & 1) {\r\n        const _r36 = core[\"Wb\" /* ɵɵgetCurrentView */]();\r\n        core[\"Vb\" /* ɵɵelementStart */](0, \"ion-col\", 73);\r\n        core[\"Vb\" /* ɵɵelementStart */](1, \"div\", 28);\r\n        core[\"Vb\" /* ɵɵelementStart */](2, \"ion-row\", 74);\r\n        core[\"Vb\" /* ɵɵelementStart */](3, \"ion-col\", 75);\r\n        core[\"Vb\" /* ɵɵelementStart */](4, \"h5\", 76);\r\n        core[\"Qb\" /* ɵɵelement */](5, \"ion-icon\", 77);\r\n        core[\"Gc\" /* ɵɵtext */](6);\r\n        core[\"gc\" /* ɵɵpipe */](7, \"translate\");\r\n        core[\"Ub\" /* ɵɵelementEnd */]();\r\n        core[\"Ub\" /* ɵɵelementEnd */]();\r\n        core[\"Vb\" /* ɵɵelementStart */](8, \"ion-col\", 78);\r\n        core[\"Vb\" /* ɵɵelementStart */](9, \"ion-button\", 79);\r\n        core[\"dc\" /* ɵɵlistener */](\"click\", function PlaceDetailPage_section_28_ion_col_2_Template_ion_button_click_9_listener() { core[\"vc\" /* ɵɵrestoreView */](_r36); const ctx_r35 = core[\"fc\" /* ɵɵnextContext */](2); return ctx_r35.onRate(); });\r\n        core[\"Gc\" /* ɵɵtext */](10);\r\n        core[\"gc\" /* ɵɵpipe */](11, \"translate\");\r\n        core[\"Ub\" /* ɵɵelementEnd */]();\r\n        core[\"Ub\" /* ɵɵelementEnd */]();\r\n        core[\"Ub\" /* ɵɵelementEnd */]();\r\n        core[\"Ec\" /* ɵɵtemplate */](12, PlaceDetailPage_section_28_ion_col_2_div_12_Template, 6, 3, \"div\", 80);\r\n        core[\"Vb\" /* ɵɵelementStart */](13, \"ion-list\", 81);\r\n        core[\"Ec\" /* ɵɵtemplate */](14, PlaceDetailPage_section_28_ion_col_2_div_14_Template, 16, 13, \"div\", 82);\r\n        core[\"Ub\" /* ɵɵelementEnd */]();\r\n        core[\"Ec\" /* ɵɵtemplate */](15, PlaceDetailPage_section_28_ion_col_2_div_15_Template, 5, 5, \"div\", 83);\r\n        core[\"Ub\" /* ɵɵelementEnd */]();\r\n        core[\"Ub\" /* ɵɵelementEnd */]();\r\n    }\r\n    if (rf & 2) {\r\n        const ctx_r24 = core[\"fc\" /* ɵɵnextContext */](2);\r\n        core[\"Db\" /* ɵɵadvance */](6);\r\n        core[\"Ic\" /* ɵɵtextInterpolate1 */](\" \", core[\"hc\" /* ɵɵpipeBind1 */](7, 5, \"REVIEWS\"), \" \");\r\n        core[\"Db\" /* ɵɵadvance */](4);\r\n        core[\"Ic\" /* ɵɵtextInterpolate1 */](\" \", core[\"hc\" /* ɵɵpipeBind1 */](11, 7, \"POST_REVIEW\"), \" \");\r\n        core[\"Db\" /* ɵɵadvance */](2);\r\n        core[\"lc\" /* ɵɵproperty */](\"ngIf\", !ctx_r24.reviews.length);\r\n        core[\"Db\" /* ɵɵadvance */](2);\r\n        core[\"lc\" /* ɵɵproperty */](\"ngForOf\", ctx_r24.reviews);\r\n        core[\"Db\" /* ɵɵadvance */](1);\r\n        core[\"lc\" /* ɵɵproperty */](\"ngIf\", ctx_r24.reviews.length);\r\n    }\r\n}\r\nfunction PlaceDetailPage_section_28_ion_item_7_Template(rf, ctx) {\r\n    if (rf & 1) {\r\n        const _r38 = core[\"Wb\" /* ɵɵgetCurrentView */]();\r\n        core[\"Vb\" /* ɵɵelementStart */](0, \"ion-item\", 88);\r\n        core[\"Qb\" /* ɵɵelement */](1, \"ion-icon\", 97);\r\n        core[\"Vb\" /* ɵɵelementStart */](2, \"ion-label\", 90);\r\n        core[\"Vb\" /* ɵɵelementStart */](3, \"span\", 86);\r\n        core[\"Gc\" /* ɵɵtext */](4);\r\n        core[\"Ub\" /* ɵɵelementEnd */]();\r\n        core[\"Vb\" /* ɵɵelementStart */](5, \"ion-label\", 98);\r\n        core[\"Vb\" /* ɵɵelementStart */](6, \"span\", 99);\r\n        core[\"dc\" /* ɵɵlistener */](\"click\", function PlaceDetailPage_section_28_ion_item_7_Template_span_click_6_listener() { core[\"vc\" /* ɵɵrestoreView */](_r38); const ctx_r37 = core[\"fc\" /* ɵɵnextContext */](2); return ctx_r37.onDirectionsButtonTouched(); });\r\n        core[\"Gc\" /* ɵɵtext */](7);\r\n        core[\"gc\" /* ɵɵpipe */](8, \"translate\");\r\n        core[\"Ub\" /* ɵɵelementEnd */]();\r\n        core[\"Ub\" /* ɵɵelementEnd */]();\r\n        core[\"Ub\" /* ɵɵelementEnd */]();\r\n        core[\"Ub\" /* ɵɵelementEnd */]();\r\n    }\r\n    if (rf & 2) {\r\n        const ctx_r25 = core[\"fc\" /* ɵɵnextContext */](2);\r\n        core[\"Db\" /* ɵɵadvance */](4);\r\n        core[\"Hc\" /* ɵɵtextInterpolate */](ctx_r25.place == null ? null : ctx_r25.place.address);\r\n        core[\"Db\" /* ɵɵadvance */](3);\r\n        core[\"Ic\" /* ɵɵtextInterpolate1 */](\" \", core[\"hc\" /* ɵɵpipeBind1 */](8, 2, \"GET_DIRECTIONS\"), \" \");\r\n    }\r\n}\r\nfunction PlaceDetailPage_section_28_ion_item_8_Template(rf, ctx) {\r\n    if (rf & 1) {\r\n        const _r40 = core[\"Wb\" /* ɵɵgetCurrentView */]();\r\n        core[\"Vb\" /* ɵɵelementStart */](0, \"ion-item\", 100);\r\n        core[\"dc\" /* ɵɵlistener */](\"click\", function PlaceDetailPage_section_28_ion_item_8_Template_ion_item_click_0_listener() { core[\"vc\" /* ɵɵrestoreView */](_r40); const ctx_r39 = core[\"fc\" /* ɵɵnextContext */](2); return ctx_r39.openUrl(ctx_r39.place.website); });\r\n        core[\"Qb\" /* ɵɵelement */](1, \"ion-icon\", 101);\r\n        core[\"Vb\" /* ɵɵelementStart */](2, \"ion-label\");\r\n        core[\"Vb\" /* ɵɵelementStart */](3, \"ion-text\", 98);\r\n        core[\"Vb\" /* ɵɵelementStart */](4, \"span\", 102);\r\n        core[\"Gc\" /* ɵɵtext */](5);\r\n        core[\"Ub\" /* ɵɵelementEnd */]();\r\n        core[\"Ub\" /* ɵɵelementEnd */]();\r\n        core[\"Ub\" /* ɵɵelementEnd */]();\r\n        core[\"Ub\" /* ɵɵelementEnd */]();\r\n    }\r\n    if (rf & 2) {\r\n        const ctx_r26 = core[\"fc\" /* ɵɵnextContext */](2);\r\n        core[\"Db\" /* ɵɵadvance */](5);\r\n        core[\"Hc\" /* ɵɵtextInterpolate */](ctx_r26.place == null ? null : ctx_r26.place.website);\r\n    }\r\n}\r\nfunction PlaceDetailPage_section_28_ion_item_9_Template(rf, ctx) {\r\n    if (rf & 1) {\r\n        const _r42 = core[\"Wb\" /* ɵɵgetCurrentView */]();\r\n        core[\"Vb\" /* ɵɵelementStart */](0, \"ion-item\", 100);\r\n        core[\"dc\" /* ɵɵlistener */](\"click\", function PlaceDetailPage_section_28_ion_item_9_Template_ion_item_click_0_listener() { core[\"vc\" /* ɵɵrestoreView */](_r42); const ctx_r41 = core[\"fc\" /* ɵɵnextContext */](2); return ctx_r41.onCall(); });\r\n        core[\"Qb\" /* ɵɵelement */](1, \"ion-icon\", 103);\r\n        core[\"Vb\" /* ɵɵelementStart */](2, \"ion-label\");\r\n        core[\"Vb\" /* ɵɵelementStart */](3, \"ion-text\", 98);\r\n        core[\"Vb\" /* ɵɵelementStart */](4, \"span\", 102);\r\n        core[\"Gc\" /* ɵɵtext */](5);\r\n        core[\"Ub\" /* ɵɵelementEnd */]();\r\n        core[\"Ub\" /* ɵɵelementEnd */]();\r\n        core[\"Ub\" /* ɵɵelementEnd */]();\r\n        core[\"Ub\" /* ɵɵelementEnd */]();\r\n    }\r\n    if (rf & 2) {\r\n        const ctx_r27 = core[\"fc\" /* ɵɵnextContext */](2);\r\n        core[\"Db\" /* ɵɵadvance */](5);\r\n        core[\"Hc\" /* ɵɵtextInterpolate */](ctx_r27.place == null ? null : ctx_r27.place.phone);\r\n    }\r\n}\r\nfunction PlaceDetailPage_section_28_ion_item_10_Template(rf, ctx) {\r\n    if (rf & 1) {\r\n        const _r44 = core[\"Wb\" /* ɵɵgetCurrentView */]();\r\n        core[\"Vb\" /* ɵɵelementStart */](0, \"ion-item\", 100);\r\n        core[\"dc\" /* ɵɵlistener */](\"click\", function PlaceDetailPage_section_28_ion_item_10_Template_ion_item_click_0_listener() { core[\"vc\" /* ɵɵrestoreView */](_r44); const ctx_r43 = core[\"fc\" /* ɵɵnextContext */](2); return ctx_r43.openUrl(ctx_r43.place.facebook); });\r\n        core[\"Qb\" /* ɵɵelement */](1, \"ion-icon\", 104);\r\n        core[\"Vb\" /* ɵɵelementStart */](2, \"ion-label\");\r\n        core[\"Vb\" /* ɵɵelementStart */](3, \"ion-text\", 98);\r\n        core[\"Vb\" /* ɵɵelementStart */](4, \"span\", 102);\r\n        core[\"Gc\" /* ɵɵtext */](5);\r\n        core[\"Ub\" /* ɵɵelementEnd */]();\r\n        core[\"Ub\" /* ɵɵelementEnd */]();\r\n        core[\"Ub\" /* ɵɵelementEnd */]();\r\n        core[\"Ub\" /* ɵɵelementEnd */]();\r\n    }\r\n    if (rf & 2) {\r\n        const ctx_r28 = core[\"fc\" /* ɵɵnextContext */](2);\r\n        core[\"Db\" /* ɵɵadvance */](5);\r\n        core[\"Hc\" /* ɵɵtextInterpolate */](ctx_r28.place == null ? null : ctx_r28.place.facebook);\r\n    }\r\n}\r\nfunction PlaceDetailPage_section_28_ion_item_11_Template(rf, ctx) {\r\n    if (rf & 1) {\r\n        const _r46 = core[\"Wb\" /* ɵɵgetCurrentView */]();\r\n        core[\"Vb\" /* ɵɵelementStart */](0, \"ion-item\", 100);\r\n        core[\"dc\" /* ɵɵlistener */](\"click\", function PlaceDetailPage_section_28_ion_item_11_Template_ion_item_click_0_listener() { core[\"vc\" /* ɵɵrestoreView */](_r46); const ctx_r45 = core[\"fc\" /* ɵɵnextContext */](2); return ctx_r45.openUrl(ctx_r45.place.instagram); });\r\n        core[\"Qb\" /* ɵɵelement */](1, \"ion-icon\", 105);\r\n        core[\"Vb\" /* ɵɵelementStart */](2, \"ion-label\");\r\n        core[\"Vb\" /* ɵɵelementStart */](3, \"ion-text\", 98);\r\n        core[\"Vb\" /* ɵɵelementStart */](4, \"span\", 102);\r\n        core[\"Gc\" /* ɵɵtext */](5);\r\n        core[\"Ub\" /* ɵɵelementEnd */]();\r\n        core[\"Ub\" /* ɵɵelementEnd */]();\r\n        core[\"Ub\" /* ɵɵelementEnd */]();\r\n        core[\"Ub\" /* ɵɵelementEnd */]();\r\n    }\r\n    if (rf & 2) {\r\n        const ctx_r29 = core[\"fc\" /* ɵɵnextContext */](2);\r\n        core[\"Db\" /* ɵɵadvance */](5);\r\n        core[\"Hc\" /* ɵɵtextInterpolate */](ctx_r29.place == null ? null : ctx_r29.place.instagram);\r\n    }\r\n}\r\nfunction PlaceDetailPage_section_28_ion_item_12_Template(rf, ctx) {\r\n    if (rf & 1) {\r\n        const _r48 = core[\"Wb\" /* ɵɵgetCurrentView */]();\r\n        core[\"Vb\" /* ɵɵelementStart */](0, \"ion-item\", 100);\r\n        core[\"dc\" /* ɵɵlistener */](\"click\", function PlaceDetailPage_section_28_ion_item_12_Template_ion_item_click_0_listener() { core[\"vc\" /* ɵɵrestoreView */](_r48); const ctx_r47 = core[\"fc\" /* ɵɵnextContext */](2); return ctx_r47.openUrl(ctx_r47.place.youtube); });\r\n        core[\"Qb\" /* ɵɵelement */](1, \"ion-icon\", 106);\r\n        core[\"Vb\" /* ɵɵelementStart */](2, \"ion-label\");\r\n        core[\"Vb\" /* ɵɵelementStart */](3, \"ion-text\", 98);\r\n        core[\"Vb\" /* ɵɵelementStart */](4, \"span\", 102);\r\n        core[\"Gc\" /* ɵɵtext */](5);\r\n        core[\"Ub\" /* ɵɵelementEnd */]();\r\n        core[\"Ub\" /* ɵɵelementEnd */]();\r\n        core[\"Ub\" /* ɵɵelementEnd */]();\r\n        core[\"Ub\" /* ɵɵelementEnd */]();\r\n    }\r\n    if (rf & 2) {\r\n        const ctx_r30 = core[\"fc\" /* ɵɵnextContext */](2);\r\n        core[\"Db\" /* ɵɵadvance */](5);\r\n        core[\"Hc\" /* ɵɵtextInterpolate */](ctx_r30.place == null ? null : ctx_r30.place.youtube);\r\n    }\r\n}\r\nfunction PlaceDetailPage_section_28_Template(rf, ctx) {\r\n    if (rf & 1) {\r\n        const _r50 = core[\"Wb\" /* ɵɵgetCurrentView */]();\r\n        core[\"Vb\" /* ɵɵelementStart */](0, \"section\", 63);\r\n        core[\"Vb\" /* ɵɵelementStart */](1, \"ion-row\");\r\n        core[\"Ec\" /* ɵɵtemplate */](2, PlaceDetailPage_section_28_ion_col_2_Template, 16, 9, \"ion-col\", 64);\r\n        core[\"Vb\" /* ɵɵelementStart */](3, \"ion-col\", 65);\r\n        core[\"Vb\" /* ɵɵelementStart */](4, \"div\", 28);\r\n        core[\"Qb\" /* ɵɵelement */](5, \"img\", 66);\r\n        core[\"Vb\" /* ɵɵelementStart */](6, \"ion-list\", 67);\r\n        core[\"Ec\" /* ɵɵtemplate */](7, PlaceDetailPage_section_28_ion_item_7_Template, 9, 4, \"ion-item\", 68);\r\n        core[\"Ec\" /* ɵɵtemplate */](8, PlaceDetailPage_section_28_ion_item_8_Template, 6, 1, \"ion-item\", 69);\r\n        core[\"Ec\" /* ɵɵtemplate */](9, PlaceDetailPage_section_28_ion_item_9_Template, 6, 1, \"ion-item\", 69);\r\n        core[\"Ec\" /* ɵɵtemplate */](10, PlaceDetailPage_section_28_ion_item_10_Template, 6, 1, \"ion-item\", 69);\r\n        core[\"Ec\" /* ɵɵtemplate */](11, PlaceDetailPage_section_28_ion_item_11_Template, 6, 1, \"ion-item\", 69);\r\n        core[\"Ec\" /* ɵɵtemplate */](12, PlaceDetailPage_section_28_ion_item_12_Template, 6, 1, \"ion-item\", 69);\r\n        core[\"Ub\" /* ɵɵelementEnd */]();\r\n        core[\"Vb\" /* ɵɵelementStart */](13, \"div\", 70);\r\n        core[\"Vb\" /* ɵɵelementStart */](14, \"ion-button\", 71);\r\n        core[\"dc\" /* ɵɵlistener */](\"click\", function PlaceDetailPage_section_28_Template_ion_button_click_14_listener() { core[\"vc\" /* ɵɵrestoreView */](_r50); const ctx_r49 = core[\"fc\" /* ɵɵnextContext */](); return ctx_r49.onReportButtonTouched(); });\r\n        core[\"Vb\" /* ɵɵelementStart */](15, \"span\", 72);\r\n        core[\"Gc\" /* ɵɵtext */](16);\r\n        core[\"gc\" /* ɵɵpipe */](17, \"translate\");\r\n        core[\"Ub\" /* ɵɵelementEnd */]();\r\n        core[\"Ub\" /* ɵɵelementEnd */]();\r\n        core[\"Ub\" /* ɵɵelementEnd */]();\r\n        core[\"Ub\" /* ɵɵelementEnd */]();\r\n        core[\"Ub\" /* ɵɵelementEnd */]();\r\n        core[\"Ub\" /* ɵɵelementEnd */]();\r\n        core[\"Ub\" /* ɵɵelementEnd */]();\r\n    }\r\n    if (rf & 2) {\r\n        const ctx_r8 = core[\"fc\" /* ɵɵnextContext */]();\r\n        core[\"Db\" /* ɵɵadvance */](2);\r\n        core[\"lc\" /* ɵɵproperty */](\"ngIf\", ctx_r8.isReviewsEnabled);\r\n        core[\"Db\" /* ɵɵadvance */](3);\r\n        core[\"nc\" /* ɵɵpropertyInterpolate3 */](\"src\", \"https://maps.googleapis.com/maps/api/staticmap?key=\", ctx_r8.apiKey, \"&markers=color:0xff7676%7C\", ctx_r8.place == null ? null : ctx_r8.place.location.latitude, \",\", ctx_r8.place == null ? null : ctx_r8.place.location.longitude, \"&zoom=17&format=png&size=600x300&zoom=17\", core[\"zc\" /* ɵɵsanitizeUrl */]);\r\n        core[\"Db\" /* ɵɵadvance */](2);\r\n        core[\"lc\" /* ɵɵproperty */](\"ngIf\", ctx_r8.place == null ? null : ctx_r8.place.address);\r\n        core[\"Db\" /* ɵɵadvance */](1);\r\n        core[\"lc\" /* ɵɵproperty */](\"ngIf\", ctx_r8.place == null ? null : ctx_r8.place.website);\r\n        core[\"Db\" /* ɵɵadvance */](1);\r\n        core[\"lc\" /* ɵɵproperty */](\"ngIf\", ctx_r8.place == null ? null : ctx_r8.place.phone);\r\n        core[\"Db\" /* ɵɵadvance */](1);\r\n        core[\"lc\" /* ɵɵproperty */](\"ngIf\", ctx_r8.place == null ? null : ctx_r8.place.facebook);\r\n        core[\"Db\" /* ɵɵadvance */](1);\r\n        core[\"lc\" /* ɵɵproperty */](\"ngIf\", ctx_r8.place == null ? null : ctx_r8.place.instagram);\r\n        core[\"Db\" /* ɵɵadvance */](1);\r\n        core[\"lc\" /* ɵɵproperty */](\"ngIf\", ctx_r8.place == null ? null : ctx_r8.place.youtube);\r\n        core[\"Db\" /* ɵɵadvance */](4);\r\n        core[\"Ic\" /* ɵɵtextInterpolate1 */](\" \", core[\"hc\" /* ɵɵpipeBind1 */](17, 11, \"REPORT_LISTING\"), \" \");\r\n    }\r\n}\r\nlet place_detail_PlaceDetailPage = /*@__PURE__*/ (() => {\r\n    class PlaceDetailPage extends base_page[\"a\" /* BasePage */] {\r\n        constructor(injector, placeService, sanitizer, geolocationService, reviewService, gallery, localStorage, appConfigService, lightboxService, zone, socialSharing) {\r\n            super(injector);\r\n            this.placeService = placeService;\r\n            this.sanitizer = sanitizer;\r\n            this.geolocationService = geolocationService;\r\n            this.reviewService = reviewService;\r\n            this.gallery = gallery;\r\n            this.localStorage = localStorage;\r\n            this.appConfigService = appConfigService;\r\n            this.lightboxService = lightboxService;\r\n            this.zone = zone;\r\n            this.socialSharing = socialSharing;\r\n            this.apiKey = environment[\"a\" /* environment */].googleMapsApiKey;\r\n            this.images = [];\r\n            this.rating = 0;\r\n            this.isLiked = false;\r\n            this.isStarred = false;\r\n            this.reviews = [];\r\n            this.slidesConfig = {};\r\n            this.webSocialShare = {\r\n                show: false,\r\n                share: {\r\n                    config: [{\r\n                            facebook: {\r\n                                socialShareUrl: '',\r\n                            },\r\n                        }, {\r\n                            twitter: {\r\n                                socialShareUrl: '',\r\n                            }\r\n                        }, {\r\n                            whatsapp: {\r\n                                socialShareText: '',\r\n                                socialShareUrl: '',\r\n                            }\r\n                        }, {\r\n                            copy: {\r\n                                socialShareUrl: '',\r\n                            }\r\n                        }]\r\n                },\r\n                onClosed: () => {\r\n                    this.webSocialShare.show = false;\r\n                }\r\n            };\r\n            this.sliderGalleryOpts = {\r\n                allowSlidePrev: false,\r\n                allowSlideNext: false,\r\n                zoom: {\r\n                    maxRatio: 3\r\n                },\r\n            };\r\n            this.isReviewsEnabled = true;\r\n            this.skeletonImages = Array(6);\r\n            this.skeletonReviews = Array(5);\r\n        }\r\n        ngOnDestroy() {\r\n            this.lightboxSubscriptionOpen.unsubscribe();\r\n            this.lightboxSubscriptionClosed.unsubscribe();\r\n            document.removeEventListener('ionBackButton', this.backButtonListener);\r\n        }\r\n        ngOnInit() {\r\n            this.setupObservable();\r\n            this.setupGallery();\r\n            this.setupDistanceUnit();\r\n        }\r\n        ionViewDidEnter() {\r\n            return Object(tslib_es6[\"a\" /* __awaiter */])(this, void 0, void 0, function* () {\r\n                if (!this.place) {\r\n                    this.setupSlider();\r\n                    yield this.showLoadingView({ showOverlay: false });\r\n                    this.loadPlace();\r\n                    this.loadLocation();\r\n                }\r\n                else {\r\n                    this.setPageTitle(this.place.title);\r\n                    this.setMetaTags({\r\n                        title: this.place.title,\r\n                        description: this.place.description,\r\n                        image: this.place.image ? this.place.image.url() : '',\r\n                        slug: this.place.getSlug()\r\n                    });\r\n                }\r\n            });\r\n        }\r\n        enableMenuSwipe() {\r\n            return false;\r\n        }\r\n        onSlidesDidLoad() {\r\n            this.contentLoaded.next();\r\n        }\r\n        onSlidesDrag() {\r\n            this.contentLoaded.next();\r\n        }\r\n        setupDistanceUnit() {\r\n            return Object(tslib_es6[\"a\" /* __awaiter */])(this, void 0, void 0, function* () {\r\n                let unit = null;\r\n                try {\r\n                    unit = yield this.localStorage.getUnit();\r\n                    if (unit === null) {\r\n                        unit = environment[\"a\" /* environment */].defaultUnit;\r\n                    }\r\n                }\r\n                catch (error) {\r\n                    unit = environment[\"a\" /* environment */].defaultUnit;\r\n                }\r\n                this.preference.unit = unit;\r\n            });\r\n        }\r\n        setupObservable() {\r\n            this.contentLoaded = new Subject[\"a\" /* Subject */]();\r\n            this.loadAndScroll = Object(merge[\"a\" /* merge */])(this.container.ionScroll, this.contentLoaded);\r\n        }\r\n        setupGallery() {\r\n            const config = {\r\n                gestures: false,\r\n                imageSize: ImageSize.Cover,\r\n                thumbPosition: ThumbnailsPosition.Bottom,\r\n                itemTemplate: this.itemGalleryTemplate,\r\n            };\r\n            const galleryRef = this.gallery.ref('placeGallery');\r\n            galleryRef.setConfig(config);\r\n            this.backButtonListener = (ev) => {\r\n                ev.detail.register(10, () => {\r\n                    this.zone.run(() => {\r\n                        if (this.isLightboxOpen) {\r\n                            this.lightboxService.close();\r\n                        }\r\n                        else {\r\n                            this.goBack();\r\n                        }\r\n                    });\r\n                });\r\n            };\r\n            document.addEventListener('ionBackButton', this.backButtonListener);\r\n            this.lightboxSubscriptionOpen = this.lightboxService.opened.subscribe(() => {\r\n                this.isLightboxOpen = true;\r\n            });\r\n            this.lightboxSubscriptionClosed = this.lightboxService.closed.subscribe(() => {\r\n                this.isLightboxOpen = false;\r\n            });\r\n        }\r\n        onContentLoaded() {\r\n            setTimeout(() => {\r\n                this.contentLoaded.next();\r\n            }, 400);\r\n        }\r\n        loadPlace() {\r\n            return Object(tslib_es6[\"a\" /* __awaiter */])(this, void 0, void 0, function* () {\r\n                try {\r\n                    const appConfig = yield this.appConfigService.load();\r\n                    if (appConfig && appConfig.reviews) {\r\n                        this.isReviewsEnabled = !appConfig.reviews.disabled;\r\n                    }\r\n                    this.place = yield this.placeService.loadOne(this.getParams().id);\r\n                    if (this.place.longDescription) {\r\n                        this.description = this.sanitizer\r\n                            .bypassSecurityTrustHtml(this.place.longDescription);\r\n                    }\r\n                    this.setPageTitle(this.place.title);\r\n                    this.setMetaTags({\r\n                        title: this.place.title,\r\n                        description: this.place.description,\r\n                        image: this.place.image ? this.place.image.url() : '',\r\n                        slug: this.place.getSlug()\r\n                    });\r\n                    this.webSocialShare.share.config.forEach((item) => {\r\n                        if (item.whatsapp) {\r\n                            item.whatsapp.socialShareUrl = this.getShareUrl(this.place.getSlug());\r\n                        }\r\n                        else if (item.facebook) {\r\n                            item.facebook.socialShareUrl = this.getShareUrl(this.place.getSlug());\r\n                        }\r\n                        else if (item.twitter) {\r\n                            item.twitter.socialShareUrl = this.getShareUrl(this.place.getSlug());\r\n                        }\r\n                        else if (item.copy) {\r\n                            item.copy.socialShareUrl = this.getShareUrl(this.place.getSlug());\r\n                        }\r\n                    });\r\n                    this.rating = this.place.rating;\r\n                    if (user_service[\"a\" /* User */].getCurrent()) {\r\n                        this.checkIfIsLiked();\r\n                        this.checkIfIsStarred();\r\n                    }\r\n                    this.loadReviews();\r\n                    if (this.place.image) {\r\n                        this.images.push(this.place.image);\r\n                    }\r\n                    if (this.place.imageTwo) {\r\n                        this.images.push(this.place.imageTwo);\r\n                    }\r\n                    if (this.place.imageThree) {\r\n                        this.images.push(this.place.imageThree);\r\n                    }\r\n                    if (this.place.imageFour) {\r\n                        this.images.push(this.place.imageFour);\r\n                    }\r\n                    if (Array.isArray(this.place.images) && this.place.images.length) {\r\n                        this.images.push(...this.place.images);\r\n                    }\r\n                    this.showContentView();\r\n                    this.onContentLoaded();\r\n                    this.onRefreshComplete(this.place);\r\n                }\r\n                catch (err) {\r\n                    if (err.code === 101) {\r\n                        this.showEmptyView();\r\n                    }\r\n                    else {\r\n                        this.showErrorView();\r\n                    }\r\n                    this.onRefreshComplete();\r\n                }\r\n            });\r\n        }\r\n        setupSlider() {\r\n            this.slidesConfig = {\r\n                grabCursor: true,\r\n                slidesPerView: 2.5,\r\n                slidesOffsetBefore: 16,\r\n                breakpointsInverse: true,\r\n                zoom: false,\r\n                touchStartPreventDefault: false,\r\n                breakpoints: {\r\n                    // when window width is >= 320px\r\n                    320: {\r\n                        slidesPerView: 2.4,\r\n                        spaceBetween: 6\r\n                    },\r\n                    // when window width is >= 400px\r\n                    400: {\r\n                        slidesPerView: 2.5,\r\n                        spaceBetween: 5\r\n                    },\r\n                    // when window width is >= 640px\r\n                    600: {\r\n                        slidesPerView: 3.5,\r\n                        spaceBetween: 10\r\n                    },\r\n                    800: {\r\n                        slidesPerView: 4.5,\r\n                        spaceBetween: 10\r\n                    }\r\n                }\r\n            };\r\n        }\r\n        checkIfIsLiked() {\r\n            return Object(tslib_es6[\"a\" /* __awaiter */])(this, void 0, void 0, function* () {\r\n                try {\r\n                    const isLiked = yield this.placeService.isLiked(this.place);\r\n                    this.isLiked = isLiked;\r\n                }\r\n                catch (err) {\r\n                    console.warn(err.message);\r\n                }\r\n            });\r\n        }\r\n        checkIfIsStarred() {\r\n            return Object(tslib_es6[\"a\" /* __awaiter */])(this, void 0, void 0, function* () {\r\n                try {\r\n                    const isStarred = yield this.placeService.isStarred(this.place);\r\n                    this.isStarred = isStarred;\r\n                }\r\n                catch (err) {\r\n                    console.warn(err.message);\r\n                }\r\n            });\r\n        }\r\n        loadLocation() {\r\n            return Object(tslib_es6[\"a\" /* __awaiter */])(this, void 0, void 0, function* () {\r\n                try {\r\n                    const coords = yield this.geolocationService.getCurrentPosition();\r\n                    this.location = coords;\r\n                }\r\n                catch (err) {\r\n                    console.warn(err);\r\n                }\r\n            });\r\n        }\r\n        loadReviews() {\r\n            return Object(tslib_es6[\"a\" /* __awaiter */])(this, void 0, void 0, function* () {\r\n                try {\r\n                    this.reviews = yield this.reviewService.load({\r\n                        place: this.place, limit: 5\r\n                    });\r\n                }\r\n                catch (err) {\r\n                    console.warn(err.message);\r\n                }\r\n            });\r\n        }\r\n        openSignInModal() {\r\n            return Object(tslib_es6[\"a\" /* __awaiter */])(this, void 0, void 0, function* () {\r\n                yield this.showLoadingView({ showOverlay: true });\r\n                const modal = yield this.modalCtrl.create({\r\n                    component: sign_in[\"a\" /* SignInPage */]\r\n                });\r\n                yield modal.present();\r\n                yield this.dismissLoadingView();\r\n            });\r\n        }\r\n        openAddReviewModal() {\r\n            return Object(tslib_es6[\"a\" /* __awaiter */])(this, void 0, void 0, function* () {\r\n                yield this.showLoadingView({ showOverlay: true });\r\n                const modal = yield this.modalCtrl.create({\r\n                    component: review_add_ReviewAddPage,\r\n                    componentProps: {\r\n                        place: this.place\r\n                    }\r\n                });\r\n                yield modal.present();\r\n                yield this.dismissLoadingView();\r\n                const { data } = yield modal.onWillDismiss();\r\n                if (data) {\r\n                    this.reviews.unshift(data);\r\n                }\r\n            });\r\n        }\r\n        openShareModal() {\r\n            return Object(tslib_es6[\"a\" /* __awaiter */])(this, void 0, void 0, function* () {\r\n                yield this.showLoadingView({ showOverlay: true });\r\n                const modal = yield this.modalCtrl.create({\r\n                    component: share_page[\"a\" /* SharePage */],\r\n                });\r\n                yield modal.present();\r\n                yield this.dismissLoadingView();\r\n            });\r\n        }\r\n        onLike() {\r\n            if (user_service[\"a\" /* User */].getCurrent()) {\r\n                this.isLiked = !this.isLiked;\r\n                this.placeService.like(this.place);\r\n            }\r\n            else {\r\n                this.openSignInModal();\r\n            }\r\n        }\r\n        onRate() {\r\n            if (user_service[\"a\" /* User */].getCurrent()) {\r\n                this.openAddReviewModal();\r\n            }\r\n            else {\r\n                this.openSignInModal();\r\n            }\r\n        }\r\n        onContentTouched(ev = {}) {\r\n            const href = ev.target.getAttribute('href');\r\n            if (href) {\r\n                ev.preventDefault();\r\n                this.openUrl(href);\r\n            }\r\n        }\r\n        onShare() {\r\n            return Object(tslib_es6[\"a\" /* __awaiter */])(this, void 0, void 0, function* () {\r\n                if (this.isCordova) {\r\n                    try {\r\n                        const url = this.getShareUrl(this.place.getSlug());\r\n                        yield this.socialSharing.share(null, null, null, url);\r\n                    }\r\n                    catch (err) {\r\n                        console.warn(err);\r\n                    }\r\n                }\r\n                else if (this.isPwa || this.isMobile) {\r\n                    this.webSocialShare.show = true;\r\n                }\r\n                else {\r\n                    this.openShareModal();\r\n                }\r\n            });\r\n        }\r\n        onCall() {\r\n            return Object(tslib_es6[\"a\" /* __awaiter */])(this, void 0, void 0, function* () {\r\n                this.openSimpleUrl('tel:' + this.place.phone);\r\n            });\r\n        }\r\n        onDirectionsButtonTouched() {\r\n            return Object(tslib_es6[\"a\" /* __awaiter */])(this, void 0, void 0, function* () {\r\n                const lat = this.place.location.latitude;\r\n                const lng = this.place.location.longitude;\r\n                const url = `https://maps.google.com/maps?q=${lat},${lng}`;\r\n                this.openSimpleUrl(url);\r\n            });\r\n        }\r\n        onReportButtonTouched() {\r\n            return Object(tslib_es6[\"a\" /* __awaiter */])(this, void 0, void 0, function* () {\r\n                if (!user_service[\"a\" /* User */].getCurrent()) {\r\n                    return this.openSignInModal();\r\n                }\r\n                const str = yield this.getTrans([\r\n                    'REPORT_LISTING', 'REPORT_REASON',\r\n                    'CONFIRM', 'DISMISS'\r\n                ]);\r\n                const { value: text } = yield this.showSweetTextArea(str.REPORT_PROFILE, str.REPORT_REASON, str.CONFIRM, str.DISMISS);\r\n                if (text) {\r\n                    try {\r\n                        const report = new report_service_Report;\r\n                        report.place = this.place;\r\n                        report.reason = text;\r\n                        yield report.save();\r\n                        this.translate.get('SENT').subscribe(str => this.showToast(str));\r\n                    }\r\n                    catch (error) {\r\n                        this.translate.get('ERROR_NETWORK').subscribe(str => this.showToast(str));\r\n                    }\r\n                }\r\n            });\r\n        }\r\n    }\r\n    PlaceDetailPage.ɵfac = function PlaceDetailPage_Factory(t) { return new (t || PlaceDetailPage)(core[\"Pb\" /* ɵɵdirectiveInject */](core[\"t\" /* Injector */]), core[\"Pb\" /* ɵɵdirectiveInject */](place_service[\"a\" /* Place */]), core[\"Pb\" /* ɵɵdirectiveInject */](platform_browser[\"b\" /* DomSanitizer */]), core[\"Pb\" /* ɵɵdirectiveInject */](geolocation_service[\"a\" /* GeolocationService */]), core[\"Pb\" /* ɵɵdirectiveInject */](review_service[\"a\" /* Review */]), core[\"Pb\" /* ɵɵdirectiveInject */](ng_gallery_Gallery), core[\"Pb\" /* ɵɵdirectiveInject */](local_storage[\"a\" /* LocalStorage */]), core[\"Pb\" /* ɵɵdirectiveInject */](app_config_service[\"a\" /* AppConfigService */]), core[\"Pb\" /* ɵɵdirectiveInject */](ng_gallery_lightbox_Lightbox), core[\"Pb\" /* ɵɵdirectiveInject */](core[\"B\" /* NgZone */]), core[\"Pb\" /* ɵɵdirectiveInject */](ngx[\"a\" /* SocialSharing */])); };\r\n    PlaceDetailPage.ɵcmp = core[\"Jb\" /* ɵɵdefineComponent */]({ type: PlaceDetailPage, selectors: [[\"place-detail-page\"]], viewQuery: function PlaceDetailPage_Query(rf, ctx) {\r\n            if (rf & 1) {\r\n                core[\"Kc\" /* ɵɵviewQuery */](ionic_angular[\"r\" /* IonContent */], 3);\r\n                core[\"Kc\" /* ɵɵviewQuery */](place_detail_c0, 3);\r\n            }\r\n            if (rf & 2) {\r\n                let _t;\r\n                core[\"tc\" /* ɵɵqueryRefresh */](_t = core[\"ec\" /* ɵɵloadQuery */]()) && (ctx.container = _t.first);\r\n                core[\"tc\" /* ɵɵqueryRefresh */](_t = core[\"ec\" /* ɵɵloadQuery */]()) && (ctx.itemGalleryTemplate = _t.first);\r\n            }\r\n        }, features: [core[\"Ab\" /* ɵɵInheritDefinitionFeature */]], decls: 29, vars: 12, consts: [[1, \"ion-no-border\"], [\"color\", \"primary\", \"fixed\", \"\"], [\"slot\", \"start\"], [\"defaultHref\", \"/\"], [\"slot\", \"end\"], [3, \"disabled\", \"click\"], [\"slot\", \"icon-only\", 3, \"name\"], [1, \"btn-share\", 3, \"disabled\", \"click\"], [\"slot\", \"icon-only\", \"name\", \"share-social-outline\"], [\"scrollEvents\", \"true\"], [\"container\", \"\"], [\"icon\", \"alert-circle-outline\", 3, \"text\", 4, \"ngIf\"], [\"itemGalleryTemplate\", \"\"], [3, \"show\", \"share\", \"closed\"], [\"name\", \"logo-facebook\", \"slot\", \"facebook\", 1, \"block\", 2, \"color\", \"var(--ion-color-fb)\", \"width\", \"36px\", \"height\", \"36px\"], [\"name\", \"logo-twitter\", \"slot\", \"twitter\", 1, \"block\", 2, \"color\", \"var(--ion-color-twitter)\", \"width\", \"36px\", \"height\", \"36px\"], [\"name\", \"logo-whatsapp\", \"slot\", \"whatsapp\", 1, \"block\", 2, \"color\", \"var(--ion-color-whatsapp)\", \"width\", \"36px\", \"height\", \"36px\"], [\"name\", \"copy-outline\", \"slot\", \"copy\", 1, \"block\", 2, \"color\", \"var(--ion-color-medium)\", \"width\", \"36px\", \"height\", \"36px\"], [\"fixed\", \"\"], [1, \"ion-justify-content-center\"], [\"size-xs\", \"12\", \"size-lg\", \"10\"], [\"class\", \"light-bg radius ion-padding\", 4, \"ngIf\"], [4, \"ngIf\"], [\"class\", \"ion-margin-top\", 4, \"ngIf\"], [\"icon\", \"alert-circle-outline\", 3, \"text\"], [2, \"width\", \"100%\", \"height\", \"100%\", 3, \"options\"], [1, \"swiper-zoom-container\"], [2, \"width\", \"100%\", \"height\", \"100%\", \"object-fit\", \"contain\", 3, \"src\"], [1, \"light-bg\", \"radius\", \"ion-padding\"], [1, \"ion-nowrap\"], [\"size-xs\", \"6\", \"size-sm\", \"6\", \"size-md\", \"6\", \"size-lg\", \"2\", 4, \"ngFor\", \"ngForOf\"], [1, \"skeleton-item\"], [1, \"wrapper\"], [1, \"avatar\"], [\"appearance\", \"circle\", 3, \"theme\"], [1, \"title\"], [3, \"theme\"], [\"size\", \"4\", 1, \"ion-text-center\"], [\"size-xs\", \"6\", \"size-sm\", \"6\", \"size-md\", \"6\", \"size-lg\", \"2\"], [\"count\", \"1\", \"appearance\", \"circle\", 3, \"theme\"], [\"class\", \"skeleton-item light-bg radius\", 4, \"ngFor\", \"ngForOf\"], [1, \"skeleton-item\", \"light-bg\", \"radius\"], [\"size\", \"12\"], [1, \"light-bg\", \"radius\", \"ion-padding-vertical\", \"fade-in\"], [\"pager\", \"false\", \"gallerize\", \"placeGallery\", \"selector\", \".bg-img\", 3, \"options\", \"ionSlidesDidLoad\", \"ionSlideDrag\"], [4, \"ngFor\", \"ngForOf\"], [1, \"ion-padding\"], [\"lines\", \"none\", \"color\", \"light\", 1, \"ion-margin-vertical\"], [\"class\", \"img-featured\", \"slot\", \"start\", 4, \"ngIf\"], [1, \"ion-text-nowrap\"], [\"color\", \"dark\"], [1, \"bold\", \"ellipsis\"], [\"color\", \"medium\"], [1, \"text-medium\", \"bold\", \"ion-margin-top\"], [1, \"text-medium\", \"bold\"], [\"class\", \"rating\", 3, \"rate\", \"readOnly\", \"max\", \"theme\", 4, \"ngIf\"], [1, \"ion-text-wrap\", \"ion-margin-top\"], [\"class\", \"html-content\", 3, \"innerHTML\", \"click\", 4, \"ngIf\"], [\"defaultImage\", \"./assets/img/placeholder.png\", 1, \"bg-img\", \"radius\", 3, \"lazyLoad\", \"customObservable\"], [\"slot\", \"start\", 1, \"img-featured\"], [\"defaultImage\", \"./assets/img/placeholder.png\", 3, \"alt\", \"lazyLoad\", \"customObservable\"], [1, \"rating\", 3, \"rate\", \"readOnly\", \"max\", \"theme\"], [1, \"html-content\", 3, \"innerHTML\", \"click\"], [1, \"ion-margin-top\"], [\"size-xs\", \"12\", \"size-lg\", \"7\", 4, \"ngIf\"], [\"size-xs\", \"12\", \"size-lg\", \"5\"], [3, \"src\"], [\"color\", \"light\", 1, \"ion-no-margin\"], [\"color\", \"light\", 4, \"ngIf\"], [\"color\", \"light\", 3, \"click\", 4, \"ngIf\"], [1, \"ion-text-center\"], [\"strong\", \"\", \"fill\", \"clear\", \"color\", \"dark\", 3, \"click\"], [1, \"ion-text-capitalize\"], [\"size-xs\", \"12\", \"size-lg\", \"7\"], [1, \"ion-align-items-center\"], [\"size-xs\", \"6\", \"size-md\", \"8\", \"size-lg\", \"8\"], [\"no-margin\", \"\"], [\"name\", \"chatbubbles\", 1, \"text-medium\"], [\"size-xs\", \"6\", \"size-md\", \"4\", \"size-lg\", \"4\", \"text-end\", \"\"], [\"size\", \"small\", \"expand\", \"block\", \"shape\", \"round\", \"color\", \"secondary\", 1, \"bold\", 3, \"click\"], [\"style\", \"height:170px;\", \"class\", \"ion-text-center\", 4, \"ngIf\"], [1, \"ion-no-margin\"], [\"class\", \"radius light-bg\", 4, \"ngFor\", \"ngForOf\"], [\"class\", \"ion-text-center\", 4, \"ngIf\"], [1, \"ion-text-center\", 2, \"height\", \"170px\"], [1, \"flex-center\"], [1, \"text-medium\"], [1, \"radius\", \"light-bg\"], [\"color\", \"light\"], [\"defaultImage\", \"./assets/img/avatar.png\", 3, \"alt\", \"lazyLoad\", \"customObservable\"], [1, \"ion-text-wrap\"], [\"color\", \"medium\", 1, \"ion-float-end\"], [1, \"text-small\"], [1, \"bold\", \"no-margin\"], [1, \"text-medium\", \"no-margin\"], [\"fill\", \"clear\", \"color\", \"dark\", 1, \"bold\", 3, \"routerLink\"], [\"slot\", \"end\", \"name\", \"chevron-forward\"], [\"slot\", \"start\", \"name\", \"map\"], [\"color\", \"primary\"], [1, \"text-medium\", \"link\", 3, \"click\"], [\"color\", \"light\", 3, \"click\"], [\"slot\", \"start\", \"name\", \"globe\"], [1, \"text-medium\", \"link\"], [\"slot\", \"start\", \"name\", \"call\"], [\"slot\", \"start\", \"name\", \"logo-facebook\"], [\"slot\", \"start\", \"name\", \"logo-instagram\"], [\"slot\", \"start\", \"name\", \"logo-youtube\"]], template: function PlaceDetailPage_Template(rf, ctx) {\r\n            if (rf & 1) {\r\n                core[\"Vb\" /* ɵɵelementStart */](0, \"ion-header\", 0);\r\n                core[\"Vb\" /* ɵɵelementStart */](1, \"ion-toolbar\", 1);\r\n                core[\"Vb\" /* ɵɵelementStart */](2, \"ion-buttons\", 2);\r\n                core[\"Qb\" /* ɵɵelement */](3, \"ion-back-button\", 3);\r\n                core[\"Ub\" /* ɵɵelementEnd */]();\r\n                core[\"Vb\" /* ɵɵelementStart */](4, \"ion-title\");\r\n                core[\"Gc\" /* ɵɵtext */](5);\r\n                core[\"Ub\" /* ɵɵelementEnd */]();\r\n                core[\"Vb\" /* ɵɵelementStart */](6, \"ion-buttons\", 4);\r\n                core[\"Vb\" /* ɵɵelementStart */](7, \"ion-button\", 5);\r\n                core[\"dc\" /* ɵɵlistener */](\"click\", function PlaceDetailPage_Template_ion_button_click_7_listener() { return ctx.onLike(); });\r\n                core[\"Qb\" /* ɵɵelement */](8, \"ion-icon\", 6);\r\n                core[\"Ub\" /* ɵɵelementEnd */]();\r\n                core[\"Vb\" /* ɵɵelementStart */](9, \"ion-button\", 7);\r\n                core[\"dc\" /* ɵɵlistener */](\"click\", function PlaceDetailPage_Template_ion_button_click_9_listener() { return ctx.onShare(); });\r\n                core[\"Qb\" /* ɵɵelement */](10, \"ion-icon\", 8);\r\n                core[\"Ub\" /* ɵɵelementEnd */]();\r\n                core[\"Ub\" /* ɵɵelementEnd */]();\r\n                core[\"Ub\" /* ɵɵelementEnd */]();\r\n                core[\"Ub\" /* ɵɵelementEnd */]();\r\n                core[\"Vb\" /* ɵɵelementStart */](11, \"ion-content\", 9, 10);\r\n                core[\"Ec\" /* ɵɵtemplate */](13, PlaceDetailPage_empty_view_13_Template, 2, 3, \"empty-view\", 11);\r\n                core[\"Ec\" /* ɵɵtemplate */](14, PlaceDetailPage_empty_view_14_Template, 2, 3, \"empty-view\", 11);\r\n                core[\"Ec\" /* ɵɵtemplate */](15, PlaceDetailPage_ng_template_15_Template, 5, 2, \"ng-template\", null, 12, core[\"Fc\" /* ɵɵtemplateRefExtractor */]);\r\n                core[\"Vb\" /* ɵɵelementStart */](17, \"web-social-share\", 13);\r\n                core[\"dc\" /* ɵɵlistener */](\"closed\", function PlaceDetailPage_Template_web_social_share_closed_17_listener() { return ctx.webSocialShare.onClosed(); });\r\n                core[\"Qb\" /* ɵɵelement */](18, \"ion-icon\", 14);\r\n                core[\"Qb\" /* ɵɵelement */](19, \"ion-icon\", 15);\r\n                core[\"Qb\" /* ɵɵelement */](20, \"ion-icon\", 16);\r\n                core[\"Qb\" /* ɵɵelement */](21, \"ion-icon\", 17);\r\n                core[\"Ub\" /* ɵɵelementEnd */]();\r\n                core[\"Vb\" /* ɵɵelementStart */](22, \"ion-grid\", 18);\r\n                core[\"Vb\" /* ɵɵelementStart */](23, \"ion-row\", 19);\r\n                core[\"Vb\" /* ɵɵelementStart */](24, \"ion-col\", 20);\r\n                core[\"Ec\" /* ɵɵtemplate */](25, PlaceDetailPage_section_25_Template, 22, 13, \"section\", 21);\r\n                core[\"Ec\" /* ɵɵtemplate */](26, PlaceDetailPage_section_26_Template, 2, 1, \"section\", 22);\r\n                core[\"Ec\" /* ɵɵtemplate */](27, PlaceDetailPage_section_27_Template, 27, 11, \"section\", 22);\r\n                core[\"Ec\" /* ɵɵtemplate */](28, PlaceDetailPage_section_28_Template, 18, 13, \"section\", 23);\r\n                core[\"Ub\" /* ɵɵelementEnd */]();\r\n                core[\"Ub\" /* ɵɵelementEnd */]();\r\n                core[\"Ub\" /* ɵɵelementEnd */]();\r\n                core[\"Ub\" /* ɵɵelementEnd */]();\r\n            }\r\n            if (rf & 2) {\r\n                core[\"Db\" /* ɵɵadvance */](5);\r\n                core[\"Hc\" /* ɵɵtextInterpolate */](ctx.place == null ? null : ctx.place.title);\r\n                core[\"Db\" /* ɵɵadvance */](2);\r\n                core[\"lc\" /* ɵɵproperty */](\"disabled\", !ctx.place);\r\n                core[\"Db\" /* ɵɵadvance */](1);\r\n                core[\"lc\" /* ɵɵproperty */](\"name\", ctx.isLiked ? \"heart\" : \"heart-outline\");\r\n                core[\"Db\" /* ɵɵadvance */](1);\r\n                core[\"lc\" /* ɵɵproperty */](\"disabled\", !ctx.place);\r\n                core[\"Db\" /* ɵɵadvance */](4);\r\n                core[\"lc\" /* ɵɵproperty */](\"ngIf\", ctx.isEmptyViewVisible);\r\n                core[\"Db\" /* ɵɵadvance */](1);\r\n                core[\"lc\" /* ɵɵproperty */](\"ngIf\", ctx.isErrorViewVisible);\r\n                core[\"Db\" /* ɵɵadvance */](3);\r\n                core[\"lc\" /* ɵɵproperty */](\"show\", ctx.webSocialShare.show)(\"share\", ctx.webSocialShare.share);\r\n                core[\"Db\" /* ɵɵadvance */](8);\r\n                core[\"lc\" /* ɵɵproperty */](\"ngIf\", ctx.isLoadingViewVisible);\r\n                core[\"Db\" /* ɵɵadvance */](1);\r\n                core[\"lc\" /* ɵɵproperty */](\"ngIf\", ctx.isLoadingViewVisible);\r\n                core[\"Db\" /* ɵɵadvance */](1);\r\n                core[\"lc\" /* ɵɵproperty */](\"ngIf\", ctx.isContentViewVisible);\r\n                core[\"Db\" /* ɵɵadvance */](1);\r\n                core[\"lc\" /* ɵɵproperty */](\"ngIf\", ctx.isContentViewVisible);\r\n            }\r\n        }, directives: [ionic_angular[\"w\" /* IonHeader */], ionic_angular[\"db\" /* IonToolbar */], ionic_angular[\"l\" /* IonButtons */], ionic_angular[\"h\" /* IonBackButton */], ionic_angular[\"i\" /* IonBackButtonDelegate */], ionic_angular[\"bb\" /* IonTitle */], ionic_angular[\"k\" /* IonButton */], ionic_angular[\"x\" /* IonIcon */], ionic_angular[\"r\" /* IonContent */], common[\"m\" /* NgIf */], ionic_angular[\"v\" /* IonGrid */], ionic_angular[\"O\" /* IonRow */], ionic_angular[\"q\" /* IonCol */], empty_view[\"a\" /* EmptyView */], ionic_angular[\"T\" /* IonSlides */], ionic_angular[\"S\" /* IonSlide */], common[\"l\" /* NgForOf */], ngx_skeleton_loader[\"a\" /* NgxSkeletonLoaderComponent */], ng_gallery_lightbox_GallerizeDirective, ionic_angular[\"B\" /* IonItem */], ionic_angular[\"E\" /* IonLabel */], ionic_angular[\"Y\" /* IonText */], ng_lazyload_image[\"b\" /* LazyLoadImageDirective */], ionic_angular[\"ab\" /* IonThumbnail */], ngx_bar_rating[\"a\" /* BarRating */], ionic_angular[\"F\" /* IonList */], ionic_angular[\"g\" /* IonAvatar */], ionic_angular[\"lb\" /* RouterLinkDelegate */], router[\"i\" /* RouterLink */]], pipes: [ngx_translate_core[\"c\" /* TranslatePipe */], common[\"f\" /* DatePipe */]], styles: [\"ion-grid[_ngcontent-%COMP%]{padding:0}ion-slides[_ngcontent-%COMP%]{height:auto}ion-slides[_ngcontent-%COMP%]   .bg-img[_ngcontent-%COMP%]{background-size:cover;background-position:50%;height:150px;width:150px}ion-slides[_ngcontent-%COMP%]   .swiper-pagination-bullet-active[_ngcontent-%COMP%]{background:var(--ion-color-light)}ion-avatar[_ngcontent-%COMP%]{margin:0 12px 0 0!important}ion-avatar[_ngcontent-%COMP%]   img[_ngcontent-%COMP%]{background:var(--ion-color-dark)}ion-thumbnail[_ngcontent-%COMP%]{--border-radius:6px;width:80px;height:80px}ion-list[_ngcontent-%COMP%]{background:var(--ion-color-light)}ion-item[_ngcontent-%COMP%]{--padding-start:0}ion-row[nowrap][_ngcontent-%COMP%]{overflow:hidden}.flex-start[_ngcontent-%COMP%]{display:flex;align-items:flex-start}.review-count[_ngcontent-%COMP%]{margin-left:6px}.icon-share[_ngcontent-%COMP%]{font-size:48px}.skeleton-item[_ngcontent-%COMP%]{width:auto;height:auto;margin:10px auto;padding:10px}.skeleton-item[_ngcontent-%COMP%]   .wrapper[_ngcontent-%COMP%]{display:inline-flex;width:100%;height:auto;flex:1}.skeleton-item[_ngcontent-%COMP%]   .wrapper[_ngcontent-%COMP%]   .avatar[_ngcontent-%COMP%]{width:100px;height:90px}.skeleton-item[_ngcontent-%COMP%]   .wrapper[_ngcontent-%COMP%]   .title[_ngcontent-%COMP%]{width:100%;padding:10px;height:80px}@media (min-width:992px){ion-thumbnail[_ngcontent-%COMP%]{width:100px;height:100px}}\"] });\r\n    return PlaceDetailPage;\r\n})();\r\n\n// EXTERNAL MODULE: ./src/app/shared.module.ts + 3 modules\nvar shared_module = __webpack_require__(\"d2mR\");\n\n// CONCATENATED MODULE: ./src/app/pages/review-add/review-add.module.ts\n\r\n\r\n\r\nlet review_add_module_ReviewAddPageModule = /*@__PURE__*/ (() => {\r\n    class ReviewAddPageModule {\r\n    }\r\n    ReviewAddPageModule.ɵmod = core[\"Nb\" /* ɵɵdefineNgModule */]({ type: ReviewAddPageModule });\r\n    ReviewAddPageModule.ɵinj = core[\"Mb\" /* ɵɵdefineInjector */]({ factory: function ReviewAddPageModule_Factory(t) { return new (t || ReviewAddPageModule)(); }, imports: [[\r\n                shared_module[\"a\" /* SharedModule */],\r\n                fesm2015_forms[\"e\" /* FormsModule */],\r\n            ]] });\r\n    return ReviewAddPageModule;\r\n})();\r\n\n// EXTERNAL MODULE: ./src/app/pages/sign-in/sign-in.module.ts + 2 modules\nvar sign_in_module = __webpack_require__(\"b8Qw\");\n\n// EXTERNAL MODULE: ./src/app/pages/share/share.module.ts + 2 modules\nvar share_module = __webpack_require__(\"Hr7V\");\n\n// CONCATENATED MODULE: ./src/app/pages/place-detail/place-detail.module.ts\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nlet place_detail_module_PlaceDetailPageModule = /*@__PURE__*/ (() => {\r\n    class PlaceDetailPageModule {\r\n    }\r\n    PlaceDetailPageModule.ɵmod = core[\"Nb\" /* ɵɵdefineNgModule */]({ type: PlaceDetailPageModule });\r\n    PlaceDetailPageModule.ɵinj = core[\"Mb\" /* ɵɵdefineInjector */]({ factory: function PlaceDetailPageModule_Factory(t) { return new (t || PlaceDetailPageModule)(); }, imports: [[\r\n                shared_module[\"a\" /* SharedModule */],\r\n                review_add_module_ReviewAddPageModule,\r\n                sign_in_module[\"a\" /* SignInPageModule */],\r\n                share_module[\"a\" /* SharePageModule */],\r\n                ng_gallery_GalleryModule,\r\n                ng_gallery_lightbox_LightboxModule,\r\n                router[\"j\" /* RouterModule */].forChild([\r\n                    {\r\n                        path: '',\r\n                        component: place_detail_PlaceDetailPage\r\n                    }\r\n                ])\r\n            ]] });\r\n    return PlaceDetailPageModule;\r\n})();\r\n\n\n/***/ })\n\n}]);","inputSourceMap":null}